<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - lcov-build.info - drivers/driver.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">drivers</a> - driver.h<span style="font-size: 80%;"> (source / <a href="driver.h.func-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">lcov-build.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryLo">0.0&nbsp;%</td>
            <td class="headerCovTableEntry">29</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2024-10-21 16:38:54</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryLo">0.0&nbsp;%</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
                  <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : /*</span>
<span id="L2"><span class="lineNum">       2</span>              :  * Driver interface definition</span>
<span id="L3"><span class="lineNum">       3</span>              :  * Copyright (c) 2003-2017, Jouni Malinen &lt;j@w1.fi&gt;</span>
<span id="L4"><span class="lineNum">       4</span>              :  *</span>
<span id="L5"><span class="lineNum">       5</span>              :  * This software may be distributed under the terms of the BSD license.</span>
<span id="L6"><span class="lineNum">       6</span>              :  * See README for more details.</span>
<span id="L7"><span class="lineNum">       7</span>              :  *</span>
<span id="L8"><span class="lineNum">       8</span>              :  * This file defines a driver interface used by both %wpa_supplicant and</span>
<span id="L9"><span class="lineNum">       9</span>              :  * hostapd. The first part of the file defines data structures used in various</span>
<span id="L10"><span class="lineNum">      10</span>              :  * driver operations. This is followed by the struct wpa_driver_ops that each</span>
<span id="L11"><span class="lineNum">      11</span>              :  * driver wrapper will beed to define with callback functions for requesting</span>
<span id="L12"><span class="lineNum">      12</span>              :  * driver operations. After this, there are definitions for driver event</span>
<span id="L13"><span class="lineNum">      13</span>              :  * reporting with wpa_supplicant_event() and some convenience helper functions</span>
<span id="L14"><span class="lineNum">      14</span>              :  * that can be used to report events.</span>
<span id="L15"><span class="lineNum">      15</span>              :  */</span>
<span id="L16"><span class="lineNum">      16</span>              : </span>
<span id="L17"><span class="lineNum">      17</span>              : #ifndef DRIVER_H</span>
<span id="L18"><span class="lineNum">      18</span>              : #define DRIVER_H</span>
<span id="L19"><span class="lineNum">      19</span>              : </span>
<span id="L20"><span class="lineNum">      20</span>              : #define WPA_SUPPLICANT_DRIVER_VERSION 4</span>
<span id="L21"><span class="lineNum">      21</span>              : </span>
<span id="L22"><span class="lineNum">      22</span>              : #include &quot;common/defs.h&quot;</span>
<span id="L23"><span class="lineNum">      23</span>              : #include &quot;common/ieee802_11_defs.h&quot;</span>
<span id="L24"><span class="lineNum">      24</span>              : #include &quot;common/wpa_common.h&quot;</span>
<span id="L25"><span class="lineNum">      25</span>              : #ifdef CONFIG_MACSEC</span>
<span id="L26"><span class="lineNum">      26</span>              : #include &quot;pae/ieee802_1x_kay.h&quot;</span>
<span id="L27"><span class="lineNum">      27</span>              : #endif /* CONFIG_MACSEC */</span>
<span id="L28"><span class="lineNum">      28</span>              : #include &quot;utils/list.h&quot;</span>
<span id="L29"><span class="lineNum">      29</span>              : </span>
<span id="L30"><span class="lineNum">      30</span>              : #define HOSTAPD_CHAN_DISABLED 0x00000001</span>
<span id="L31"><span class="lineNum">      31</span>              : #define HOSTAPD_CHAN_NO_IR 0x00000002</span>
<span id="L32"><span class="lineNum">      32</span>              : #define HOSTAPD_CHAN_RADAR 0x00000008</span>
<span id="L33"><span class="lineNum">      33</span>              : #define HOSTAPD_CHAN_HT40PLUS 0x00000010</span>
<span id="L34"><span class="lineNum">      34</span>              : #define HOSTAPD_CHAN_HT40MINUS 0x00000020</span>
<span id="L35"><span class="lineNum">      35</span>              : #define HOSTAPD_CHAN_HT40 0x00000040</span>
<span id="L36"><span class="lineNum">      36</span>              : #define HOSTAPD_CHAN_SURVEY_LIST_INITIALIZED 0x00000080</span>
<span id="L37"><span class="lineNum">      37</span>              : </span>
<span id="L38"><span class="lineNum">      38</span>              : #define HOSTAPD_CHAN_DFS_UNKNOWN 0x00000000</span>
<span id="L39"><span class="lineNum">      39</span>              : #define HOSTAPD_CHAN_DFS_USABLE 0x00000100</span>
<span id="L40"><span class="lineNum">      40</span>              : #define HOSTAPD_CHAN_DFS_UNAVAILABLE 0x00000200</span>
<span id="L41"><span class="lineNum">      41</span>              : #define HOSTAPD_CHAN_DFS_AVAILABLE 0x00000300</span>
<span id="L42"><span class="lineNum">      42</span>              : #define HOSTAPD_CHAN_DFS_MASK 0x00000300</span>
<span id="L43"><span class="lineNum">      43</span>              : </span>
<span id="L44"><span class="lineNum">      44</span>              : #define HOSTAPD_CHAN_VHT_10_70 0x00000800</span>
<span id="L45"><span class="lineNum">      45</span>              : #define HOSTAPD_CHAN_VHT_30_50 0x00001000</span>
<span id="L46"><span class="lineNum">      46</span>              : #define HOSTAPD_CHAN_VHT_50_30 0x00002000</span>
<span id="L47"><span class="lineNum">      47</span>              : #define HOSTAPD_CHAN_VHT_70_10 0x00004000</span>
<span id="L48"><span class="lineNum">      48</span>              : </span>
<span id="L49"><span class="lineNum">      49</span>              : #define HOSTAPD_CHAN_INDOOR_ONLY 0x00010000</span>
<span id="L50"><span class="lineNum">      50</span>              : #define HOSTAPD_CHAN_GO_CONCURRENT 0x00020000</span>
<span id="L51"><span class="lineNum">      51</span>              : </span>
<span id="L52"><span class="lineNum">      52</span>              : #define HOSTAPD_CHAN_VHT_10_150 0x00100000</span>
<span id="L53"><span class="lineNum">      53</span>              : #define HOSTAPD_CHAN_VHT_30_130 0x00200000</span>
<span id="L54"><span class="lineNum">      54</span>              : #define HOSTAPD_CHAN_VHT_50_110 0x00400000</span>
<span id="L55"><span class="lineNum">      55</span>              : #define HOSTAPD_CHAN_VHT_70_90  0x00800000</span>
<span id="L56"><span class="lineNum">      56</span>              : #define HOSTAPD_CHAN_VHT_90_70  0x01000000</span>
<span id="L57"><span class="lineNum">      57</span>              : #define HOSTAPD_CHAN_VHT_110_50 0x02000000</span>
<span id="L58"><span class="lineNum">      58</span>              : #define HOSTAPD_CHAN_VHT_130_30 0x04000000</span>
<span id="L59"><span class="lineNum">      59</span>              : #define HOSTAPD_CHAN_VHT_150_10 0x08000000</span>
<span id="L60"><span class="lineNum">      60</span>              : </span>
<span id="L61"><span class="lineNum">      61</span>              : /* Allowed bandwidth mask */</span>
<span id="L62"><span class="lineNum">      62</span>              : enum hostapd_chan_width_attr {</span>
<span id="L63"><span class="lineNum">      63</span>              :         HOSTAPD_CHAN_WIDTH_10   = BIT(0),</span>
<span id="L64"><span class="lineNum">      64</span>              :         HOSTAPD_CHAN_WIDTH_20   = BIT(1),</span>
<span id="L65"><span class="lineNum">      65</span>              :         HOSTAPD_CHAN_WIDTH_40P  = BIT(2),</span>
<span id="L66"><span class="lineNum">      66</span>              :         HOSTAPD_CHAN_WIDTH_40M  = BIT(3),</span>
<span id="L67"><span class="lineNum">      67</span>              :         HOSTAPD_CHAN_WIDTH_80   = BIT(4),</span>
<span id="L68"><span class="lineNum">      68</span>              :         HOSTAPD_CHAN_WIDTH_160  = BIT(5),</span>
<span id="L69"><span class="lineNum">      69</span>              : };</span>
<span id="L70"><span class="lineNum">      70</span>              : </span>
<span id="L71"><span class="lineNum">      71</span>              : /* Filter gratuitous ARP */</span>
<span id="L72"><span class="lineNum">      72</span>              : #define WPA_DATA_FRAME_FILTER_FLAG_ARP BIT(0)</span>
<span id="L73"><span class="lineNum">      73</span>              : /* Filter unsolicited Neighbor Advertisement */</span>
<span id="L74"><span class="lineNum">      74</span>              : #define WPA_DATA_FRAME_FILTER_FLAG_NA BIT(1)</span>
<span id="L75"><span class="lineNum">      75</span>              : /* Filter unicast IP packets encrypted using the GTK */</span>
<span id="L76"><span class="lineNum">      76</span>              : #define WPA_DATA_FRAME_FILTER_FLAG_GTK BIT(2)</span>
<span id="L77"><span class="lineNum">      77</span>              : </span>
<span id="L78"><span class="lineNum">      78</span>              : #define HOSTAPD_DFS_REGION_FCC  1</span>
<span id="L79"><span class="lineNum">      79</span>              : #define HOSTAPD_DFS_REGION_ETSI 2</span>
<span id="L80"><span class="lineNum">      80</span>              : #define HOSTAPD_DFS_REGION_JP   3</span>
<span id="L81"><span class="lineNum">      81</span>              : </span>
<span id="L82"><span class="lineNum">      82</span>              : /**</span>
<span id="L83"><span class="lineNum">      83</span>              :  * enum reg_change_initiator - Regulatory change initiator</span>
<span id="L84"><span class="lineNum">      84</span>              :  */</span>
<span id="L85"><span class="lineNum">      85</span>              : enum reg_change_initiator {</span>
<span id="L86"><span class="lineNum">      86</span>              :         REGDOM_SET_BY_CORE,</span>
<span id="L87"><span class="lineNum">      87</span>              :         REGDOM_SET_BY_USER,</span>
<span id="L88"><span class="lineNum">      88</span>              :         REGDOM_SET_BY_DRIVER,</span>
<span id="L89"><span class="lineNum">      89</span>              :         REGDOM_SET_BY_COUNTRY_IE,</span>
<span id="L90"><span class="lineNum">      90</span>              :         REGDOM_BEACON_HINT,</span>
<span id="L91"><span class="lineNum">      91</span>              : };</span>
<span id="L92"><span class="lineNum">      92</span>              : </span>
<span id="L93"><span class="lineNum">      93</span>              : /**</span>
<span id="L94"><span class="lineNum">      94</span>              :  * enum reg_type - Regulatory change types</span>
<span id="L95"><span class="lineNum">      95</span>              :  */</span>
<span id="L96"><span class="lineNum">      96</span>              : enum reg_type {</span>
<span id="L97"><span class="lineNum">      97</span>              :         REGDOM_TYPE_UNKNOWN,</span>
<span id="L98"><span class="lineNum">      98</span>              :         REGDOM_TYPE_COUNTRY,</span>
<span id="L99"><span class="lineNum">      99</span>              :         REGDOM_TYPE_WORLD,</span>
<span id="L100"><span class="lineNum">     100</span>              :         REGDOM_TYPE_CUSTOM_WORLD,</span>
<span id="L101"><span class="lineNum">     101</span>              :         REGDOM_TYPE_INTERSECTION,</span>
<span id="L102"><span class="lineNum">     102</span>              : };</span>
<span id="L103"><span class="lineNum">     103</span>              : </span>
<span id="L104"><span class="lineNum">     104</span>              : /**</span>
<span id="L105"><span class="lineNum">     105</span>              :  * struct hostapd_wmm_rule - WMM regulatory rule</span>
<span id="L106"><span class="lineNum">     106</span>              :  * @min_cwmin: Lower bound of CW_min value</span>
<span id="L107"><span class="lineNum">     107</span>              :  * @min_cwmax: Lower bound of CW_max value</span>
<span id="L108"><span class="lineNum">     108</span>              :  * @min_aifs: Lower bound of AIFS value</span>
<span id="L109"><span class="lineNum">     109</span>              :  * @max_txop: Upper bound of TXOP, value in units of 32 usec</span>
<span id="L110"><span class="lineNum">     110</span>              :  */</span>
<span id="L111"><span class="lineNum">     111</span>              : struct hostapd_wmm_rule {</span>
<span id="L112"><span class="lineNum">     112</span>              :         int min_cwmin;</span>
<span id="L113"><span class="lineNum">     113</span>              :         int min_cwmax;</span>
<span id="L114"><span class="lineNum">     114</span>              :         int min_aifs;</span>
<span id="L115"><span class="lineNum">     115</span>              :         int max_txop;</span>
<span id="L116"><span class="lineNum">     116</span>              : };</span>
<span id="L117"><span class="lineNum">     117</span>              : </span>
<span id="L118"><span class="lineNum">     118</span>              : /**</span>
<span id="L119"><span class="lineNum">     119</span>              :  * struct hostapd_channel_data - Channel information</span>
<span id="L120"><span class="lineNum">     120</span>              :  */</span>
<span id="L121"><span class="lineNum">     121</span>              : struct hostapd_channel_data {</span>
<span id="L122"><span class="lineNum">     122</span>              :         /**</span>
<span id="L123"><span class="lineNum">     123</span>              :          * chan - Channel number (IEEE 802.11)</span>
<span id="L124"><span class="lineNum">     124</span>              :          */</span>
<span id="L125"><span class="lineNum">     125</span>              :         short chan;</span>
<span id="L126"><span class="lineNum">     126</span>              : </span>
<span id="L127"><span class="lineNum">     127</span>              :         /**</span>
<span id="L128"><span class="lineNum">     128</span>              :          * freq - Frequency in MHz</span>
<span id="L129"><span class="lineNum">     129</span>              :          */</span>
<span id="L130"><span class="lineNum">     130</span>              :         int freq;</span>
<span id="L131"><span class="lineNum">     131</span>              : </span>
<span id="L132"><span class="lineNum">     132</span>              :         /**</span>
<span id="L133"><span class="lineNum">     133</span>              :          * flag - Channel flags (HOSTAPD_CHAN_*)</span>
<span id="L134"><span class="lineNum">     134</span>              :          */</span>
<span id="L135"><span class="lineNum">     135</span>              :         int flag;</span>
<span id="L136"><span class="lineNum">     136</span>              : </span>
<span id="L137"><span class="lineNum">     137</span>              :         /**</span>
<span id="L138"><span class="lineNum">     138</span>              :          * allowed_bw - Allowed channel width bitmask</span>
<span id="L139"><span class="lineNum">     139</span>              :          *</span>
<span id="L140"><span class="lineNum">     140</span>              :          * See enum hostapd_chan_width_attr.</span>
<span id="L141"><span class="lineNum">     141</span>              :          */</span>
<span id="L142"><span class="lineNum">     142</span>              :         u32 allowed_bw;</span>
<span id="L143"><span class="lineNum">     143</span>              : </span>
<span id="L144"><span class="lineNum">     144</span>              :         /**</span>
<span id="L145"><span class="lineNum">     145</span>              :          * max_tx_power - Regulatory transmit power limit in dBm</span>
<span id="L146"><span class="lineNum">     146</span>              :          */</span>
<span id="L147"><span class="lineNum">     147</span>              :         u8 max_tx_power;</span>
<span id="L148"><span class="lineNum">     148</span>              : </span>
<span id="L149"><span class="lineNum">     149</span>              :         /**</span>
<span id="L150"><span class="lineNum">     150</span>              :          * survey_list - Linked list of surveys (struct freq_survey)</span>
<span id="L151"><span class="lineNum">     151</span>              :          */</span>
<span id="L152"><span class="lineNum">     152</span>              :         struct dl_list survey_list;</span>
<span id="L153"><span class="lineNum">     153</span>              : </span>
<span id="L154"><span class="lineNum">     154</span>              :         /**</span>
<span id="L155"><span class="lineNum">     155</span>              :          * min_nf - Minimum observed noise floor, in dBm, based on all</span>
<span id="L156"><span class="lineNum">     156</span>              :          * surveyed channel data</span>
<span id="L157"><span class="lineNum">     157</span>              :          */</span>
<span id="L158"><span class="lineNum">     158</span>              :         s8 min_nf;</span>
<span id="L159"><span class="lineNum">     159</span>              : </span>
<span id="L160"><span class="lineNum">     160</span>              : #ifdef CONFIG_ACS</span>
<span id="L161"><span class="lineNum">     161</span>              :         /**</span>
<span id="L162"><span class="lineNum">     162</span>              :          * interference_factor - Computed interference factor on this</span>
<span id="L163"><span class="lineNum">     163</span>              :          * channel (used internally in src/ap/acs.c; driver wrappers do not</span>
<span id="L164"><span class="lineNum">     164</span>              :          * need to set this)</span>
<span id="L165"><span class="lineNum">     165</span>              :          */</span>
<span id="L166"><span class="lineNum">     166</span>              :         long double interference_factor;</span>
<span id="L167"><span class="lineNum">     167</span>              : #endif /* CONFIG_ACS */</span>
<span id="L168"><span class="lineNum">     168</span>              : </span>
<span id="L169"><span class="lineNum">     169</span>              :         /**</span>
<span id="L170"><span class="lineNum">     170</span>              :          * dfs_cac_ms - DFS CAC time in milliseconds</span>
<span id="L171"><span class="lineNum">     171</span>              :          */</span>
<span id="L172"><span class="lineNum">     172</span>              :         unsigned int dfs_cac_ms;</span>
<span id="L173"><span class="lineNum">     173</span>              : </span>
<span id="L174"><span class="lineNum">     174</span>              :         /**</span>
<span id="L175"><span class="lineNum">     175</span>              :          * wmm_rules_valid - Indicates wmm_rules state</span>
<span id="L176"><span class="lineNum">     176</span>              :          */</span>
<span id="L177"><span class="lineNum">     177</span>              :         int wmm_rules_valid;</span>
<span id="L178"><span class="lineNum">     178</span>              : </span>
<span id="L179"><span class="lineNum">     179</span>              :         /**</span>
<span id="L180"><span class="lineNum">     180</span>              :          * wmm_rules - WMM regulatory rules</span>
<span id="L181"><span class="lineNum">     181</span>              :          */</span>
<span id="L182"><span class="lineNum">     182</span>              :         struct hostapd_wmm_rule wmm_rules[WMM_AC_NUM];</span>
<span id="L183"><span class="lineNum">     183</span>              : };</span>
<span id="L184"><span class="lineNum">     184</span>              : </span>
<span id="L185"><span class="lineNum">     185</span>              : #define HE_MAC_CAPAB_0          0</span>
<span id="L186"><span class="lineNum">     186</span>              : #define HE_MAX_MAC_CAPAB_SIZE   6</span>
<span id="L187"><span class="lineNum">     187</span>              : #define HE_MAX_PHY_CAPAB_SIZE   11</span>
<span id="L188"><span class="lineNum">     188</span>              : #define HE_MAX_MCS_CAPAB_SIZE   12</span>
<span id="L189"><span class="lineNum">     189</span>              : #define HE_MAX_PPET_CAPAB_SIZE  25</span>
<span id="L190"><span class="lineNum">     190</span>              : </span>
<span id="L191"><span class="lineNum">     191</span>              : /**</span>
<span id="L192"><span class="lineNum">     192</span>              :  * struct he_capabilities - IEEE 802.11ax HE capabilities</span>
<span id="L193"><span class="lineNum">     193</span>              :  */</span>
<span id="L194"><span class="lineNum">     194</span>              : struct he_capabilities {</span>
<span id="L195"><span class="lineNum">     195</span>              :         u8 he_supported;</span>
<span id="L196"><span class="lineNum">     196</span>              :         u8 phy_cap[HE_MAX_PHY_CAPAB_SIZE];</span>
<span id="L197"><span class="lineNum">     197</span>              :         u8 mac_cap[HE_MAX_MAC_CAPAB_SIZE];</span>
<span id="L198"><span class="lineNum">     198</span>              :         u8 mcs[HE_MAX_MCS_CAPAB_SIZE];</span>
<span id="L199"><span class="lineNum">     199</span>              :         u8 ppet[HE_MAX_PPET_CAPAB_SIZE];</span>
<span id="L200"><span class="lineNum">     200</span>              :         u16 he_6ghz_capa;</span>
<span id="L201"><span class="lineNum">     201</span>              : };</span>
<span id="L202"><span class="lineNum">     202</span>              : </span>
<span id="L203"><span class="lineNum">     203</span>              : /* struct eht_capabilities - IEEE 802.11be EHT capabilities */</span>
<span id="L204"><span class="lineNum">     204</span>              : struct eht_capabilities {</span>
<span id="L205"><span class="lineNum">     205</span>              :         bool eht_supported;</span>
<span id="L206"><span class="lineNum">     206</span>              :         u16 mac_cap;</span>
<span id="L207"><span class="lineNum">     207</span>              :         u8 phy_cap[EHT_PHY_CAPAB_LEN];</span>
<span id="L208"><span class="lineNum">     208</span>              :         u8 mcs[EHT_MCS_NSS_CAPAB_LEN];</span>
<span id="L209"><span class="lineNum">     209</span>              :         u8 ppet[EHT_PPE_THRESH_CAPAB_LEN];</span>
<span id="L210"><span class="lineNum">     210</span>              : };</span>
<span id="L211"><span class="lineNum">     211</span>              : </span>
<span id="L212"><span class="lineNum">     212</span>              : #define HOSTAPD_MODE_FLAG_HT_INFO_KNOWN BIT(0)</span>
<span id="L213"><span class="lineNum">     213</span>              : #define HOSTAPD_MODE_FLAG_VHT_INFO_KNOWN BIT(1)</span>
<span id="L214"><span class="lineNum">     214</span>              : </span>
<span id="L215"><span class="lineNum">     215</span>              : </span>
<span id="L216"><span class="lineNum">     216</span>              : enum ieee80211_op_mode {</span>
<span id="L217"><span class="lineNum">     217</span>              :         IEEE80211_MODE_INFRA = 0,</span>
<span id="L218"><span class="lineNum">     218</span>              :         IEEE80211_MODE_IBSS = 1,</span>
<span id="L219"><span class="lineNum">     219</span>              :         IEEE80211_MODE_AP = 2,</span>
<span id="L220"><span class="lineNum">     220</span>              :         IEEE80211_MODE_MESH = 5,</span>
<span id="L221"><span class="lineNum">     221</span>              : </span>
<span id="L222"><span class="lineNum">     222</span>              :         /* only add new entries before IEEE80211_MODE_NUM */</span>
<span id="L223"><span class="lineNum">     223</span>              :         IEEE80211_MODE_NUM</span>
<span id="L224"><span class="lineNum">     224</span>              : };</span>
<span id="L225"><span class="lineNum">     225</span>              : </span>
<span id="L226"><span class="lineNum">     226</span>              : /**</span>
<span id="L227"><span class="lineNum">     227</span>              :  * struct ieee80211_edmg_config - EDMG configuration</span>
<span id="L228"><span class="lineNum">     228</span>              :  *</span>
<span id="L229"><span class="lineNum">     229</span>              :  * This structure describes most essential parameters needed</span>
<span id="L230"><span class="lineNum">     230</span>              :  * for IEEE 802.11ay EDMG configuration</span>
<span id="L231"><span class="lineNum">     231</span>              :  *</span>
<span id="L232"><span class="lineNum">     232</span>              :  * @channels: Bitmap that indicates the 2.16 GHz channel(s)</span>
<span id="L233"><span class="lineNum">     233</span>              :  *      that are allowed to be used for transmissions.</span>
<span id="L234"><span class="lineNum">     234</span>              :  *      Bit 0 indicates channel 1, bit 1 indicates channel 2, etc.</span>
<span id="L235"><span class="lineNum">     235</span>              :  *      Set to 0 to indicate EDMG not supported.</span>
<span id="L236"><span class="lineNum">     236</span>              :  * @bw_config: Channel BW Configuration subfield encodes</span>
<span id="L237"><span class="lineNum">     237</span>              :  *      the allowed channel bandwidth configurations</span>
<span id="L238"><span class="lineNum">     238</span>              :  */</span>
<span id="L239"><span class="lineNum">     239</span>              : struct ieee80211_edmg_config {</span>
<span id="L240"><span class="lineNum">     240</span>              :         u8 channels;</span>
<span id="L241"><span class="lineNum">     241</span>              :         enum edmg_bw_config bw_config;</span>
<span id="L242"><span class="lineNum">     242</span>              : };</span>
<span id="L243"><span class="lineNum">     243</span>              : </span>
<span id="L244"><span class="lineNum">     244</span>              : /**</span>
<span id="L245"><span class="lineNum">     245</span>              :  * struct hostapd_hw_modes - Supported hardware mode information</span>
<span id="L246"><span class="lineNum">     246</span>              :  */</span>
<span id="L247"><span class="lineNum">     247</span>              : struct hostapd_hw_modes {</span>
<span id="L248"><span class="lineNum">     248</span>              :         /**</span>
<span id="L249"><span class="lineNum">     249</span>              :          * mode - Hardware mode</span>
<span id="L250"><span class="lineNum">     250</span>              :          */</span>
<span id="L251"><span class="lineNum">     251</span>              :         enum hostapd_hw_mode mode;</span>
<span id="L252"><span class="lineNum">     252</span>              : </span>
<span id="L253"><span class="lineNum">     253</span>              :         /**</span>
<span id="L254"><span class="lineNum">     254</span>              :          * num_channels - Number of entries in the channels array</span>
<span id="L255"><span class="lineNum">     255</span>              :          */</span>
<span id="L256"><span class="lineNum">     256</span>              :         int num_channels;</span>
<span id="L257"><span class="lineNum">     257</span>              : </span>
<span id="L258"><span class="lineNum">     258</span>              :         /**</span>
<span id="L259"><span class="lineNum">     259</span>              :          * channels - Array of supported channels</span>
<span id="L260"><span class="lineNum">     260</span>              :          */</span>
<span id="L261"><span class="lineNum">     261</span>              :         struct hostapd_channel_data *channels;</span>
<span id="L262"><span class="lineNum">     262</span>              : </span>
<span id="L263"><span class="lineNum">     263</span>              :         /**</span>
<span id="L264"><span class="lineNum">     264</span>              :          * num_rates - Number of entries in the rates array</span>
<span id="L265"><span class="lineNum">     265</span>              :          */</span>
<span id="L266"><span class="lineNum">     266</span>              :         int num_rates;</span>
<span id="L267"><span class="lineNum">     267</span>              : </span>
<span id="L268"><span class="lineNum">     268</span>              :         /**</span>
<span id="L269"><span class="lineNum">     269</span>              :          * rates - Array of supported rates in 100 kbps units</span>
<span id="L270"><span class="lineNum">     270</span>              :          */</span>
<span id="L271"><span class="lineNum">     271</span>              :         int *rates;</span>
<span id="L272"><span class="lineNum">     272</span>              : </span>
<span id="L273"><span class="lineNum">     273</span>              :         /**</span>
<span id="L274"><span class="lineNum">     274</span>              :          * ht_capab - HT (IEEE 802.11n) capabilities</span>
<span id="L275"><span class="lineNum">     275</span>              :          */</span>
<span id="L276"><span class="lineNum">     276</span>              :         u16 ht_capab;</span>
<span id="L277"><span class="lineNum">     277</span>              : </span>
<span id="L278"><span class="lineNum">     278</span>              :         /**</span>
<span id="L279"><span class="lineNum">     279</span>              :          * mcs_set - MCS (IEEE 802.11n) rate parameters</span>
<span id="L280"><span class="lineNum">     280</span>              :          */</span>
<span id="L281"><span class="lineNum">     281</span>              :         u8 mcs_set[16];</span>
<span id="L282"><span class="lineNum">     282</span>              : </span>
<span id="L283"><span class="lineNum">     283</span>              :         /**</span>
<span id="L284"><span class="lineNum">     284</span>              :          * a_mpdu_params - A-MPDU (IEEE 802.11n) parameters</span>
<span id="L285"><span class="lineNum">     285</span>              :          */</span>
<span id="L286"><span class="lineNum">     286</span>              :         u8 a_mpdu_params;</span>
<span id="L287"><span class="lineNum">     287</span>              : </span>
<span id="L288"><span class="lineNum">     288</span>              :         /**</span>
<span id="L289"><span class="lineNum">     289</span>              :          * vht_capab - VHT (IEEE 802.11ac) capabilities</span>
<span id="L290"><span class="lineNum">     290</span>              :          */</span>
<span id="L291"><span class="lineNum">     291</span>              :         u32 vht_capab;</span>
<span id="L292"><span class="lineNum">     292</span>              : </span>
<span id="L293"><span class="lineNum">     293</span>              :         /**</span>
<span id="L294"><span class="lineNum">     294</span>              :          * vht_mcs_set - VHT MCS (IEEE 802.11ac) rate parameters</span>
<span id="L295"><span class="lineNum">     295</span>              :          */</span>
<span id="L296"><span class="lineNum">     296</span>              :         u8 vht_mcs_set[8];</span>
<span id="L297"><span class="lineNum">     297</span>              : </span>
<span id="L298"><span class="lineNum">     298</span>              :         unsigned int flags; /* HOSTAPD_MODE_FLAG_* */</span>
<span id="L299"><span class="lineNum">     299</span>              : </span>
<span id="L300"><span class="lineNum">     300</span>              :         /**</span>
<span id="L301"><span class="lineNum">     301</span>              :          * he_capab - HE (IEEE 802.11ax) capabilities</span>
<span id="L302"><span class="lineNum">     302</span>              :          */</span>
<span id="L303"><span class="lineNum">     303</span>              :         struct he_capabilities he_capab[IEEE80211_MODE_NUM];</span>
<span id="L304"><span class="lineNum">     304</span>              : </span>
<span id="L305"><span class="lineNum">     305</span>              :         /**</span>
<span id="L306"><span class="lineNum">     306</span>              :          * This structure describes the most essential parameters needed</span>
<span id="L307"><span class="lineNum">     307</span>              :          * for IEEE 802.11ay EDMG configuration.</span>
<span id="L308"><span class="lineNum">     308</span>              :          */</span>
<span id="L309"><span class="lineNum">     309</span>              :         struct ieee80211_edmg_config edmg;</span>
<span id="L310"><span class="lineNum">     310</span>              : </span>
<span id="L311"><span class="lineNum">     311</span>              :         /**</span>
<span id="L312"><span class="lineNum">     312</span>              :          * eht_capab - EHT (IEEE 802.11be) capabilities</span>
<span id="L313"><span class="lineNum">     313</span>              :          */</span>
<span id="L314"><span class="lineNum">     314</span>              :         struct eht_capabilities eht_capab[IEEE80211_MODE_NUM];</span>
<span id="L315"><span class="lineNum">     315</span>              : };</span>
<span id="L316"><span class="lineNum">     316</span>              : </span>
<span id="L317"><span class="lineNum">     317</span>              : </span>
<span id="L318"><span class="lineNum">     318</span>              : #define IEEE80211_CAP_ESS       0x0001</span>
<span id="L319"><span class="lineNum">     319</span>              : #define IEEE80211_CAP_IBSS      0x0002</span>
<span id="L320"><span class="lineNum">     320</span>              : #define IEEE80211_CAP_PRIVACY   0x0010</span>
<span id="L321"><span class="lineNum">     321</span>              : #define IEEE80211_CAP_RRM       0x1000</span>
<span id="L322"><span class="lineNum">     322</span>              : </span>
<span id="L323"><span class="lineNum">     323</span>              : /* DMG (60 GHz) IEEE 802.11ad */</span>
<span id="L324"><span class="lineNum">     324</span>              : /* type - bits 0..1 */</span>
<span id="L325"><span class="lineNum">     325</span>              : #define IEEE80211_CAP_DMG_MASK  0x0003</span>
<span id="L326"><span class="lineNum">     326</span>              : #define IEEE80211_CAP_DMG_IBSS  0x0001 /* Tx by: STA */</span>
<span id="L327"><span class="lineNum">     327</span>              : #define IEEE80211_CAP_DMG_PBSS  0x0002 /* Tx by: PCP */</span>
<span id="L328"><span class="lineNum">     328</span>              : #define IEEE80211_CAP_DMG_AP    0x0003 /* Tx by: AP */</span>
<span id="L329"><span class="lineNum">     329</span>              : </span>
<span id="L330"><span class="lineNum">     330</span>              : #define WPA_SCAN_QUAL_INVALID           BIT(0)</span>
<span id="L331"><span class="lineNum">     331</span>              : #define WPA_SCAN_NOISE_INVALID          BIT(1)</span>
<span id="L332"><span class="lineNum">     332</span>              : #define WPA_SCAN_LEVEL_INVALID          BIT(2)</span>
<span id="L333"><span class="lineNum">     333</span>              : #define WPA_SCAN_LEVEL_DBM              BIT(3)</span>
<span id="L334"><span class="lineNum">     334</span>              : #define WPA_SCAN_ASSOCIATED             BIT(5)</span>
<span id="L335"><span class="lineNum">     335</span>              : </span>
<span id="L336"><span class="lineNum">     336</span>              : /**</span>
<span id="L337"><span class="lineNum">     337</span>              :  * struct wpa_scan_res - Scan result for an BSS/IBSS</span>
<span id="L338"><span class="lineNum">     338</span>              :  * @flags: information flags about the BSS/IBSS (WPA_SCAN_*)</span>
<span id="L339"><span class="lineNum">     339</span>              :  * @bssid: BSSID</span>
<span id="L340"><span class="lineNum">     340</span>              :  * @freq: frequency of the channel in MHz (e.g., 2412 = channel 1)</span>
<span id="L341"><span class="lineNum">     341</span>              :  * @beacon_int: beacon interval in TUs (host byte order)</span>
<span id="L342"><span class="lineNum">     342</span>              :  * @caps: capability information field in host byte order</span>
<span id="L343"><span class="lineNum">     343</span>              :  * @qual: signal quality</span>
<span id="L344"><span class="lineNum">     344</span>              :  * @noise: noise level</span>
<span id="L345"><span class="lineNum">     345</span>              :  * @level: signal level</span>
<span id="L346"><span class="lineNum">     346</span>              :  * @tsf: Timestamp</span>
<span id="L347"><span class="lineNum">     347</span>              :  * @age: Age of the information in milliseconds (i.e., how many milliseconds</span>
<span id="L348"><span class="lineNum">     348</span>              :  * ago the last Beacon or Probe Response frame was received)</span>
<span id="L349"><span class="lineNum">     349</span>              :  * @est_throughput: Estimated throughput in kbps (this is calculated during</span>
<span id="L350"><span class="lineNum">     350</span>              :  * scan result processing if left zero by the driver wrapper)</span>
<span id="L351"><span class="lineNum">     351</span>              :  * @snr: Signal-to-noise ratio in dB (calculated during scan result processing)</span>
<span id="L352"><span class="lineNum">     352</span>              :  * @parent_tsf: Time when the Beacon/Probe Response frame was received in terms</span>
<span id="L353"><span class="lineNum">     353</span>              :  * of TSF of the BSS specified by %tsf_bssid.</span>
<span id="L354"><span class="lineNum">     354</span>              :  * @tsf_bssid: The BSS that %parent_tsf TSF time refers to.</span>
<span id="L355"><span class="lineNum">     355</span>              :  * @beacon_newer: Whether the Beacon frame data is known to be newer</span>
<span id="L356"><span class="lineNum">     356</span>              :  * @ie_len: length of the following IE field in octets</span>
<span id="L357"><span class="lineNum">     357</span>              :  * @beacon_ie_len: length of the following Beacon IE field in octets</span>
<span id="L358"><span class="lineNum">     358</span>              :  *</span>
<span id="L359"><span class="lineNum">     359</span>              :  * This structure is used as a generic format for scan results from the</span>
<span id="L360"><span class="lineNum">     360</span>              :  * driver. Each driver interface implementation is responsible for converting</span>
<span id="L361"><span class="lineNum">     361</span>              :  * the driver or OS specific scan results into this format.</span>
<span id="L362"><span class="lineNum">     362</span>              :  *</span>
<span id="L363"><span class="lineNum">     363</span>              :  * If the driver does not support reporting all IEs, the IE data structure is</span>
<span id="L364"><span class="lineNum">     364</span>              :  * constructed of the IEs that are available. This field will also need to</span>
<span id="L365"><span class="lineNum">     365</span>              :  * include SSID in IE format. All drivers are encouraged to be extended to</span>
<span id="L366"><span class="lineNum">     366</span>              :  * report all IEs to make it easier to support future additions.</span>
<span id="L367"><span class="lineNum">     367</span>              :  *</span>
<span id="L368"><span class="lineNum">     368</span>              :  * This structure data is followed by ie_len octets of IEs from Probe Response</span>
<span id="L369"><span class="lineNum">     369</span>              :  * frame (or if the driver does not indicate source of IEs, these may also be</span>
<span id="L370"><span class="lineNum">     370</span>              :  * from Beacon frame). After the first set of IEs, another set of IEs may follow</span>
<span id="L371"><span class="lineNum">     371</span>              :  * (with beacon_ie_len octets of data) if the driver provides both IE sets.</span>
<span id="L372"><span class="lineNum">     372</span>              :  */</span>
<span id="L373"><span class="lineNum">     373</span>              : struct wpa_scan_res {</span>
<span id="L374"><span class="lineNum">     374</span>              :         unsigned int flags;</span>
<span id="L375"><span class="lineNum">     375</span>              :         u8 bssid[ETH_ALEN];</span>
<span id="L376"><span class="lineNum">     376</span>              :         int freq;</span>
<span id="L377"><span class="lineNum">     377</span>              :         u16 beacon_int;</span>
<span id="L378"><span class="lineNum">     378</span>              :         u16 caps;</span>
<span id="L379"><span class="lineNum">     379</span>              :         int qual;</span>
<span id="L380"><span class="lineNum">     380</span>              :         int noise;</span>
<span id="L381"><span class="lineNum">     381</span>              :         int level;</span>
<span id="L382"><span class="lineNum">     382</span>              :         u64 tsf;</span>
<span id="L383"><span class="lineNum">     383</span>              :         unsigned int age;</span>
<span id="L384"><span class="lineNum">     384</span>              :         unsigned int est_throughput;</span>
<span id="L385"><span class="lineNum">     385</span>              :         int snr;</span>
<span id="L386"><span class="lineNum">     386</span>              :         u64 parent_tsf;</span>
<span id="L387"><span class="lineNum">     387</span>              :         u8 tsf_bssid[ETH_ALEN];</span>
<span id="L388"><span class="lineNum">     388</span>              :         bool beacon_newer;</span>
<span id="L389"><span class="lineNum">     389</span>              :         size_t ie_len;</span>
<span id="L390"><span class="lineNum">     390</span>              :         size_t beacon_ie_len;</span>
<span id="L391"><span class="lineNum">     391</span>              :         /* Followed by ie_len + beacon_ie_len octets of IE data */</span>
<span id="L392"><span class="lineNum">     392</span>              : };</span>
<span id="L393"><span class="lineNum">     393</span>              : </span>
<span id="L394"><span class="lineNum">     394</span>              : /**</span>
<span id="L395"><span class="lineNum">     395</span>              :  * struct wpa_scan_results - Scan results</span>
<span id="L396"><span class="lineNum">     396</span>              :  * @res: Array of pointers to allocated variable length scan result entries</span>
<span id="L397"><span class="lineNum">     397</span>              :  * @num: Number of entries in the scan result array</span>
<span id="L398"><span class="lineNum">     398</span>              :  * @fetch_time: Time when the results were fetched from the driver</span>
<span id="L399"><span class="lineNum">     399</span>              :  */</span>
<span id="L400"><span class="lineNum">     400</span>              : struct wpa_scan_results {</span>
<span id="L401"><span class="lineNum">     401</span>              :         struct wpa_scan_res **res;</span>
<span id="L402"><span class="lineNum">     402</span>              :         size_t num;</span>
<span id="L403"><span class="lineNum">     403</span>              :         struct os_reltime fetch_time;</span>
<span id="L404"><span class="lineNum">     404</span>              : };</span>
<span id="L405"><span class="lineNum">     405</span>              : </span>
<span id="L406"><span class="lineNum">     406</span>              : /**</span>
<span id="L407"><span class="lineNum">     407</span>              :  * struct wpa_interface_info - Network interface information</span>
<span id="L408"><span class="lineNum">     408</span>              :  * @next: Pointer to the next interface or NULL if this is the last one</span>
<span id="L409"><span class="lineNum">     409</span>              :  * @ifname: Interface name that can be used with init() or init2()</span>
<span id="L410"><span class="lineNum">     410</span>              :  * @desc: Human readable adapter description (e.g., vendor/model) or NULL if</span>
<span id="L411"><span class="lineNum">     411</span>              :  *      not available</span>
<span id="L412"><span class="lineNum">     412</span>              :  * @drv_name: struct wpa_driver_ops::name (note: unlike other strings, this one</span>
<span id="L413"><span class="lineNum">     413</span>              :  *      is not an allocated copy, i.e., get_interfaces() caller will not free</span>
<span id="L414"><span class="lineNum">     414</span>              :  *      this)</span>
<span id="L415"><span class="lineNum">     415</span>              :  */</span>
<span id="L416"><span class="lineNum">     416</span>              : struct wpa_interface_info {</span>
<span id="L417"><span class="lineNum">     417</span>              :         struct wpa_interface_info *next;</span>
<span id="L418"><span class="lineNum">     418</span>              :         char *ifname;</span>
<span id="L419"><span class="lineNum">     419</span>              :         char *desc;</span>
<span id="L420"><span class="lineNum">     420</span>              :         const char *drv_name;</span>
<span id="L421"><span class="lineNum">     421</span>              : };</span>
<span id="L422"><span class="lineNum">     422</span>              : </span>
<span id="L423"><span class="lineNum">     423</span>              : #define WPAS_MAX_SCAN_SSIDS 16</span>
<span id="L424"><span class="lineNum">     424</span>              : </span>
<span id="L425"><span class="lineNum">     425</span>              : /**</span>
<span id="L426"><span class="lineNum">     426</span>              :  * struct wpa_driver_scan_ssid - SSIDs to scan for</span>
<span id="L427"><span class="lineNum">     427</span>              :  * @ssid - specific SSID to scan for (ProbeReq)</span>
<span id="L428"><span class="lineNum">     428</span>              :  *      %NULL or zero-length SSID is used to indicate active scan</span>
<span id="L429"><span class="lineNum">     429</span>              :  *      with wildcard SSID.</span>
<span id="L430"><span class="lineNum">     430</span>              :  * @ssid_len - Length of the SSID in octets</span>
<span id="L431"><span class="lineNum">     431</span>              :  */</span>
<span id="L432"><span class="lineNum">     432</span>              : struct wpa_driver_scan_ssid {</span>
<span id="L433"><span class="lineNum">     433</span>              :         const u8 *ssid;</span>
<span id="L434"><span class="lineNum">     434</span>              :         size_t ssid_len;</span>
<span id="L435"><span class="lineNum">     435</span>              : };</span>
<span id="L436"><span class="lineNum">     436</span>              : </span>
<span id="L437"><span class="lineNum">     437</span>              : /**</span>
<span id="L438"><span class="lineNum">     438</span>              :  * struct wpa_driver_scan_params - Scan parameters</span>
<span id="L439"><span class="lineNum">     439</span>              :  * Data for struct wpa_driver_ops::scan2().</span>
<span id="L440"><span class="lineNum">     440</span>              :  */</span>
<span id="L441"><span class="lineNum">     441</span>              : struct wpa_driver_scan_params {</span>
<span id="L442"><span class="lineNum">     442</span>              :         /**</span>
<span id="L443"><span class="lineNum">     443</span>              :          * ssids - SSIDs to scan for</span>
<span id="L444"><span class="lineNum">     444</span>              :          */</span>
<span id="L445"><span class="lineNum">     445</span>              :         struct wpa_driver_scan_ssid ssids[WPAS_MAX_SCAN_SSIDS];</span>
<span id="L446"><span class="lineNum">     446</span>              : </span>
<span id="L447"><span class="lineNum">     447</span>              :         /**</span>
<span id="L448"><span class="lineNum">     448</span>              :          * num_ssids - Number of entries in ssids array</span>
<span id="L449"><span class="lineNum">     449</span>              :          * Zero indicates a request for a passive scan.</span>
<span id="L450"><span class="lineNum">     450</span>              :          */</span>
<span id="L451"><span class="lineNum">     451</span>              :         size_t num_ssids;</span>
<span id="L452"><span class="lineNum">     452</span>              : </span>
<span id="L453"><span class="lineNum">     453</span>              :         /**</span>
<span id="L454"><span class="lineNum">     454</span>              :          * extra_ies - Extra IE(s) to add into Probe Request or %NULL</span>
<span id="L455"><span class="lineNum">     455</span>              :          */</span>
<span id="L456"><span class="lineNum">     456</span>              :         const u8 *extra_ies;</span>
<span id="L457"><span class="lineNum">     457</span>              : </span>
<span id="L458"><span class="lineNum">     458</span>              :         /**</span>
<span id="L459"><span class="lineNum">     459</span>              :          * extra_ies_len - Length of extra_ies in octets</span>
<span id="L460"><span class="lineNum">     460</span>              :          */</span>
<span id="L461"><span class="lineNum">     461</span>              :         size_t extra_ies_len;</span>
<span id="L462"><span class="lineNum">     462</span>              : </span>
<span id="L463"><span class="lineNum">     463</span>              :         /**</span>
<span id="L464"><span class="lineNum">     464</span>              :          * freqs - Array of frequencies to scan or %NULL for all frequencies</span>
<span id="L465"><span class="lineNum">     465</span>              :          *</span>
<span id="L466"><span class="lineNum">     466</span>              :          * The frequency is set in MHz. The array is zero-terminated.</span>
<span id="L467"><span class="lineNum">     467</span>              :          */</span>
<span id="L468"><span class="lineNum">     468</span>              :         int *freqs;</span>
<span id="L469"><span class="lineNum">     469</span>              : </span>
<span id="L470"><span class="lineNum">     470</span>              :         /**</span>
<span id="L471"><span class="lineNum">     471</span>              :          * filter_ssids - Filter for reporting SSIDs</span>
<span id="L472"><span class="lineNum">     472</span>              :          *</span>
<span id="L473"><span class="lineNum">     473</span>              :          * This optional parameter can be used to request the driver wrapper to</span>
<span id="L474"><span class="lineNum">     474</span>              :          * filter scan results to include only the specified SSIDs. %NULL</span>
<span id="L475"><span class="lineNum">     475</span>              :          * indicates that no filtering is to be done. This can be used to</span>
<span id="L476"><span class="lineNum">     476</span>              :          * reduce memory needs for scan results in environments that have large</span>
<span id="L477"><span class="lineNum">     477</span>              :          * number of APs with different SSIDs.</span>
<span id="L478"><span class="lineNum">     478</span>              :          *</span>
<span id="L479"><span class="lineNum">     479</span>              :          * The driver wrapper is allowed to take this allocated buffer into its</span>
<span id="L480"><span class="lineNum">     480</span>              :          * own use by setting the pointer to %NULL. In that case, the driver</span>
<span id="L481"><span class="lineNum">     481</span>              :          * wrapper is responsible for freeing the buffer with os_free() once it</span>
<span id="L482"><span class="lineNum">     482</span>              :          * is not needed anymore.</span>
<span id="L483"><span class="lineNum">     483</span>              :          */</span>
<span id="L484"><span class="lineNum">     484</span>              :         struct wpa_driver_scan_filter {</span>
<span id="L485"><span class="lineNum">     485</span>              :                 u8 ssid[SSID_MAX_LEN];</span>
<span id="L486"><span class="lineNum">     486</span>              :                 size_t ssid_len;</span>
<span id="L487"><span class="lineNum">     487</span>              :         } *filter_ssids;</span>
<span id="L488"><span class="lineNum">     488</span>              : </span>
<span id="L489"><span class="lineNum">     489</span>              :         /**</span>
<span id="L490"><span class="lineNum">     490</span>              :          * num_filter_ssids - Number of entries in filter_ssids array</span>
<span id="L491"><span class="lineNum">     491</span>              :          */</span>
<span id="L492"><span class="lineNum">     492</span>              :         size_t num_filter_ssids;</span>
<span id="L493"><span class="lineNum">     493</span>              : </span>
<span id="L494"><span class="lineNum">     494</span>              :         /**</span>
<span id="L495"><span class="lineNum">     495</span>              :          * filter_rssi - Filter by RSSI</span>
<span id="L496"><span class="lineNum">     496</span>              :          *</span>
<span id="L497"><span class="lineNum">     497</span>              :          * The driver may filter scan results in firmware to reduce host</span>
<span id="L498"><span class="lineNum">     498</span>              :          * wakeups and thereby save power. Specify the RSSI threshold in s32</span>
<span id="L499"><span class="lineNum">     499</span>              :          * dBm.</span>
<span id="L500"><span class="lineNum">     500</span>              :          */</span>
<span id="L501"><span class="lineNum">     501</span>              :         s32 filter_rssi;</span>
<span id="L502"><span class="lineNum">     502</span>              : </span>
<span id="L503"><span class="lineNum">     503</span>              :         /**</span>
<span id="L504"><span class="lineNum">     504</span>              :          * p2p_probe - Used to disable CCK (802.11b) rates for P2P probes</span>
<span id="L505"><span class="lineNum">     505</span>              :          *</span>
<span id="L506"><span class="lineNum">     506</span>              :          * When set, the driver is expected to remove rates 1, 2, 5.5, and 11</span>
<span id="L507"><span class="lineNum">     507</span>              :          * Mbps from the support rates element(s) in the Probe Request frames</span>
<span id="L508"><span class="lineNum">     508</span>              :          * and not to transmit the frames at any of those rates.</span>
<span id="L509"><span class="lineNum">     509</span>              :          */</span>
<span id="L510"><span class="lineNum">     510</span>              :         unsigned int p2p_probe:1;</span>
<span id="L511"><span class="lineNum">     511</span>              : </span>
<span id="L512"><span class="lineNum">     512</span>              :         /**</span>
<span id="L513"><span class="lineNum">     513</span>              :          * only_new_results - Request driver to report only new results</span>
<span id="L514"><span class="lineNum">     514</span>              :          *</span>
<span id="L515"><span class="lineNum">     515</span>              :          * This is used to request the driver to report only BSSes that have</span>
<span id="L516"><span class="lineNum">     516</span>              :          * been detected after this scan request has been started, i.e., to</span>
<span id="L517"><span class="lineNum">     517</span>              :          * flush old cached BSS entries.</span>
<span id="L518"><span class="lineNum">     518</span>              :          */</span>
<span id="L519"><span class="lineNum">     519</span>              :         unsigned int only_new_results:1;</span>
<span id="L520"><span class="lineNum">     520</span>              : </span>
<span id="L521"><span class="lineNum">     521</span>              :         /**</span>
<span id="L522"><span class="lineNum">     522</span>              :          * low_priority - Requests driver to use a lower scan priority</span>
<span id="L523"><span class="lineNum">     523</span>              :          *</span>
<span id="L524"><span class="lineNum">     524</span>              :          * This is used to request the driver to use a lower scan priority</span>
<span id="L525"><span class="lineNum">     525</span>              :          * if it supports such a thing.</span>
<span id="L526"><span class="lineNum">     526</span>              :          */</span>
<span id="L527"><span class="lineNum">     527</span>              :         unsigned int low_priority:1;</span>
<span id="L528"><span class="lineNum">     528</span>              : </span>
<span id="L529"><span class="lineNum">     529</span>              :         /**</span>
<span id="L530"><span class="lineNum">     530</span>              :          * mac_addr_rand - Requests driver to randomize MAC address</span>
<span id="L531"><span class="lineNum">     531</span>              :          */</span>
<span id="L532"><span class="lineNum">     532</span>              :         unsigned int mac_addr_rand:1;</span>
<span id="L533"><span class="lineNum">     533</span>              : </span>
<span id="L534"><span class="lineNum">     534</span>              :         /**</span>
<span id="L535"><span class="lineNum">     535</span>              :          * mac_addr - MAC address used with randomization. The address cannot be</span>
<span id="L536"><span class="lineNum">     536</span>              :          * a multicast one, i.e., bit 0 of byte 0 should not be set.</span>
<span id="L537"><span class="lineNum">     537</span>              :          */</span>
<span id="L538"><span class="lineNum">     538</span>              :         u8 *mac_addr;</span>
<span id="L539"><span class="lineNum">     539</span>              : </span>
<span id="L540"><span class="lineNum">     540</span>              :         /**</span>
<span id="L541"><span class="lineNum">     541</span>              :          * mac_addr_mask - MAC address mask used with randomization.</span>
<span id="L542"><span class="lineNum">     542</span>              :          *</span>
<span id="L543"><span class="lineNum">     543</span>              :          * Bits that are 0 in the mask should be randomized. Bits that are 1 in</span>
<span id="L544"><span class="lineNum">     544</span>              :          * the mask should be taken as is from mac_addr. The mask should not</span>
<span id="L545"><span class="lineNum">     545</span>              :          * allow the generation of a multicast address, i.e., bit 0 of byte 0</span>
<span id="L546"><span class="lineNum">     546</span>              :          * must be set.</span>
<span id="L547"><span class="lineNum">     547</span>              :          */</span>
<span id="L548"><span class="lineNum">     548</span>              :         const u8 *mac_addr_mask;</span>
<span id="L549"><span class="lineNum">     549</span>              : </span>
<span id="L550"><span class="lineNum">     550</span>              :         /**</span>
<span id="L551"><span class="lineNum">     551</span>              :          * sched_scan_plans - Scan plans for scheduled scan</span>
<span id="L552"><span class="lineNum">     552</span>              :          *</span>
<span id="L553"><span class="lineNum">     553</span>              :          * Each scan plan consists of the number of iterations to scan and the</span>
<span id="L554"><span class="lineNum">     554</span>              :          * interval between scans. When a scan plan finishes (i.e., it was run</span>
<span id="L555"><span class="lineNum">     555</span>              :          * for the specified number of iterations), the next scan plan is</span>
<span id="L556"><span class="lineNum">     556</span>              :          * executed. The scan plans are executed in the order they appear in</span>
<span id="L557"><span class="lineNum">     557</span>              :          * the array (lower index first). The last scan plan will run infinitely</span>
<span id="L558"><span class="lineNum">     558</span>              :          * (until requested to stop), thus must not specify the number of</span>
<span id="L559"><span class="lineNum">     559</span>              :          * iterations. All other scan plans must specify the number of</span>
<span id="L560"><span class="lineNum">     560</span>              :          * iterations.</span>
<span id="L561"><span class="lineNum">     561</span>              :          */</span>
<span id="L562"><span class="lineNum">     562</span>              :         struct sched_scan_plan {</span>
<span id="L563"><span class="lineNum">     563</span>              :                  u32 interval; /* In seconds */</span>
<span id="L564"><span class="lineNum">     564</span>              :                  u32 iterations; /* Zero to run infinitely */</span>
<span id="L565"><span class="lineNum">     565</span>              :          } *sched_scan_plans;</span>
<span id="L566"><span class="lineNum">     566</span>              : </span>
<span id="L567"><span class="lineNum">     567</span>              :         /**</span>
<span id="L568"><span class="lineNum">     568</span>              :          * sched_scan_plans_num - Number of scan plans in sched_scan_plans array</span>
<span id="L569"><span class="lineNum">     569</span>              :          */</span>
<span id="L570"><span class="lineNum">     570</span>              :          unsigned int sched_scan_plans_num;</span>
<span id="L571"><span class="lineNum">     571</span>              : </span>
<span id="L572"><span class="lineNum">     572</span>              :         /**</span>
<span id="L573"><span class="lineNum">     573</span>              :          * sched_scan_start_delay - Delay to use before starting the first scan</span>
<span id="L574"><span class="lineNum">     574</span>              :          *</span>
<span id="L575"><span class="lineNum">     575</span>              :          * Delay (in seconds) before scheduling first scan plan cycle. The</span>
<span id="L576"><span class="lineNum">     576</span>              :          * driver may ignore this parameter and start immediately (or at any</span>
<span id="L577"><span class="lineNum">     577</span>              :          * other time), if this feature is not supported.</span>
<span id="L578"><span class="lineNum">     578</span>              :          */</span>
<span id="L579"><span class="lineNum">     579</span>              :          u32 sched_scan_start_delay;</span>
<span id="L580"><span class="lineNum">     580</span>              : </span>
<span id="L581"><span class="lineNum">     581</span>              :         /**</span>
<span id="L582"><span class="lineNum">     582</span>              :          * bssid - Specific BSSID to scan for</span>
<span id="L583"><span class="lineNum">     583</span>              :          *</span>
<span id="L584"><span class="lineNum">     584</span>              :          * This optional parameter can be used to replace the default wildcard</span>
<span id="L585"><span class="lineNum">     585</span>              :          * BSSID with a specific BSSID to scan for if results are needed from</span>
<span id="L586"><span class="lineNum">     586</span>              :          * only a single BSS.</span>
<span id="L587"><span class="lineNum">     587</span>              :          */</span>
<span id="L588"><span class="lineNum">     588</span>              :         const u8 *bssid;</span>
<span id="L589"><span class="lineNum">     589</span>              : </span>
<span id="L590"><span class="lineNum">     590</span>              :         /**</span>
<span id="L591"><span class="lineNum">     591</span>              :          * scan_cookie - Unique identification representing the scan request</span>
<span id="L592"><span class="lineNum">     592</span>              :          *</span>
<span id="L593"><span class="lineNum">     593</span>              :          * This scan_cookie carries a unique identification representing the</span>
<span id="L594"><span class="lineNum">     594</span>              :          * scan request if the host driver/kernel supports concurrent scan</span>
<span id="L595"><span class="lineNum">     595</span>              :          * requests. This cookie is returned from the corresponding driver</span>
<span id="L596"><span class="lineNum">     596</span>              :          * interface.</span>
<span id="L597"><span class="lineNum">     597</span>              :          *</span>
<span id="L598"><span class="lineNum">     598</span>              :          * Note: Unlike other parameters in this structure, scan_cookie is used</span>
<span id="L599"><span class="lineNum">     599</span>              :          * only to return information instead of setting parameters for the</span>
<span id="L600"><span class="lineNum">     600</span>              :          * scan.</span>
<span id="L601"><span class="lineNum">     601</span>              :          */</span>
<span id="L602"><span class="lineNum">     602</span>              :         u64 scan_cookie;</span>
<span id="L603"><span class="lineNum">     603</span>              : </span>
<span id="L604"><span class="lineNum">     604</span>              :          /**</span>
<span id="L605"><span class="lineNum">     605</span>              :           * duration - Dwell time on each channel</span>
<span id="L606"><span class="lineNum">     606</span>              :           *</span>
<span id="L607"><span class="lineNum">     607</span>              :           * This optional parameter can be used to set the dwell time on each</span>
<span id="L608"><span class="lineNum">     608</span>              :           * channel. In TUs.</span>
<span id="L609"><span class="lineNum">     609</span>              :           */</span>
<span id="L610"><span class="lineNum">     610</span>              :          u16 duration;</span>
<span id="L611"><span class="lineNum">     611</span>              : </span>
<span id="L612"><span class="lineNum">     612</span>              :          /**</span>
<span id="L613"><span class="lineNum">     613</span>              :           * duration_mandatory - Whether the specified duration is mandatory</span>
<span id="L614"><span class="lineNum">     614</span>              :           *</span>
<span id="L615"><span class="lineNum">     615</span>              :           * If this is set, the duration specified by the %duration field is</span>
<span id="L616"><span class="lineNum">     616</span>              :           * mandatory (and the driver should reject the scan request if it is</span>
<span id="L617"><span class="lineNum">     617</span>              :           * unable to comply with the specified duration), otherwise it is the</span>
<span id="L618"><span class="lineNum">     618</span>              :           * maximum duration and the actual duration may be shorter.</span>
<span id="L619"><span class="lineNum">     619</span>              :           */</span>
<span id="L620"><span class="lineNum">     620</span>              :          unsigned int duration_mandatory:1;</span>
<span id="L621"><span class="lineNum">     621</span>              : </span>
<span id="L622"><span class="lineNum">     622</span>              :         /**</span>
<span id="L623"><span class="lineNum">     623</span>              :          * relative_rssi_set - Whether relative RSSI parameters are set</span>
<span id="L624"><span class="lineNum">     624</span>              :          */</span>
<span id="L625"><span class="lineNum">     625</span>              :         unsigned int relative_rssi_set:1;</span>
<span id="L626"><span class="lineNum">     626</span>              : </span>
<span id="L627"><span class="lineNum">     627</span>              :         /**</span>
<span id="L628"><span class="lineNum">     628</span>              :          * relative_rssi - Relative RSSI for reporting better BSSs</span>
<span id="L629"><span class="lineNum">     629</span>              :          *</span>
<span id="L630"><span class="lineNum">     630</span>              :          * Amount of RSSI by which a BSS should be better than the current</span>
<span id="L631"><span class="lineNum">     631</span>              :          * connected BSS to report the new BSS to user space.</span>
<span id="L632"><span class="lineNum">     632</span>              :          */</span>
<span id="L633"><span class="lineNum">     633</span>              :         s8 relative_rssi;</span>
<span id="L634"><span class="lineNum">     634</span>              : </span>
<span id="L635"><span class="lineNum">     635</span>              :         /**</span>
<span id="L636"><span class="lineNum">     636</span>              :          * relative_adjust_band - Band to which RSSI should be adjusted</span>
<span id="L637"><span class="lineNum">     637</span>              :          *</span>
<span id="L638"><span class="lineNum">     638</span>              :          * The relative_adjust_rssi should be added to the band specified</span>
<span id="L639"><span class="lineNum">     639</span>              :          * by relative_adjust_band.</span>
<span id="L640"><span class="lineNum">     640</span>              :          */</span>
<span id="L641"><span class="lineNum">     641</span>              :         enum set_band relative_adjust_band;</span>
<span id="L642"><span class="lineNum">     642</span>              : </span>
<span id="L643"><span class="lineNum">     643</span>              :         /**</span>
<span id="L644"><span class="lineNum">     644</span>              :          * relative_adjust_rssi - RSSI to be added to relative_adjust_band</span>
<span id="L645"><span class="lineNum">     645</span>              :          *</span>
<span id="L646"><span class="lineNum">     646</span>              :          * An amount of relative_band_rssi should be added to the BSSs that</span>
<span id="L647"><span class="lineNum">     647</span>              :          * belong to the band specified by relative_adjust_band while comparing</span>
<span id="L648"><span class="lineNum">     648</span>              :          * with other bands for BSS reporting.</span>
<span id="L649"><span class="lineNum">     649</span>              :          */</span>
<span id="L650"><span class="lineNum">     650</span>              :         s8 relative_adjust_rssi;</span>
<span id="L651"><span class="lineNum">     651</span>              : </span>
<span id="L652"><span class="lineNum">     652</span>              :         /**</span>
<span id="L653"><span class="lineNum">     653</span>              :          * oce_scan</span>
<span id="L654"><span class="lineNum">     654</span>              :          *</span>
<span id="L655"><span class="lineNum">     655</span>              :          * Enable the following OCE scan features: (WFA OCE TechSpec v1.0)</span>
<span id="L656"><span class="lineNum">     656</span>              :          * - Accept broadcast Probe Response frame.</span>
<span id="L657"><span class="lineNum">     657</span>              :          * - Probe Request frame deferral and suppression.</span>
<span id="L658"><span class="lineNum">     658</span>              :          * - Max Channel Time - driver fills FILS request params IE with</span>
<span id="L659"><span class="lineNum">     659</span>              :          *   Maximum Channel Time.</span>
<span id="L660"><span class="lineNum">     660</span>              :          * - Send 1st Probe Request frame in rate of minimum 5.5 Mbps.</span>
<span id="L661"><span class="lineNum">     661</span>              :          */</span>
<span id="L662"><span class="lineNum">     662</span>              :         unsigned int oce_scan:1;</span>
<span id="L663"><span class="lineNum">     663</span>              : </span>
<span id="L664"><span class="lineNum">     664</span>              :         /**</span>
<span id="L665"><span class="lineNum">     665</span>              :          * p2p_include_6ghz - Include 6 GHz channels for P2P full scan</span>
<span id="L666"><span class="lineNum">     666</span>              :          *</span>
<span id="L667"><span class="lineNum">     667</span>              :          */</span>
<span id="L668"><span class="lineNum">     668</span>              :         unsigned int p2p_include_6ghz:1;</span>
<span id="L669"><span class="lineNum">     669</span>              : </span>
<span id="L670"><span class="lineNum">     670</span>              :         /**</span>
<span id="L671"><span class="lineNum">     671</span>              :          * non_coloc_6ghz - Force scanning of non-PSC 6 GHz channels</span>
<span id="L672"><span class="lineNum">     672</span>              :          *</span>
<span id="L673"><span class="lineNum">     673</span>              :          * If this is set, the driver should scan non-PSC channels from the</span>
<span id="L674"><span class="lineNum">     674</span>              :          * scan request even if neighbor reports from 2.4/5 GHz APs did not</span>
<span id="L675"><span class="lineNum">     675</span>              :          * report a co-located AP on these channels. The default is to scan</span>
<span id="L676"><span class="lineNum">     676</span>              :          * non-PSC channels only if a co-located AP was reported on the channel.</span>
<span id="L677"><span class="lineNum">     677</span>              :          */</span>
<span id="L678"><span class="lineNum">     678</span>              :         unsigned int non_coloc_6ghz:1;</span>
<span id="L679"><span class="lineNum">     679</span>              : </span>
<span id="L680"><span class="lineNum">     680</span>              :         /*</span>
<span id="L681"><span class="lineNum">     681</span>              :          * NOTE: Whenever adding new parameters here, please make sure</span>
<span id="L682"><span class="lineNum">     682</span>              :          * wpa_scan_clone_params() and wpa_scan_free_params() get updated with</span>
<span id="L683"><span class="lineNum">     683</span>              :          * matching changes.</span>
<span id="L684"><span class="lineNum">     684</span>              :          */</span>
<span id="L685"><span class="lineNum">     685</span>              : };</span>
<span id="L686"><span class="lineNum">     686</span>              : </span>
<span id="L687"><span class="lineNum">     687</span>              : /**</span>
<span id="L688"><span class="lineNum">     688</span>              :  * struct wpa_driver_auth_params - Authentication parameters</span>
<span id="L689"><span class="lineNum">     689</span>              :  * Data for struct wpa_driver_ops::authenticate().</span>
<span id="L690"><span class="lineNum">     690</span>              :  */</span>
<span id="L691"><span class="lineNum">     691</span>              : struct wpa_driver_auth_params {</span>
<span id="L692"><span class="lineNum">     692</span>              :         int freq;</span>
<span id="L693"><span class="lineNum">     693</span>              :         const u8 *bssid;</span>
<span id="L694"><span class="lineNum">     694</span>              :         const u8 *ssid;</span>
<span id="L695"><span class="lineNum">     695</span>              :         size_t ssid_len;</span>
<span id="L696"><span class="lineNum">     696</span>              :         int auth_alg;</span>
<span id="L697"><span class="lineNum">     697</span>              :         const u8 *ie;</span>
<span id="L698"><span class="lineNum">     698</span>              :         size_t ie_len;</span>
<span id="L699"><span class="lineNum">     699</span>              :         const u8 *wep_key[4];</span>
<span id="L700"><span class="lineNum">     700</span>              :         size_t wep_key_len[4];</span>
<span id="L701"><span class="lineNum">     701</span>              :         int wep_tx_keyidx;</span>
<span id="L702"><span class="lineNum">     702</span>              :         int local_state_change;</span>
<span id="L703"><span class="lineNum">     703</span>              : </span>
<span id="L704"><span class="lineNum">     704</span>              :         /**</span>
<span id="L705"><span class="lineNum">     705</span>              :          * p2p - Whether this connection is a P2P group</span>
<span id="L706"><span class="lineNum">     706</span>              :          */</span>
<span id="L707"><span class="lineNum">     707</span>              :         int p2p;</span>
<span id="L708"><span class="lineNum">     708</span>              : </span>
<span id="L709"><span class="lineNum">     709</span>              :         /**</span>
<span id="L710"><span class="lineNum">     710</span>              :          * auth_data - Additional elements for Authentication frame</span>
<span id="L711"><span class="lineNum">     711</span>              :          *</span>
<span id="L712"><span class="lineNum">     712</span>              :          * This buffer starts with the Authentication transaction sequence</span>
<span id="L713"><span class="lineNum">     713</span>              :          * number field. If no special handling of such elements is needed, this</span>
<span id="L714"><span class="lineNum">     714</span>              :          * pointer is %NULL. This is used with SAE and FILS.</span>
<span id="L715"><span class="lineNum">     715</span>              :          */</span>
<span id="L716"><span class="lineNum">     716</span>              :         const u8 *auth_data;</span>
<span id="L717"><span class="lineNum">     717</span>              : </span>
<span id="L718"><span class="lineNum">     718</span>              :         /**</span>
<span id="L719"><span class="lineNum">     719</span>              :          * auth_data_len - Length of auth_data buffer in octets</span>
<span id="L720"><span class="lineNum">     720</span>              :          */</span>
<span id="L721"><span class="lineNum">     721</span>              :         size_t auth_data_len;</span>
<span id="L722"><span class="lineNum">     722</span>              : };</span>
<span id="L723"><span class="lineNum">     723</span>              : </span>
<span id="L724"><span class="lineNum">     724</span>              : /**</span>
<span id="L725"><span class="lineNum">     725</span>              :  * enum wps_mode - WPS mode</span>
<span id="L726"><span class="lineNum">     726</span>              :  */</span>
<span id="L727"><span class="lineNum">     727</span>              : enum wps_mode {</span>
<span id="L728"><span class="lineNum">     728</span>              :         /**</span>
<span id="L729"><span class="lineNum">     729</span>              :          * WPS_MODE_NONE - No WPS provisioning being used</span>
<span id="L730"><span class="lineNum">     730</span>              :          */</span>
<span id="L731"><span class="lineNum">     731</span>              :         WPS_MODE_NONE,</span>
<span id="L732"><span class="lineNum">     732</span>              : </span>
<span id="L733"><span class="lineNum">     733</span>              :         /**</span>
<span id="L734"><span class="lineNum">     734</span>              :          * WPS_MODE_OPEN - WPS provisioning with AP that is in open mode</span>
<span id="L735"><span class="lineNum">     735</span>              :          */</span>
<span id="L736"><span class="lineNum">     736</span>              :         WPS_MODE_OPEN,</span>
<span id="L737"><span class="lineNum">     737</span>              : </span>
<span id="L738"><span class="lineNum">     738</span>              :         /**</span>
<span id="L739"><span class="lineNum">     739</span>              :          * WPS_MODE_PRIVACY - WPS provisioning with AP that is using protection</span>
<span id="L740"><span class="lineNum">     740</span>              :          */</span>
<span id="L741"><span class="lineNum">     741</span>              :         WPS_MODE_PRIVACY</span>
<span id="L742"><span class="lineNum">     742</span>              : };</span>
<span id="L743"><span class="lineNum">     743</span>              : </span>
<span id="L744"><span class="lineNum">     744</span>              : /**</span>
<span id="L745"><span class="lineNum">     745</span>              :  * struct hostapd_freq_params - Channel parameters</span>
<span id="L746"><span class="lineNum">     746</span>              :  */</span>
<span id="L747"><span class="lineNum">     747</span>              : struct hostapd_freq_params {</span>
<span id="L748"><span class="lineNum">     748</span>              :         /**</span>
<span id="L749"><span class="lineNum">     749</span>              :          * mode - Mode/band (HOSTAPD_MODE_IEEE80211A, ..)</span>
<span id="L750"><span class="lineNum">     750</span>              :          */</span>
<span id="L751"><span class="lineNum">     751</span>              :         enum hostapd_hw_mode mode;</span>
<span id="L752"><span class="lineNum">     752</span>              : </span>
<span id="L753"><span class="lineNum">     753</span>              :         /**</span>
<span id="L754"><span class="lineNum">     754</span>              :          * freq - Primary channel center frequency in MHz</span>
<span id="L755"><span class="lineNum">     755</span>              :          */</span>
<span id="L756"><span class="lineNum">     756</span>              :         int freq;</span>
<span id="L757"><span class="lineNum">     757</span>              : </span>
<span id="L758"><span class="lineNum">     758</span>              :         /**</span>
<span id="L759"><span class="lineNum">     759</span>              :          * channel - Channel number</span>
<span id="L760"><span class="lineNum">     760</span>              :          */</span>
<span id="L761"><span class="lineNum">     761</span>              :         int channel;</span>
<span id="L762"><span class="lineNum">     762</span>              : </span>
<span id="L763"><span class="lineNum">     763</span>              :         /**</span>
<span id="L764"><span class="lineNum">     764</span>              :          * ht_enabled - Whether HT is enabled</span>
<span id="L765"><span class="lineNum">     765</span>              :          */</span>
<span id="L766"><span class="lineNum">     766</span>              :         int ht_enabled;</span>
<span id="L767"><span class="lineNum">     767</span>              : </span>
<span id="L768"><span class="lineNum">     768</span>              :         /**</span>
<span id="L769"><span class="lineNum">     769</span>              :          * sec_channel_offset - Secondary channel offset for HT40</span>
<span id="L770"><span class="lineNum">     770</span>              :          *</span>
<span id="L771"><span class="lineNum">     771</span>              :          * 0 = HT40 disabled,</span>
<span id="L772"><span class="lineNum">     772</span>              :          * -1 = HT40 enabled, secondary channel below primary,</span>
<span id="L773"><span class="lineNum">     773</span>              :          * 1 = HT40 enabled, secondary channel above primary</span>
<span id="L774"><span class="lineNum">     774</span>              :          */</span>
<span id="L775"><span class="lineNum">     775</span>              :         int sec_channel_offset;</span>
<span id="L776"><span class="lineNum">     776</span>              : </span>
<span id="L777"><span class="lineNum">     777</span>              :         /**</span>
<span id="L778"><span class="lineNum">     778</span>              :          * vht_enabled - Whether VHT is enabled</span>
<span id="L779"><span class="lineNum">     779</span>              :          */</span>
<span id="L780"><span class="lineNum">     780</span>              :         int vht_enabled;</span>
<span id="L781"><span class="lineNum">     781</span>              : </span>
<span id="L782"><span class="lineNum">     782</span>              :         /**</span>
<span id="L783"><span class="lineNum">     783</span>              :          * he_enabled - Whether HE is enabled</span>
<span id="L784"><span class="lineNum">     784</span>              :          */</span>
<span id="L785"><span class="lineNum">     785</span>              :         int he_enabled;</span>
<span id="L786"><span class="lineNum">     786</span>              : </span>
<span id="L787"><span class="lineNum">     787</span>              :         /**</span>
<span id="L788"><span class="lineNum">     788</span>              :          * center_freq1 - Segment 0 center frequency in MHz</span>
<span id="L789"><span class="lineNum">     789</span>              :          *</span>
<span id="L790"><span class="lineNum">     790</span>              :          * Valid for both HT and VHT.</span>
<span id="L791"><span class="lineNum">     791</span>              :          */</span>
<span id="L792"><span class="lineNum">     792</span>              :         int center_freq1;</span>
<span id="L793"><span class="lineNum">     793</span>              : </span>
<span id="L794"><span class="lineNum">     794</span>              :         /**</span>
<span id="L795"><span class="lineNum">     795</span>              :          * center_freq2 - Segment 1 center frequency in MHz</span>
<span id="L796"><span class="lineNum">     796</span>              :          *</span>
<span id="L797"><span class="lineNum">     797</span>              :          * Non-zero only for bandwidth 80 and an 80+80 channel</span>
<span id="L798"><span class="lineNum">     798</span>              :          */</span>
<span id="L799"><span class="lineNum">     799</span>              :         int center_freq2;</span>
<span id="L800"><span class="lineNum">     800</span>              : </span>
<span id="L801"><span class="lineNum">     801</span>              :         /**</span>
<span id="L802"><span class="lineNum">     802</span>              :          * bandwidth - Channel bandwidth in MHz (20, 40, 80, 160)</span>
<span id="L803"><span class="lineNum">     803</span>              :          */</span>
<span id="L804"><span class="lineNum">     804</span>              :         int bandwidth;</span>
<span id="L805"><span class="lineNum">     805</span>              : </span>
<span id="L806"><span class="lineNum">     806</span>              :         /**</span>
<span id="L807"><span class="lineNum">     807</span>              :          * This structure describes the most essential parameters needed</span>
<span id="L808"><span class="lineNum">     808</span>              :          * for IEEE 802.11ay EDMG configuration.</span>
<span id="L809"><span class="lineNum">     809</span>              :          */</span>
<span id="L810"><span class="lineNum">     810</span>              :         struct ieee80211_edmg_config edmg;</span>
<span id="L811"><span class="lineNum">     811</span>              : </span>
<span id="L812"><span class="lineNum">     812</span>              :         /**</span>
<span id="L813"><span class="lineNum">     813</span>              :          * radar_background - Whether radar/CAC background is requested</span>
<span id="L814"><span class="lineNum">     814</span>              :          */</span>
<span id="L815"><span class="lineNum">     815</span>              :         bool radar_background;</span>
<span id="L816"><span class="lineNum">     816</span>              : </span>
<span id="L817"><span class="lineNum">     817</span>              :         /**</span>
<span id="L818"><span class="lineNum">     818</span>              :          * eht_enabled - Whether EHT is enabled</span>
<span id="L819"><span class="lineNum">     819</span>              :          */</span>
<span id="L820"><span class="lineNum">     820</span>              :         bool eht_enabled;</span>
<span id="L821"><span class="lineNum">     821</span>              : };</span>
<span id="L822"><span class="lineNum">     822</span>              : </span>
<span id="L823"><span class="lineNum">     823</span>              : /**</span>
<span id="L824"><span class="lineNum">     824</span>              :  * struct wpa_driver_sta_auth_params - Authentication parameters</span>
<span id="L825"><span class="lineNum">     825</span>              :  * Data for struct wpa_driver_ops::sta_auth().</span>
<span id="L826"><span class="lineNum">     826</span>              :  */</span>
<span id="L827"><span class="lineNum">     827</span>              : struct wpa_driver_sta_auth_params {</span>
<span id="L828"><span class="lineNum">     828</span>              : </span>
<span id="L829"><span class="lineNum">     829</span>              :         /**</span>
<span id="L830"><span class="lineNum">     830</span>              :          * own_addr - Source address and BSSID for authentication frame</span>
<span id="L831"><span class="lineNum">     831</span>              :          */</span>
<span id="L832"><span class="lineNum">     832</span>              :         const u8 *own_addr;</span>
<span id="L833"><span class="lineNum">     833</span>              : </span>
<span id="L834"><span class="lineNum">     834</span>              :         /**</span>
<span id="L835"><span class="lineNum">     835</span>              :          * addr - MAC address of the station to associate</span>
<span id="L836"><span class="lineNum">     836</span>              :          */</span>
<span id="L837"><span class="lineNum">     837</span>              :         const u8 *addr;</span>
<span id="L838"><span class="lineNum">     838</span>              : </span>
<span id="L839"><span class="lineNum">     839</span>              :         /**</span>
<span id="L840"><span class="lineNum">     840</span>              :          * seq - authentication sequence number</span>
<span id="L841"><span class="lineNum">     841</span>              :          */</span>
<span id="L842"><span class="lineNum">     842</span>              :         u16 seq;</span>
<span id="L843"><span class="lineNum">     843</span>              : </span>
<span id="L844"><span class="lineNum">     844</span>              :         /**</span>
<span id="L845"><span class="lineNum">     845</span>              :          * status - authentication response status code</span>
<span id="L846"><span class="lineNum">     846</span>              :          */</span>
<span id="L847"><span class="lineNum">     847</span>              :         u16 status;</span>
<span id="L848"><span class="lineNum">     848</span>              : </span>
<span id="L849"><span class="lineNum">     849</span>              :         /**</span>
<span id="L850"><span class="lineNum">     850</span>              :          * ie - authentication frame ie buffer</span>
<span id="L851"><span class="lineNum">     851</span>              :          */</span>
<span id="L852"><span class="lineNum">     852</span>              :         const u8 *ie;</span>
<span id="L853"><span class="lineNum">     853</span>              : </span>
<span id="L854"><span class="lineNum">     854</span>              :         /**</span>
<span id="L855"><span class="lineNum">     855</span>              :          * len - ie buffer length</span>
<span id="L856"><span class="lineNum">     856</span>              :          */</span>
<span id="L857"><span class="lineNum">     857</span>              :         size_t len;</span>
<span id="L858"><span class="lineNum">     858</span>              : </span>
<span id="L859"><span class="lineNum">     859</span>              :         /**</span>
<span id="L860"><span class="lineNum">     860</span>              :          * fils_auth - Indicates whether FILS authentication is being performed</span>
<span id="L861"><span class="lineNum">     861</span>              :          */</span>
<span id="L862"><span class="lineNum">     862</span>              :         int fils_auth;</span>
<span id="L863"><span class="lineNum">     863</span>              : </span>
<span id="L864"><span class="lineNum">     864</span>              :         /**</span>
<span id="L865"><span class="lineNum">     865</span>              :          * fils_anonce - ANonce (required for FILS)</span>
<span id="L866"><span class="lineNum">     866</span>              :          */</span>
<span id="L867"><span class="lineNum">     867</span>              :         u8 fils_anonce[WPA_NONCE_LEN];</span>
<span id="L868"><span class="lineNum">     868</span>              : </span>
<span id="L869"><span class="lineNum">     869</span>              :         /**</span>
<span id="L870"><span class="lineNum">     870</span>              :          * fils_snonce - SNonce (required for FILS)</span>
<span id="L871"><span class="lineNum">     871</span>              :         */</span>
<span id="L872"><span class="lineNum">     872</span>              :         u8 fils_snonce[WPA_NONCE_LEN];</span>
<span id="L873"><span class="lineNum">     873</span>              : </span>
<span id="L874"><span class="lineNum">     874</span>              :         /**</span>
<span id="L875"><span class="lineNum">     875</span>              :          * fils_kek - key for encryption (required for FILS)</span>
<span id="L876"><span class="lineNum">     876</span>              :          */</span>
<span id="L877"><span class="lineNum">     877</span>              :         u8 fils_kek[WPA_KEK_MAX_LEN];</span>
<span id="L878"><span class="lineNum">     878</span>              : </span>
<span id="L879"><span class="lineNum">     879</span>              :         /**</span>
<span id="L880"><span class="lineNum">     880</span>              :          * fils_kek_len - Length of the fils_kek in octets (required for FILS)</span>
<span id="L881"><span class="lineNum">     881</span>              :          */</span>
<span id="L882"><span class="lineNum">     882</span>              :         size_t fils_kek_len;</span>
<span id="L883"><span class="lineNum">     883</span>              : };</span>
<span id="L884"><span class="lineNum">     884</span>              : </span>
<span id="L885"><span class="lineNum">     885</span>              : /**</span>
<span id="L886"><span class="lineNum">     886</span>              :  * struct wpa_driver_associate_params - Association parameters</span>
<span id="L887"><span class="lineNum">     887</span>              :  * Data for struct wpa_driver_ops::associate().</span>
<span id="L888"><span class="lineNum">     888</span>              :  */</span>
<span id="L889"><span class="lineNum">     889</span>              : struct wpa_driver_associate_params {</span>
<span id="L890"><span class="lineNum">     890</span>              :         /**</span>
<span id="L891"><span class="lineNum">     891</span>              :          * bssid - BSSID of the selected AP</span>
<span id="L892"><span class="lineNum">     892</span>              :          * This can be %NULL, if ap_scan=2 mode is used and the driver is</span>
<span id="L893"><span class="lineNum">     893</span>              :          * responsible for selecting with which BSS to associate. */</span>
<span id="L894"><span class="lineNum">     894</span>              :         const u8 *bssid;</span>
<span id="L895"><span class="lineNum">     895</span>              : </span>
<span id="L896"><span class="lineNum">     896</span>              :         /**</span>
<span id="L897"><span class="lineNum">     897</span>              :          * bssid_hint - BSSID of a proposed AP</span>
<span id="L898"><span class="lineNum">     898</span>              :          *</span>
<span id="L899"><span class="lineNum">     899</span>              :          * This indicates which BSS has been found a suitable candidate for</span>
<span id="L900"><span class="lineNum">     900</span>              :          * initial association for drivers that use driver/firmwate-based BSS</span>
<span id="L901"><span class="lineNum">     901</span>              :          * selection. Unlike the @bssid parameter, @bssid_hint does not limit</span>
<span id="L902"><span class="lineNum">     902</span>              :          * the driver from selecting other BSSes in the ESS.</span>
<span id="L903"><span class="lineNum">     903</span>              :          */</span>
<span id="L904"><span class="lineNum">     904</span>              :         const u8 *bssid_hint;</span>
<span id="L905"><span class="lineNum">     905</span>              : </span>
<span id="L906"><span class="lineNum">     906</span>              :         /**</span>
<span id="L907"><span class="lineNum">     907</span>              :          * ssid - The selected SSID</span>
<span id="L908"><span class="lineNum">     908</span>              :          */</span>
<span id="L909"><span class="lineNum">     909</span>              :         const u8 *ssid;</span>
<span id="L910"><span class="lineNum">     910</span>              : </span>
<span id="L911"><span class="lineNum">     911</span>              :         /**</span>
<span id="L912"><span class="lineNum">     912</span>              :          * ssid_len - Length of the SSID (1..32)</span>
<span id="L913"><span class="lineNum">     913</span>              :          */</span>
<span id="L914"><span class="lineNum">     914</span>              :         size_t ssid_len;</span>
<span id="L915"><span class="lineNum">     915</span>              : </span>
<span id="L916"><span class="lineNum">     916</span>              :         /**</span>
<span id="L917"><span class="lineNum">     917</span>              :          * freq - channel parameters</span>
<span id="L918"><span class="lineNum">     918</span>              :          */</span>
<span id="L919"><span class="lineNum">     919</span>              :         struct hostapd_freq_params freq;</span>
<span id="L920"><span class="lineNum">     920</span>              : </span>
<span id="L921"><span class="lineNum">     921</span>              :         /**</span>
<span id="L922"><span class="lineNum">     922</span>              :          * freq_hint - Frequency of the channel the proposed AP is using</span>
<span id="L923"><span class="lineNum">     923</span>              :          *</span>
<span id="L924"><span class="lineNum">     924</span>              :          * This provides a channel on which a suitable BSS has been found as a</span>
<span id="L925"><span class="lineNum">     925</span>              :          * hint for the driver. Unlike the @freq parameter, @freq_hint does not</span>
<span id="L926"><span class="lineNum">     926</span>              :          * limit the driver from selecting other channels for</span>
<span id="L927"><span class="lineNum">     927</span>              :          * driver/firmware-based BSS selection.</span>
<span id="L928"><span class="lineNum">     928</span>              :          */</span>
<span id="L929"><span class="lineNum">     929</span>              :         int freq_hint;</span>
<span id="L930"><span class="lineNum">     930</span>              : </span>
<span id="L931"><span class="lineNum">     931</span>              :         /**</span>
<span id="L932"><span class="lineNum">     932</span>              :          * bg_scan_period - Background scan period in seconds, 0 to disable</span>
<span id="L933"><span class="lineNum">     933</span>              :          * background scan, or -1 to indicate no change to default driver</span>
<span id="L934"><span class="lineNum">     934</span>              :          * configuration</span>
<span id="L935"><span class="lineNum">     935</span>              :          */</span>
<span id="L936"><span class="lineNum">     936</span>              :         int bg_scan_period;</span>
<span id="L937"><span class="lineNum">     937</span>              : </span>
<span id="L938"><span class="lineNum">     938</span>              :         /**</span>
<span id="L939"><span class="lineNum">     939</span>              :          * beacon_int - Beacon interval for IBSS or 0 to use driver default</span>
<span id="L940"><span class="lineNum">     940</span>              :          */</span>
<span id="L941"><span class="lineNum">     941</span>              :         int beacon_int;</span>
<span id="L942"><span class="lineNum">     942</span>              : </span>
<span id="L943"><span class="lineNum">     943</span>              :         /**</span>
<span id="L944"><span class="lineNum">     944</span>              :          * wpa_ie - WPA information element for (Re)Association Request</span>
<span id="L945"><span class="lineNum">     945</span>              :          * WPA information element to be included in (Re)Association</span>
<span id="L946"><span class="lineNum">     946</span>              :          * Request (including information element id and length). Use</span>
<span id="L947"><span class="lineNum">     947</span>              :          * of this WPA IE is optional. If the driver generates the WPA</span>
<span id="L948"><span class="lineNum">     948</span>              :          * IE, it can use pairwise_suite, group_suite, group_mgmt_suite, and</span>
<span id="L949"><span class="lineNum">     949</span>              :          * key_mgmt_suite to select proper algorithms. In this case,</span>
<span id="L950"><span class="lineNum">     950</span>              :          * the driver has to notify wpa_supplicant about the used WPA</span>
<span id="L951"><span class="lineNum">     951</span>              :          * IE by generating an event that the interface code will</span>
<span id="L952"><span class="lineNum">     952</span>              :          * convert into EVENT_ASSOCINFO data (see below).</span>
<span id="L953"><span class="lineNum">     953</span>              :          *</span>
<span id="L954"><span class="lineNum">     954</span>              :          * When using WPA2/IEEE 802.11i, wpa_ie is used for RSN IE</span>
<span id="L955"><span class="lineNum">     955</span>              :          * instead. The driver can determine which version is used by</span>
<span id="L956"><span class="lineNum">     956</span>              :          * looking at the first byte of the IE (0xdd for WPA, 0x30 for</span>
<span id="L957"><span class="lineNum">     957</span>              :          * WPA2/RSN).</span>
<span id="L958"><span class="lineNum">     958</span>              :          *</span>
<span id="L959"><span class="lineNum">     959</span>              :          * When using WPS, wpa_ie is used for WPS IE instead of WPA/RSN IE.</span>
<span id="L960"><span class="lineNum">     960</span>              :          */</span>
<span id="L961"><span class="lineNum">     961</span>              :         const u8 *wpa_ie;</span>
<span id="L962"><span class="lineNum">     962</span>              : </span>
<span id="L963"><span class="lineNum">     963</span>              :         /**</span>
<span id="L964"><span class="lineNum">     964</span>              :          * wpa_ie_len - length of the wpa_ie</span>
<span id="L965"><span class="lineNum">     965</span>              :          */</span>
<span id="L966"><span class="lineNum">     966</span>              :         size_t wpa_ie_len;</span>
<span id="L967"><span class="lineNum">     967</span>              : </span>
<span id="L968"><span class="lineNum">     968</span>              :         /**</span>
<span id="L969"><span class="lineNum">     969</span>              :          * wpa_proto - Bitfield of WPA_PROTO_* values to indicate WPA/WPA2</span>
<span id="L970"><span class="lineNum">     970</span>              :          */</span>
<span id="L971"><span class="lineNum">     971</span>              :         unsigned int wpa_proto;</span>
<span id="L972"><span class="lineNum">     972</span>              : </span>
<span id="L973"><span class="lineNum">     973</span>              :         /**</span>
<span id="L974"><span class="lineNum">     974</span>              :          * pairwise_suite - Selected pairwise cipher suite (WPA_CIPHER_*)</span>
<span id="L975"><span class="lineNum">     975</span>              :          *</span>
<span id="L976"><span class="lineNum">     976</span>              :          * This is usually ignored if @wpa_ie is used.</span>
<span id="L977"><span class="lineNum">     977</span>              :          */</span>
<span id="L978"><span class="lineNum">     978</span>              :         unsigned int pairwise_suite;</span>
<span id="L979"><span class="lineNum">     979</span>              : </span>
<span id="L980"><span class="lineNum">     980</span>              :         /**</span>
<span id="L981"><span class="lineNum">     981</span>              :          * group_suite - Selected group cipher suite (WPA_CIPHER_*)</span>
<span id="L982"><span class="lineNum">     982</span>              :          *</span>
<span id="L983"><span class="lineNum">     983</span>              :          * This is usually ignored if @wpa_ie is used.</span>
<span id="L984"><span class="lineNum">     984</span>              :          */</span>
<span id="L985"><span class="lineNum">     985</span>              :         unsigned int group_suite;</span>
<span id="L986"><span class="lineNum">     986</span>              : </span>
<span id="L987"><span class="lineNum">     987</span>              :         /**</span>
<span id="L988"><span class="lineNum">     988</span>              :          * mgmt_group_suite - Selected group management cipher suite (WPA_CIPHER_*)</span>
<span id="L989"><span class="lineNum">     989</span>              :          *</span>
<span id="L990"><span class="lineNum">     990</span>              :          * This is usually ignored if @wpa_ie is used.</span>
<span id="L991"><span class="lineNum">     991</span>              :          */</span>
<span id="L992"><span class="lineNum">     992</span>              :         unsigned int mgmt_group_suite;</span>
<span id="L993"><span class="lineNum">     993</span>              : </span>
<span id="L994"><span class="lineNum">     994</span>              :         /**</span>
<span id="L995"><span class="lineNum">     995</span>              :          * key_mgmt_suite - Selected key management suite (WPA_KEY_MGMT_*)</span>
<span id="L996"><span class="lineNum">     996</span>              :          *</span>
<span id="L997"><span class="lineNum">     997</span>              :          * This is usually ignored if @wpa_ie is used.</span>
<span id="L998"><span class="lineNum">     998</span>              :          */</span>
<span id="L999"><span class="lineNum">     999</span>              :         unsigned int key_mgmt_suite;</span>
<span id="L1000"><span class="lineNum">    1000</span>              : </span>
<span id="L1001"><span class="lineNum">    1001</span>              :         /**</span>
<span id="L1002"><span class="lineNum">    1002</span>              :          * auth_alg - Allowed authentication algorithms</span>
<span id="L1003"><span class="lineNum">    1003</span>              :          * Bit field of WPA_AUTH_ALG_*</span>
<span id="L1004"><span class="lineNum">    1004</span>              :          */</span>
<span id="L1005"><span class="lineNum">    1005</span>              :         int auth_alg;</span>
<span id="L1006"><span class="lineNum">    1006</span>              : </span>
<span id="L1007"><span class="lineNum">    1007</span>              :         /**</span>
<span id="L1008"><span class="lineNum">    1008</span>              :          * mode - Operation mode (infra/ibss) IEEE80211_MODE_*</span>
<span id="L1009"><span class="lineNum">    1009</span>              :          */</span>
<span id="L1010"><span class="lineNum">    1010</span>              :         int mode;</span>
<span id="L1011"><span class="lineNum">    1011</span>              : </span>
<span id="L1012"><span class="lineNum">    1012</span>              :         /**</span>
<span id="L1013"><span class="lineNum">    1013</span>              :          * wep_key - WEP keys for static WEP configuration</span>
<span id="L1014"><span class="lineNum">    1014</span>              :          */</span>
<span id="L1015"><span class="lineNum">    1015</span>              :         const u8 *wep_key[4];</span>
<span id="L1016"><span class="lineNum">    1016</span>              : </span>
<span id="L1017"><span class="lineNum">    1017</span>              :         /**</span>
<span id="L1018"><span class="lineNum">    1018</span>              :          * wep_key_len - WEP key length for static WEP configuration</span>
<span id="L1019"><span class="lineNum">    1019</span>              :          */</span>
<span id="L1020"><span class="lineNum">    1020</span>              :         size_t wep_key_len[4];</span>
<span id="L1021"><span class="lineNum">    1021</span>              : </span>
<span id="L1022"><span class="lineNum">    1022</span>              :         /**</span>
<span id="L1023"><span class="lineNum">    1023</span>              :          * wep_tx_keyidx - WEP TX key index for static WEP configuration</span>
<span id="L1024"><span class="lineNum">    1024</span>              :          */</span>
<span id="L1025"><span class="lineNum">    1025</span>              :         int wep_tx_keyidx;</span>
<span id="L1026"><span class="lineNum">    1026</span>              : </span>
<span id="L1027"><span class="lineNum">    1027</span>              :         /**</span>
<span id="L1028"><span class="lineNum">    1028</span>              :          * mgmt_frame_protection - IEEE 802.11w management frame protection</span>
<span id="L1029"><span class="lineNum">    1029</span>              :          */</span>
<span id="L1030"><span class="lineNum">    1030</span>              :         enum mfp_options mgmt_frame_protection;</span>
<span id="L1031"><span class="lineNum">    1031</span>              : </span>
<span id="L1032"><span class="lineNum">    1032</span>              :         /**</span>
<span id="L1033"><span class="lineNum">    1033</span>              :          * passphrase - RSN passphrase for PSK</span>
<span id="L1034"><span class="lineNum">    1034</span>              :          *</span>
<span id="L1035"><span class="lineNum">    1035</span>              :          * This value is made available only for WPA/WPA2-Personal (PSK) and</span>
<span id="L1036"><span class="lineNum">    1036</span>              :          * only for drivers that set WPA_DRIVER_FLAGS_4WAY_HANDSHAKE_PSK. This</span>
<span id="L1037"><span class="lineNum">    1037</span>              :          * is the 8..63 character ASCII passphrase, if available. Please note</span>
<span id="L1038"><span class="lineNum">    1038</span>              :          * that this can be %NULL if passphrase was not used to generate the</span>
<span id="L1039"><span class="lineNum">    1039</span>              :          * PSK. In that case, the psk field must be used to fetch the PSK.</span>
<span id="L1040"><span class="lineNum">    1040</span>              :          */</span>
<span id="L1041"><span class="lineNum">    1041</span>              :         const char *passphrase;</span>
<span id="L1042"><span class="lineNum">    1042</span>              : </span>
<span id="L1043"><span class="lineNum">    1043</span>              :         /**</span>
<span id="L1044"><span class="lineNum">    1044</span>              :          * psk - RSN PSK (alternative for passphrase for PSK)</span>
<span id="L1045"><span class="lineNum">    1045</span>              :          *</span>
<span id="L1046"><span class="lineNum">    1046</span>              :          * This value is made available only for WPA/WPA2-Personal (PSK) and</span>
<span id="L1047"><span class="lineNum">    1047</span>              :          * only for drivers that set WPA_DRIVER_FLAGS_4WAY_HANDSHAKE_PSK. This</span>
<span id="L1048"><span class="lineNum">    1048</span>              :          * is the 32-octet (256-bit) PSK, if available. The driver wrapper</span>
<span id="L1049"><span class="lineNum">    1049</span>              :          * should be prepared to handle %NULL value as an error.</span>
<span id="L1050"><span class="lineNum">    1050</span>              :          */</span>
<span id="L1051"><span class="lineNum">    1051</span>              :         const u8 *psk;</span>
<span id="L1052"><span class="lineNum">    1052</span>              : </span>
<span id="L1053"><span class="lineNum">    1053</span>              :         /**</span>
<span id="L1054"><span class="lineNum">    1054</span>              :          * drop_unencrypted - Enable/disable unencrypted frame filtering</span>
<span id="L1055"><span class="lineNum">    1055</span>              :          *</span>
<span id="L1056"><span class="lineNum">    1056</span>              :          * Configure the driver to drop all non-EAPOL frames (both receive and</span>
<span id="L1057"><span class="lineNum">    1057</span>              :          * transmit paths). Unencrypted EAPOL frames (ethertype 0x888e) must</span>
<span id="L1058"><span class="lineNum">    1058</span>              :          * still be allowed for key negotiation.</span>
<span id="L1059"><span class="lineNum">    1059</span>              :          */</span>
<span id="L1060"><span class="lineNum">    1060</span>              :         int drop_unencrypted;</span>
<span id="L1061"><span class="lineNum">    1061</span>              : </span>
<span id="L1062"><span class="lineNum">    1062</span>              :         /**</span>
<span id="L1063"><span class="lineNum">    1063</span>              :          * prev_bssid - Previously used BSSID in this ESS</span>
<span id="L1064"><span class="lineNum">    1064</span>              :          *</span>
<span id="L1065"><span class="lineNum">    1065</span>              :          * When not %NULL, this is a request to use reassociation instead of</span>
<span id="L1066"><span class="lineNum">    1066</span>              :          * association.</span>
<span id="L1067"><span class="lineNum">    1067</span>              :          */</span>
<span id="L1068"><span class="lineNum">    1068</span>              :         const u8 *prev_bssid;</span>
<span id="L1069"><span class="lineNum">    1069</span>              : </span>
<span id="L1070"><span class="lineNum">    1070</span>              :         /**</span>
<span id="L1071"><span class="lineNum">    1071</span>              :          * wps - WPS mode</span>
<span id="L1072"><span class="lineNum">    1072</span>              :          *</span>
<span id="L1073"><span class="lineNum">    1073</span>              :          * If the driver needs to do special configuration for WPS association,</span>
<span id="L1074"><span class="lineNum">    1074</span>              :          * this variable provides more information on what type of association</span>
<span id="L1075"><span class="lineNum">    1075</span>              :          * is being requested. Most drivers should not need to use this.</span>
<span id="L1076"><span class="lineNum">    1076</span>              :          */</span>
<span id="L1077"><span class="lineNum">    1077</span>              :         enum wps_mode wps;</span>
<span id="L1078"><span class="lineNum">    1078</span>              : </span>
<span id="L1079"><span class="lineNum">    1079</span>              :         /**</span>
<span id="L1080"><span class="lineNum">    1080</span>              :          * p2p - Whether this connection is a P2P group</span>
<span id="L1081"><span class="lineNum">    1081</span>              :          */</span>
<span id="L1082"><span class="lineNum">    1082</span>              :         int p2p;</span>
<span id="L1083"><span class="lineNum">    1083</span>              : </span>
<span id="L1084"><span class="lineNum">    1084</span>              :         /**</span>
<span id="L1085"><span class="lineNum">    1085</span>              :          * uapsd - UAPSD parameters for the network</span>
<span id="L1086"><span class="lineNum">    1086</span>              :          * -1 = do not change defaults</span>
<span id="L1087"><span class="lineNum">    1087</span>              :          * AP mode: 1 = enabled, 0 = disabled</span>
<span id="L1088"><span class="lineNum">    1088</span>              :          * STA mode: bits 0..3 UAPSD enabled for VO,VI,BK,BE</span>
<span id="L1089"><span class="lineNum">    1089</span>              :          */</span>
<span id="L1090"><span class="lineNum">    1090</span>              :         int uapsd;</span>
<span id="L1091"><span class="lineNum">    1091</span>              : </span>
<span id="L1092"><span class="lineNum">    1092</span>              :         /**</span>
<span id="L1093"><span class="lineNum">    1093</span>              :          * fixed_bssid - Whether to force this BSSID in IBSS mode</span>
<span id="L1094"><span class="lineNum">    1094</span>              :          * 1 = Fix this BSSID and prevent merges.</span>
<span id="L1095"><span class="lineNum">    1095</span>              :          * 0 = Do not fix BSSID.</span>
<span id="L1096"><span class="lineNum">    1096</span>              :          */</span>
<span id="L1097"><span class="lineNum">    1097</span>              :         int fixed_bssid;</span>
<span id="L1098"><span class="lineNum">    1098</span>              : </span>
<span id="L1099"><span class="lineNum">    1099</span>              :         /**</span>
<span id="L1100"><span class="lineNum">    1100</span>              :          * fixed_freq - Fix control channel in IBSS mode</span>
<span id="L1101"><span class="lineNum">    1101</span>              :          * 0 = don't fix control channel (default)</span>
<span id="L1102"><span class="lineNum">    1102</span>              :          * 1 = fix control channel; this prevents IBSS merging with another</span>
<span id="L1103"><span class="lineNum">    1103</span>              :          *      channel</span>
<span id="L1104"><span class="lineNum">    1104</span>              :          */</span>
<span id="L1105"><span class="lineNum">    1105</span>              :         int fixed_freq;</span>
<span id="L1106"><span class="lineNum">    1106</span>              : </span>
<span id="L1107"><span class="lineNum">    1107</span>              :         /**</span>
<span id="L1108"><span class="lineNum">    1108</span>              :          * disable_ht - Disable HT (IEEE 802.11n) for this connection</span>
<span id="L1109"><span class="lineNum">    1109</span>              :          */</span>
<span id="L1110"><span class="lineNum">    1110</span>              :         int disable_ht;</span>
<span id="L1111"><span class="lineNum">    1111</span>              : </span>
<span id="L1112"><span class="lineNum">    1112</span>              :         /**</span>
<span id="L1113"><span class="lineNum">    1113</span>              :          * htcaps - HT Capabilities over-rides</span>
<span id="L1114"><span class="lineNum">    1114</span>              :          *</span>
<span id="L1115"><span class="lineNum">    1115</span>              :          * Only bits set in the mask will be used, and not all values are used</span>
<span id="L1116"><span class="lineNum">    1116</span>              :          * by the kernel anyway. Currently, MCS, MPDU and MSDU fields are used.</span>
<span id="L1117"><span class="lineNum">    1117</span>              :          *</span>
<span id="L1118"><span class="lineNum">    1118</span>              :          * Pointer to struct ieee80211_ht_capabilities.</span>
<span id="L1119"><span class="lineNum">    1119</span>              :          */</span>
<span id="L1120"><span class="lineNum">    1120</span>              :         const u8 *htcaps;</span>
<span id="L1121"><span class="lineNum">    1121</span>              : </span>
<span id="L1122"><span class="lineNum">    1122</span>              :         /**</span>
<span id="L1123"><span class="lineNum">    1123</span>              :          * htcaps_mask - HT Capabilities over-rides mask</span>
<span id="L1124"><span class="lineNum">    1124</span>              :          *</span>
<span id="L1125"><span class="lineNum">    1125</span>              :          * Pointer to struct ieee80211_ht_capabilities.</span>
<span id="L1126"><span class="lineNum">    1126</span>              :          */</span>
<span id="L1127"><span class="lineNum">    1127</span>              :         const u8 *htcaps_mask;</span>
<span id="L1128"><span class="lineNum">    1128</span>              : </span>
<span id="L1129"><span class="lineNum">    1129</span>              : #ifdef CONFIG_VHT_OVERRIDES</span>
<span id="L1130"><span class="lineNum">    1130</span>              :         /**</span>
<span id="L1131"><span class="lineNum">    1131</span>              :          * disable_vht - Disable VHT for this connection</span>
<span id="L1132"><span class="lineNum">    1132</span>              :          */</span>
<span id="L1133"><span class="lineNum">    1133</span>              :         int disable_vht;</span>
<span id="L1134"><span class="lineNum">    1134</span>              : </span>
<span id="L1135"><span class="lineNum">    1135</span>              :         /**</span>
<span id="L1136"><span class="lineNum">    1136</span>              :          * VHT capability overrides.</span>
<span id="L1137"><span class="lineNum">    1137</span>              :          */</span>
<span id="L1138"><span class="lineNum">    1138</span>              :         const struct ieee80211_vht_capabilities *vhtcaps;</span>
<span id="L1139"><span class="lineNum">    1139</span>              :         const struct ieee80211_vht_capabilities *vhtcaps_mask;</span>
<span id="L1140"><span class="lineNum">    1140</span>              : #endif /* CONFIG_VHT_OVERRIDES */</span>
<span id="L1141"><span class="lineNum">    1141</span>              : </span>
<span id="L1142"><span class="lineNum">    1142</span>              : #ifdef CONFIG_HE_OVERRIDES</span>
<span id="L1143"><span class="lineNum">    1143</span>              :         /**</span>
<span id="L1144"><span class="lineNum">    1144</span>              :          * disable_he - Disable HE for this connection</span>
<span id="L1145"><span class="lineNum">    1145</span>              :          */</span>
<span id="L1146"><span class="lineNum">    1146</span>              :         int disable_he;</span>
<span id="L1147"><span class="lineNum">    1147</span>              : #endif /* CONFIG_HE_OVERRIDES */</span>
<span id="L1148"><span class="lineNum">    1148</span>              : </span>
<span id="L1149"><span class="lineNum">    1149</span>              :         /**</span>
<span id="L1150"><span class="lineNum">    1150</span>              :          * req_key_mgmt_offload - Request key management offload for connection</span>
<span id="L1151"><span class="lineNum">    1151</span>              :          *</span>
<span id="L1152"><span class="lineNum">    1152</span>              :          * Request key management offload for this connection if the device</span>
<span id="L1153"><span class="lineNum">    1153</span>              :          * supports it.</span>
<span id="L1154"><span class="lineNum">    1154</span>              :          */</span>
<span id="L1155"><span class="lineNum">    1155</span>              :         int req_key_mgmt_offload;</span>
<span id="L1156"><span class="lineNum">    1156</span>              : </span>
<span id="L1157"><span class="lineNum">    1157</span>              :         /**</span>
<span id="L1158"><span class="lineNum">    1158</span>              :          * req_handshake_offload - Request EAPOL handshake offload</span>
<span id="L1159"><span class="lineNum">    1159</span>              :          *</span>
<span id="L1160"><span class="lineNum">    1160</span>              :          * Request EAPOL handshake offload for this connection if the device</span>
<span id="L1161"><span class="lineNum">    1161</span>              :          * supports it.</span>
<span id="L1162"><span class="lineNum">    1162</span>              :          */</span>
<span id="L1163"><span class="lineNum">    1163</span>              :         int req_handshake_offload;</span>
<span id="L1164"><span class="lineNum">    1164</span>              : </span>
<span id="L1165"><span class="lineNum">    1165</span>              :         /**</span>
<span id="L1166"><span class="lineNum">    1166</span>              :          * Flag for indicating whether this association includes support for</span>
<span id="L1167"><span class="lineNum">    1167</span>              :          * RRM (Radio Resource Measurements)</span>
<span id="L1168"><span class="lineNum">    1168</span>              :          */</span>
<span id="L1169"><span class="lineNum">    1169</span>              :         int rrm_used;</span>
<span id="L1170"><span class="lineNum">    1170</span>              : </span>
<span id="L1171"><span class="lineNum">    1171</span>              :         /**</span>
<span id="L1172"><span class="lineNum">    1172</span>              :          * pbss - If set, connect to a PCP in a PBSS. Otherwise, connect to an</span>
<span id="L1173"><span class="lineNum">    1173</span>              :          * AP as usual. Valid for DMG network only.</span>
<span id="L1174"><span class="lineNum">    1174</span>              :          */</span>
<span id="L1175"><span class="lineNum">    1175</span>              :         int pbss;</span>
<span id="L1176"><span class="lineNum">    1176</span>              : </span>
<span id="L1177"><span class="lineNum">    1177</span>              :         /**</span>
<span id="L1178"><span class="lineNum">    1178</span>              :          * fils_kek - KEK for FILS association frame protection (AES-SIV)</span>
<span id="L1179"><span class="lineNum">    1179</span>              :          */</span>
<span id="L1180"><span class="lineNum">    1180</span>              :         const u8 *fils_kek;</span>
<span id="L1181"><span class="lineNum">    1181</span>              : </span>
<span id="L1182"><span class="lineNum">    1182</span>              :         /**</span>
<span id="L1183"><span class="lineNum">    1183</span>              :          * fils_kek_len: Length of fils_kek in bytes</span>
<span id="L1184"><span class="lineNum">    1184</span>              :          */</span>
<span id="L1185"><span class="lineNum">    1185</span>              :         size_t fils_kek_len;</span>
<span id="L1186"><span class="lineNum">    1186</span>              : </span>
<span id="L1187"><span class="lineNum">    1187</span>              :         /**</span>
<span id="L1188"><span class="lineNum">    1188</span>              :          * fils_nonces - Nonces for FILS association frame protection</span>
<span id="L1189"><span class="lineNum">    1189</span>              :          * (AES-SIV AAD)</span>
<span id="L1190"><span class="lineNum">    1190</span>              :          */</span>
<span id="L1191"><span class="lineNum">    1191</span>              :         const u8 *fils_nonces;</span>
<span id="L1192"><span class="lineNum">    1192</span>              : </span>
<span id="L1193"><span class="lineNum">    1193</span>              :         /**</span>
<span id="L1194"><span class="lineNum">    1194</span>              :          * fils_nonces_len: Length of fils_nonce in bytes</span>
<span id="L1195"><span class="lineNum">    1195</span>              :          */</span>
<span id="L1196"><span class="lineNum">    1196</span>              :         size_t fils_nonces_len;</span>
<span id="L1197"><span class="lineNum">    1197</span>              : </span>
<span id="L1198"><span class="lineNum">    1198</span>              :         /**</span>
<span id="L1199"><span class="lineNum">    1199</span>              :          * fils_erp_username - Username part of keyName-NAI</span>
<span id="L1200"><span class="lineNum">    1200</span>              :          */</span>
<span id="L1201"><span class="lineNum">    1201</span>              :         const u8 *fils_erp_username;</span>
<span id="L1202"><span class="lineNum">    1202</span>              : </span>
<span id="L1203"><span class="lineNum">    1203</span>              :         /**</span>
<span id="L1204"><span class="lineNum">    1204</span>              :          * fils_erp_username_len - Length of fils_erp_username in bytes</span>
<span id="L1205"><span class="lineNum">    1205</span>              :          */</span>
<span id="L1206"><span class="lineNum">    1206</span>              :         size_t fils_erp_username_len;</span>
<span id="L1207"><span class="lineNum">    1207</span>              : </span>
<span id="L1208"><span class="lineNum">    1208</span>              :         /**</span>
<span id="L1209"><span class="lineNum">    1209</span>              :          * fils_erp_realm - Realm/domain name to use in FILS ERP</span>
<span id="L1210"><span class="lineNum">    1210</span>              :          */</span>
<span id="L1211"><span class="lineNum">    1211</span>              :         const u8 *fils_erp_realm;</span>
<span id="L1212"><span class="lineNum">    1212</span>              : </span>
<span id="L1213"><span class="lineNum">    1213</span>              :         /**</span>
<span id="L1214"><span class="lineNum">    1214</span>              :          * fils_erp_realm_len - Length of fils_erp_realm in bytes</span>
<span id="L1215"><span class="lineNum">    1215</span>              :          */</span>
<span id="L1216"><span class="lineNum">    1216</span>              :         size_t fils_erp_realm_len;</span>
<span id="L1217"><span class="lineNum">    1217</span>              : </span>
<span id="L1218"><span class="lineNum">    1218</span>              :         /**</span>
<span id="L1219"><span class="lineNum">    1219</span>              :          * fils_erp_next_seq_num - The next sequence number to use in FILS ERP</span>
<span id="L1220"><span class="lineNum">    1220</span>              :          * messages</span>
<span id="L1221"><span class="lineNum">    1221</span>              :          */</span>
<span id="L1222"><span class="lineNum">    1222</span>              :         u16 fils_erp_next_seq_num;</span>
<span id="L1223"><span class="lineNum">    1223</span>              : </span>
<span id="L1224"><span class="lineNum">    1224</span>              :         /**</span>
<span id="L1225"><span class="lineNum">    1225</span>              :          * fils_erp_rrk - Re-authentication root key (rRK) for the keyName-NAI</span>
<span id="L1226"><span class="lineNum">    1226</span>              :          * specified by fils_erp_username@fils_erp_realm.</span>
<span id="L1227"><span class="lineNum">    1227</span>              :          */</span>
<span id="L1228"><span class="lineNum">    1228</span>              :         const u8 *fils_erp_rrk;</span>
<span id="L1229"><span class="lineNum">    1229</span>              : </span>
<span id="L1230"><span class="lineNum">    1230</span>              :         /**</span>
<span id="L1231"><span class="lineNum">    1231</span>              :          * fils_erp_rrk_len - Length of fils_erp_rrk in bytes</span>
<span id="L1232"><span class="lineNum">    1232</span>              :          */</span>
<span id="L1233"><span class="lineNum">    1233</span>              :         size_t fils_erp_rrk_len;</span>
<span id="L1234"><span class="lineNum">    1234</span>              : </span>
<span id="L1235"><span class="lineNum">    1235</span>              :         /**</span>
<span id="L1236"><span class="lineNum">    1236</span>              :          * sae_pwe - SAE mechanism for PWE derivation</span>
<span id="L1237"><span class="lineNum">    1237</span>              :          * 0 = hunting-and-pecking loop only</span>
<span id="L1238"><span class="lineNum">    1238</span>              :          * 1 = hash-to-element only</span>
<span id="L1239"><span class="lineNum">    1239</span>              :          * 2 = both hunting-and-pecking loop and hash-to-element enabled</span>
<span id="L1240"><span class="lineNum">    1240</span>              :          */</span>
<span id="L1241"><span class="lineNum">    1241</span>              :         int sae_pwe;</span>
<span id="L1242"><span class="lineNum">    1242</span>              : };</span>
<span id="L1243"><span class="lineNum">    1243</span>              : </span>
<span id="L1244"><span class="lineNum">    1244</span>              : enum hide_ssid {</span>
<span id="L1245"><span class="lineNum">    1245</span>              :         NO_SSID_HIDING,</span>
<span id="L1246"><span class="lineNum">    1246</span>              :         HIDDEN_SSID_ZERO_LEN,</span>
<span id="L1247"><span class="lineNum">    1247</span>              :         HIDDEN_SSID_ZERO_CONTENTS</span>
<span id="L1248"><span class="lineNum">    1248</span>              : };</span>
<span id="L1249"><span class="lineNum">    1249</span>              : </span>
<span id="L1250"><span class="lineNum">    1250</span>              : enum ch_switch_state {</span>
<span id="L1251"><span class="lineNum">    1251</span>              :         CH_SW_STARTED,</span>
<span id="L1252"><span class="lineNum">    1252</span>              :         CH_SW_FINISHED</span>
<span id="L1253"><span class="lineNum">    1253</span>              : };</span>
<span id="L1254"><span class="lineNum">    1254</span>              : </span>
<span id="L1255"><span class="lineNum">    1255</span>              : struct wowlan_triggers {</span>
<span id="L1256"><span class="lineNum">    1256</span>              :         u8 any;</span>
<span id="L1257"><span class="lineNum">    1257</span>              :         u8 disconnect;</span>
<span id="L1258"><span class="lineNum">    1258</span>              :         u8 magic_pkt;</span>
<span id="L1259"><span class="lineNum">    1259</span>              :         u8 gtk_rekey_failure;</span>
<span id="L1260"><span class="lineNum">    1260</span>              :         u8 eap_identity_req;</span>
<span id="L1261"><span class="lineNum">    1261</span>              :         u8 four_way_handshake;</span>
<span id="L1262"><span class="lineNum">    1262</span>              :         u8 rfkill_release;</span>
<span id="L1263"><span class="lineNum">    1263</span>              : };</span>
<span id="L1264"><span class="lineNum">    1264</span>              : </span>
<span id="L1265"><span class="lineNum">    1265</span>              : struct wpa_driver_ap_params {</span>
<span id="L1266"><span class="lineNum">    1266</span>              :         /**</span>
<span id="L1267"><span class="lineNum">    1267</span>              :          * head - Beacon head from IEEE 802.11 header to IEs before TIM IE</span>
<span id="L1268"><span class="lineNum">    1268</span>              :          */</span>
<span id="L1269"><span class="lineNum">    1269</span>              :         u8 *head;</span>
<span id="L1270"><span class="lineNum">    1270</span>              : </span>
<span id="L1271"><span class="lineNum">    1271</span>              :         /**</span>
<span id="L1272"><span class="lineNum">    1272</span>              :          * head_len - Length of the head buffer in octets</span>
<span id="L1273"><span class="lineNum">    1273</span>              :          */</span>
<span id="L1274"><span class="lineNum">    1274</span>              :         size_t head_len;</span>
<span id="L1275"><span class="lineNum">    1275</span>              : </span>
<span id="L1276"><span class="lineNum">    1276</span>              :         /**</span>
<span id="L1277"><span class="lineNum">    1277</span>              :          * tail - Beacon tail following TIM IE</span>
<span id="L1278"><span class="lineNum">    1278</span>              :          */</span>
<span id="L1279"><span class="lineNum">    1279</span>              :         u8 *tail;</span>
<span id="L1280"><span class="lineNum">    1280</span>              : </span>
<span id="L1281"><span class="lineNum">    1281</span>              :         /**</span>
<span id="L1282"><span class="lineNum">    1282</span>              :          * tail_len - Length of the tail buffer in octets</span>
<span id="L1283"><span class="lineNum">    1283</span>              :          */</span>
<span id="L1284"><span class="lineNum">    1284</span>              :         size_t tail_len;</span>
<span id="L1285"><span class="lineNum">    1285</span>              : </span>
<span id="L1286"><span class="lineNum">    1286</span>              :         /**</span>
<span id="L1287"><span class="lineNum">    1287</span>              :          * dtim_period - DTIM period</span>
<span id="L1288"><span class="lineNum">    1288</span>              :          */</span>
<span id="L1289"><span class="lineNum">    1289</span>              :         int dtim_period;</span>
<span id="L1290"><span class="lineNum">    1290</span>              : </span>
<span id="L1291"><span class="lineNum">    1291</span>              :         /**</span>
<span id="L1292"><span class="lineNum">    1292</span>              :          * beacon_int - Beacon interval</span>
<span id="L1293"><span class="lineNum">    1293</span>              :          */</span>
<span id="L1294"><span class="lineNum">    1294</span>              :         int beacon_int;</span>
<span id="L1295"><span class="lineNum">    1295</span>              : </span>
<span id="L1296"><span class="lineNum">    1296</span>              :         /**</span>
<span id="L1297"><span class="lineNum">    1297</span>              :          * basic_rates: -1 terminated array of basic rates in 100 kbps</span>
<span id="L1298"><span class="lineNum">    1298</span>              :          *</span>
<span id="L1299"><span class="lineNum">    1299</span>              :          * This parameter can be used to set a specific basic rate set for the</span>
<span id="L1300"><span class="lineNum">    1300</span>              :          * BSS. If %NULL, default basic rate set is used.</span>
<span id="L1301"><span class="lineNum">    1301</span>              :          */</span>
<span id="L1302"><span class="lineNum">    1302</span>              :         int *basic_rates;</span>
<span id="L1303"><span class="lineNum">    1303</span>              : </span>
<span id="L1304"><span class="lineNum">    1304</span>              :         /**</span>
<span id="L1305"><span class="lineNum">    1305</span>              :          * beacon_rate: Beacon frame data rate</span>
<span id="L1306"><span class="lineNum">    1306</span>              :          *</span>
<span id="L1307"><span class="lineNum">    1307</span>              :          * This parameter can be used to set a specific Beacon frame data rate</span>
<span id="L1308"><span class="lineNum">    1308</span>              :          * for the BSS. The interpretation of this value depends on the</span>
<span id="L1309"><span class="lineNum">    1309</span>              :          * rate_type (legacy: in 100 kbps units, HT: HT-MCS, VHT: VHT-MCS,</span>
<span id="L1310"><span class="lineNum">    1310</span>              :          * HE: HE-MCS). If beacon_rate == 0 and rate_type == 0</span>
<span id="L1311"><span class="lineNum">    1311</span>              :          * (BEACON_RATE_LEGACY), the default Beacon frame data rate is used.</span>
<span id="L1312"><span class="lineNum">    1312</span>              :          */</span>
<span id="L1313"><span class="lineNum">    1313</span>              :         unsigned int beacon_rate;</span>
<span id="L1314"><span class="lineNum">    1314</span>              : </span>
<span id="L1315"><span class="lineNum">    1315</span>              :         /**</span>
<span id="L1316"><span class="lineNum">    1316</span>              :          * beacon_rate_type: Beacon data rate type (legacy/HT/VHT/HE)</span>
<span id="L1317"><span class="lineNum">    1317</span>              :          */</span>
<span id="L1318"><span class="lineNum">    1318</span>              :         enum beacon_rate_type rate_type;</span>
<span id="L1319"><span class="lineNum">    1319</span>              : </span>
<span id="L1320"><span class="lineNum">    1320</span>              :         /**</span>
<span id="L1321"><span class="lineNum">    1321</span>              :          * proberesp - Probe Response template</span>
<span id="L1322"><span class="lineNum">    1322</span>              :          *</span>
<span id="L1323"><span class="lineNum">    1323</span>              :          * This is used by drivers that reply to Probe Requests internally in</span>
<span id="L1324"><span class="lineNum">    1324</span>              :          * AP mode and require the full Probe Response template.</span>
<span id="L1325"><span class="lineNum">    1325</span>              :          */</span>
<span id="L1326"><span class="lineNum">    1326</span>              :         u8 *proberesp;</span>
<span id="L1327"><span class="lineNum">    1327</span>              : </span>
<span id="L1328"><span class="lineNum">    1328</span>              :         /**</span>
<span id="L1329"><span class="lineNum">    1329</span>              :          * proberesp_len - Length of the proberesp buffer in octets</span>
<span id="L1330"><span class="lineNum">    1330</span>              :          */</span>
<span id="L1331"><span class="lineNum">    1331</span>              :         size_t proberesp_len;</span>
<span id="L1332"><span class="lineNum">    1332</span>              : </span>
<span id="L1333"><span class="lineNum">    1333</span>              :         /**</span>
<span id="L1334"><span class="lineNum">    1334</span>              :          * ssid - The SSID to use in Beacon/Probe Response frames</span>
<span id="L1335"><span class="lineNum">    1335</span>              :          */</span>
<span id="L1336"><span class="lineNum">    1336</span>              :         const u8 *ssid;</span>
<span id="L1337"><span class="lineNum">    1337</span>              : </span>
<span id="L1338"><span class="lineNum">    1338</span>              :         /**</span>
<span id="L1339"><span class="lineNum">    1339</span>              :          * ssid_len - Length of the SSID (1..32)</span>
<span id="L1340"><span class="lineNum">    1340</span>              :          */</span>
<span id="L1341"><span class="lineNum">    1341</span>              :         size_t ssid_len;</span>
<span id="L1342"><span class="lineNum">    1342</span>              : </span>
<span id="L1343"><span class="lineNum">    1343</span>              :         /**</span>
<span id="L1344"><span class="lineNum">    1344</span>              :          * hide_ssid - Whether to hide the SSID</span>
<span id="L1345"><span class="lineNum">    1345</span>              :          */</span>
<span id="L1346"><span class="lineNum">    1346</span>              :         enum hide_ssid hide_ssid;</span>
<span id="L1347"><span class="lineNum">    1347</span>              : </span>
<span id="L1348"><span class="lineNum">    1348</span>              :         /**</span>
<span id="L1349"><span class="lineNum">    1349</span>              :          * pairwise_ciphers - WPA_CIPHER_* bitfield</span>
<span id="L1350"><span class="lineNum">    1350</span>              :          */</span>
<span id="L1351"><span class="lineNum">    1351</span>              :         unsigned int pairwise_ciphers;</span>
<span id="L1352"><span class="lineNum">    1352</span>              : </span>
<span id="L1353"><span class="lineNum">    1353</span>              :         /**</span>
<span id="L1354"><span class="lineNum">    1354</span>              :          * group_cipher - WPA_CIPHER_*</span>
<span id="L1355"><span class="lineNum">    1355</span>              :          */</span>
<span id="L1356"><span class="lineNum">    1356</span>              :         unsigned int group_cipher;</span>
<span id="L1357"><span class="lineNum">    1357</span>              : </span>
<span id="L1358"><span class="lineNum">    1358</span>              :         /**</span>
<span id="L1359"><span class="lineNum">    1359</span>              :          * key_mgmt_suites - WPA_KEY_MGMT_* bitfield</span>
<span id="L1360"><span class="lineNum">    1360</span>              :          */</span>
<span id="L1361"><span class="lineNum">    1361</span>              :         unsigned int key_mgmt_suites;</span>
<span id="L1362"><span class="lineNum">    1362</span>              : </span>
<span id="L1363"><span class="lineNum">    1363</span>              :         /**</span>
<span id="L1364"><span class="lineNum">    1364</span>              :          * auth_algs - WPA_AUTH_ALG_* bitfield</span>
<span id="L1365"><span class="lineNum">    1365</span>              :          */</span>
<span id="L1366"><span class="lineNum">    1366</span>              :         unsigned int auth_algs;</span>
<span id="L1367"><span class="lineNum">    1367</span>              : </span>
<span id="L1368"><span class="lineNum">    1368</span>              :         /**</span>
<span id="L1369"><span class="lineNum">    1369</span>              :          * wpa_version - WPA_PROTO_* bitfield</span>
<span id="L1370"><span class="lineNum">    1370</span>              :          */</span>
<span id="L1371"><span class="lineNum">    1371</span>              :         unsigned int wpa_version;</span>
<span id="L1372"><span class="lineNum">    1372</span>              : </span>
<span id="L1373"><span class="lineNum">    1373</span>              :         /**</span>
<span id="L1374"><span class="lineNum">    1374</span>              :          * privacy - Whether privacy is used in the BSS</span>
<span id="L1375"><span class="lineNum">    1375</span>              :          */</span>
<span id="L1376"><span class="lineNum">    1376</span>              :         int privacy;</span>
<span id="L1377"><span class="lineNum">    1377</span>              : </span>
<span id="L1378"><span class="lineNum">    1378</span>              :         /**</span>
<span id="L1379"><span class="lineNum">    1379</span>              :          * beacon_ies - WPS/P2P IE(s) for Beacon frames</span>
<span id="L1380"><span class="lineNum">    1380</span>              :          *</span>
<span id="L1381"><span class="lineNum">    1381</span>              :          * This is used to add IEs like WPS IE and P2P IE by drivers that do</span>
<span id="L1382"><span class="lineNum">    1382</span>              :          * not use the full Beacon template.</span>
<span id="L1383"><span class="lineNum">    1383</span>              :          */</span>
<span id="L1384"><span class="lineNum">    1384</span>              :         const struct wpabuf *beacon_ies;</span>
<span id="L1385"><span class="lineNum">    1385</span>              : </span>
<span id="L1386"><span class="lineNum">    1386</span>              :         /**</span>
<span id="L1387"><span class="lineNum">    1387</span>              :          * proberesp_ies - P2P/WPS IE(s) for Probe Response frames</span>
<span id="L1388"><span class="lineNum">    1388</span>              :          *</span>
<span id="L1389"><span class="lineNum">    1389</span>              :          * This is used to add IEs like WPS IE and P2P IE by drivers that</span>
<span id="L1390"><span class="lineNum">    1390</span>              :          * reply to Probe Request frames internally.</span>
<span id="L1391"><span class="lineNum">    1391</span>              :          */</span>
<span id="L1392"><span class="lineNum">    1392</span>              :         const struct wpabuf *proberesp_ies;</span>
<span id="L1393"><span class="lineNum">    1393</span>              : </span>
<span id="L1394"><span class="lineNum">    1394</span>              :         /**</span>
<span id="L1395"><span class="lineNum">    1395</span>              :          * assocresp_ies - WPS IE(s) for (Re)Association Response frames</span>
<span id="L1396"><span class="lineNum">    1396</span>              :          *</span>
<span id="L1397"><span class="lineNum">    1397</span>              :          * This is used to add IEs like WPS IE by drivers that reply to</span>
<span id="L1398"><span class="lineNum">    1398</span>              :          * (Re)Association Request frames internally.</span>
<span id="L1399"><span class="lineNum">    1399</span>              :          */</span>
<span id="L1400"><span class="lineNum">    1400</span>              :         const struct wpabuf *assocresp_ies;</span>
<span id="L1401"><span class="lineNum">    1401</span>              : </span>
<span id="L1402"><span class="lineNum">    1402</span>              :         /**</span>
<span id="L1403"><span class="lineNum">    1403</span>              :          * isolate - Whether to isolate frames between associated stations</span>
<span id="L1404"><span class="lineNum">    1404</span>              :          *</span>
<span id="L1405"><span class="lineNum">    1405</span>              :          * If this is non-zero, the AP is requested to disable forwarding of</span>
<span id="L1406"><span class="lineNum">    1406</span>              :          * frames between associated stations.</span>
<span id="L1407"><span class="lineNum">    1407</span>              :          */</span>
<span id="L1408"><span class="lineNum">    1408</span>              :         int isolate;</span>
<span id="L1409"><span class="lineNum">    1409</span>              : </span>
<span id="L1410"><span class="lineNum">    1410</span>              :         /**</span>
<span id="L1411"><span class="lineNum">    1411</span>              :          * cts_protect - Whether CTS protection is enabled</span>
<span id="L1412"><span class="lineNum">    1412</span>              :          */</span>
<span id="L1413"><span class="lineNum">    1413</span>              :         int cts_protect;</span>
<span id="L1414"><span class="lineNum">    1414</span>              : </span>
<span id="L1415"><span class="lineNum">    1415</span>              :         /**</span>
<span id="L1416"><span class="lineNum">    1416</span>              :          * preamble - Whether short preamble is enabled</span>
<span id="L1417"><span class="lineNum">    1417</span>              :          */</span>
<span id="L1418"><span class="lineNum">    1418</span>              :         int preamble;</span>
<span id="L1419"><span class="lineNum">    1419</span>              : </span>
<span id="L1420"><span class="lineNum">    1420</span>              :         /**</span>
<span id="L1421"><span class="lineNum">    1421</span>              :          * short_slot_time - Whether short slot time is enabled</span>
<span id="L1422"><span class="lineNum">    1422</span>              :          *</span>
<span id="L1423"><span class="lineNum">    1423</span>              :          * 0 = short slot time disable, 1 = short slot time enabled, -1 = do</span>
<span id="L1424"><span class="lineNum">    1424</span>              :          * not set (e.g., when 802.11g mode is not in use)</span>
<span id="L1425"><span class="lineNum">    1425</span>              :          */</span>
<span id="L1426"><span class="lineNum">    1426</span>              :         int short_slot_time;</span>
<span id="L1427"><span class="lineNum">    1427</span>              : </span>
<span id="L1428"><span class="lineNum">    1428</span>              :         /**</span>
<span id="L1429"><span class="lineNum">    1429</span>              :          * ht_opmode - HT operation mode or -1 if HT not in use</span>
<span id="L1430"><span class="lineNum">    1430</span>              :          */</span>
<span id="L1431"><span class="lineNum">    1431</span>              :         int ht_opmode;</span>
<span id="L1432"><span class="lineNum">    1432</span>              : </span>
<span id="L1433"><span class="lineNum">    1433</span>              :         /**</span>
<span id="L1434"><span class="lineNum">    1434</span>              :          * interworking - Whether Interworking is enabled</span>
<span id="L1435"><span class="lineNum">    1435</span>              :          */</span>
<span id="L1436"><span class="lineNum">    1436</span>              :         int interworking;</span>
<span id="L1437"><span class="lineNum">    1437</span>              : </span>
<span id="L1438"><span class="lineNum">    1438</span>              :         /**</span>
<span id="L1439"><span class="lineNum">    1439</span>              :          * hessid - Homogeneous ESS identifier or %NULL if not set</span>
<span id="L1440"><span class="lineNum">    1440</span>              :          */</span>
<span id="L1441"><span class="lineNum">    1441</span>              :         const u8 *hessid;</span>
<span id="L1442"><span class="lineNum">    1442</span>              : </span>
<span id="L1443"><span class="lineNum">    1443</span>              :         /**</span>
<span id="L1444"><span class="lineNum">    1444</span>              :          * access_network_type - Access Network Type (0..15)</span>
<span id="L1445"><span class="lineNum">    1445</span>              :          *</span>
<span id="L1446"><span class="lineNum">    1446</span>              :          * This is used for filtering Probe Request frames when Interworking is</span>
<span id="L1447"><span class="lineNum">    1447</span>              :          * enabled.</span>
<span id="L1448"><span class="lineNum">    1448</span>              :          */</span>
<span id="L1449"><span class="lineNum">    1449</span>              :         u8 access_network_type;</span>
<span id="L1450"><span class="lineNum">    1450</span>              : </span>
<span id="L1451"><span class="lineNum">    1451</span>              :         /**</span>
<span id="L1452"><span class="lineNum">    1452</span>              :          * ap_max_inactivity - Timeout in seconds to detect STA's inactivity</span>
<span id="L1453"><span class="lineNum">    1453</span>              :          *</span>
<span id="L1454"><span class="lineNum">    1454</span>              :          * This is used by driver which advertises this capability.</span>
<span id="L1455"><span class="lineNum">    1455</span>              :          */</span>
<span id="L1456"><span class="lineNum">    1456</span>              :         int ap_max_inactivity;</span>
<span id="L1457"><span class="lineNum">    1457</span>              : </span>
<span id="L1458"><span class="lineNum">    1458</span>              :         /**</span>
<span id="L1459"><span class="lineNum">    1459</span>              :          * ctwindow - Client Traffic Window (in TUs)</span>
<span id="L1460"><span class="lineNum">    1460</span>              :          */</span>
<span id="L1461"><span class="lineNum">    1461</span>              :         u8 p2p_go_ctwindow;</span>
<span id="L1462"><span class="lineNum">    1462</span>              : </span>
<span id="L1463"><span class="lineNum">    1463</span>              :         /**</span>
<span id="L1464"><span class="lineNum">    1464</span>              :          * disable_dgaf - Whether group-addressed frames are disabled</span>
<span id="L1465"><span class="lineNum">    1465</span>              :          */</span>
<span id="L1466"><span class="lineNum">    1466</span>              :         int disable_dgaf;</span>
<span id="L1467"><span class="lineNum">    1467</span>              : </span>
<span id="L1468"><span class="lineNum">    1468</span>              :         /**</span>
<span id="L1469"><span class="lineNum">    1469</span>              :          * osen - Whether OSEN security is enabled</span>
<span id="L1470"><span class="lineNum">    1470</span>              :          */</span>
<span id="L1471"><span class="lineNum">    1471</span>              :         int osen;</span>
<span id="L1472"><span class="lineNum">    1472</span>              : </span>
<span id="L1473"><span class="lineNum">    1473</span>              :         /**</span>
<span id="L1474"><span class="lineNum">    1474</span>              :          * freq - Channel parameters for dynamic bandwidth changes</span>
<span id="L1475"><span class="lineNum">    1475</span>              :          */</span>
<span id="L1476"><span class="lineNum">    1476</span>              :         struct hostapd_freq_params *freq;</span>
<span id="L1477"><span class="lineNum">    1477</span>              : </span>
<span id="L1478"><span class="lineNum">    1478</span>              :         /**</span>
<span id="L1479"><span class="lineNum">    1479</span>              :          * reenable - Whether this is to re-enable beaconing</span>
<span id="L1480"><span class="lineNum">    1480</span>              :          */</span>
<span id="L1481"><span class="lineNum">    1481</span>              :         int reenable;</span>
<span id="L1482"><span class="lineNum">    1482</span>              : </span>
<span id="L1483"><span class="lineNum">    1483</span>              :         /**</span>
<span id="L1484"><span class="lineNum">    1484</span>              :          * pbss - Whether to start a PCP (in PBSS) instead of an AP in</span>
<span id="L1485"><span class="lineNum">    1485</span>              :          * infrastructure BSS. Valid only for DMG network.</span>
<span id="L1486"><span class="lineNum">    1486</span>              :          */</span>
<span id="L1487"><span class="lineNum">    1487</span>              :         int pbss;</span>
<span id="L1488"><span class="lineNum">    1488</span>              : </span>
<span id="L1489"><span class="lineNum">    1489</span>              :         /**</span>
<span id="L1490"><span class="lineNum">    1490</span>              :          * multicast_to_unicast - Whether to use multicast_to_unicast</span>
<span id="L1491"><span class="lineNum">    1491</span>              :          *</span>
<span id="L1492"><span class="lineNum">    1492</span>              :          * If this is non-zero, the AP is requested to perform multicast to</span>
<span id="L1493"><span class="lineNum">    1493</span>              :          * unicast conversion for ARP, IPv4, and IPv6 frames (possibly within</span>
<span id="L1494"><span class="lineNum">    1494</span>              :          * 802.1Q). If enabled, such frames are to be sent to each station</span>
<span id="L1495"><span class="lineNum">    1495</span>              :          * separately, with the DA replaced by their own MAC address rather</span>
<span id="L1496"><span class="lineNum">    1496</span>              :          * than the group address.</span>
<span id="L1497"><span class="lineNum">    1497</span>              :          *</span>
<span id="L1498"><span class="lineNum">    1498</span>              :          * Note that this may break certain expectations of the receiver, such</span>
<span id="L1499"><span class="lineNum">    1499</span>              :          * as the ability to drop unicast IP packets received within multicast</span>
<span id="L1500"><span class="lineNum">    1500</span>              :          * L2 frames, or the ability to not send ICMP destination unreachable</span>
<span id="L1501"><span class="lineNum">    1501</span>              :          * messages for packets received in L2 multicast (which is required,</span>
<span id="L1502"><span class="lineNum">    1502</span>              :          * but the receiver can't tell the difference if this new option is</span>
<span id="L1503"><span class="lineNum">    1503</span>              :          * enabled.)</span>
<span id="L1504"><span class="lineNum">    1504</span>              :          *</span>
<span id="L1505"><span class="lineNum">    1505</span>              :          * This also doesn't implement the 802.11 DMS (directed multicast</span>
<span id="L1506"><span class="lineNum">    1506</span>              :          * service).</span>
<span id="L1507"><span class="lineNum">    1507</span>              :          */</span>
<span id="L1508"><span class="lineNum">    1508</span>              :         int multicast_to_unicast;</span>
<span id="L1509"><span class="lineNum">    1509</span>              : </span>
<span id="L1510"><span class="lineNum">    1510</span>              :         /**</span>
<span id="L1511"><span class="lineNum">    1511</span>              :          * ftm_responder - Whether FTM responder is enabled</span>
<span id="L1512"><span class="lineNum">    1512</span>              :          */</span>
<span id="L1513"><span class="lineNum">    1513</span>              :         int ftm_responder;</span>
<span id="L1514"><span class="lineNum">    1514</span>              : </span>
<span id="L1515"><span class="lineNum">    1515</span>              :         /**</span>
<span id="L1516"><span class="lineNum">    1516</span>              :          * lci - Binary data, the content of an LCI report IE with type 8 as</span>
<span id="L1517"><span class="lineNum">    1517</span>              :          * defined in IEEE Std 802.11-2016, 9.4.2.22.10</span>
<span id="L1518"><span class="lineNum">    1518</span>              :          */</span>
<span id="L1519"><span class="lineNum">    1519</span>              :         const struct wpabuf *lci;</span>
<span id="L1520"><span class="lineNum">    1520</span>              : </span>
<span id="L1521"><span class="lineNum">    1521</span>              :         /**</span>
<span id="L1522"><span class="lineNum">    1522</span>              :          * civic - Binary data, the content of a measurement report IE with</span>
<span id="L1523"><span class="lineNum">    1523</span>              :          * type 11 as defined in IEEE Std 802.11-2016, 9.4.2.22.13</span>
<span id="L1524"><span class="lineNum">    1524</span>              :          */</span>
<span id="L1525"><span class="lineNum">    1525</span>              :         const struct wpabuf *civic;</span>
<span id="L1526"><span class="lineNum">    1526</span>              : </span>
<span id="L1527"><span class="lineNum">    1527</span>              :         /**</span>
<span id="L1528"><span class="lineNum">    1528</span>              :          * he_spr_ctrl - Spatial Reuse control field of SPR element</span>
<span id="L1529"><span class="lineNum">    1529</span>              :          */</span>
<span id="L1530"><span class="lineNum">    1530</span>              :         u8 he_spr_ctrl;</span>
<span id="L1531"><span class="lineNum">    1531</span>              : </span>
<span id="L1532"><span class="lineNum">    1532</span>              :         /**</span>
<span id="L1533"><span class="lineNum">    1533</span>              :          * he_spr_non_srg_obss_pd_max_offset - Non-SRG Maximum TX power offset</span>
<span id="L1534"><span class="lineNum">    1534</span>              :          */</span>
<span id="L1535"><span class="lineNum">    1535</span>              :         u8 he_spr_non_srg_obss_pd_max_offset;</span>
<span id="L1536"><span class="lineNum">    1536</span>              : </span>
<span id="L1537"><span class="lineNum">    1537</span>              :         /**</span>
<span id="L1538"><span class="lineNum">    1538</span>              :          * he_spr_srg_obss_pd_min_offset - Minimum TX power offset</span>
<span id="L1539"><span class="lineNum">    1539</span>              :          */</span>
<span id="L1540"><span class="lineNum">    1540</span>              :         u8 he_spr_srg_obss_pd_min_offset;</span>
<span id="L1541"><span class="lineNum">    1541</span>              : </span>
<span id="L1542"><span class="lineNum">    1542</span>              :         /**</span>
<span id="L1543"><span class="lineNum">    1543</span>              :          * he_spr_srg_obss_pd_max_offset - Maximum TX power offset</span>
<span id="L1544"><span class="lineNum">    1544</span>              :          */</span>
<span id="L1545"><span class="lineNum">    1545</span>              :         u8 he_spr_srg_obss_pd_max_offset;</span>
<span id="L1546"><span class="lineNum">    1546</span>              : </span>
<span id="L1547"><span class="lineNum">    1547</span>              :         /**</span>
<span id="L1548"><span class="lineNum">    1548</span>              :          * he_spr_bss_color_bitmap - BSS color values used by members of the</span>
<span id="L1549"><span class="lineNum">    1549</span>              :          * SRG.</span>
<span id="L1550"><span class="lineNum">    1550</span>              :          */</span>
<span id="L1551"><span class="lineNum">    1551</span>              :         u8 he_spr_bss_color_bitmap[8];</span>
<span id="L1552"><span class="lineNum">    1552</span>              : </span>
<span id="L1553"><span class="lineNum">    1553</span>              :         /**</span>
<span id="L1554"><span class="lineNum">    1554</span>              :          * he_spr_partial_bssid_bitmap - Partial BSSID values used by members</span>
<span id="L1555"><span class="lineNum">    1555</span>              :          * of the SRG.</span>
<span id="L1556"><span class="lineNum">    1556</span>              :          */</span>
<span id="L1557"><span class="lineNum">    1557</span>              :         u8 he_spr_partial_bssid_bitmap[8];</span>
<span id="L1558"><span class="lineNum">    1558</span>              : </span>
<span id="L1559"><span class="lineNum">    1559</span>              :         /**</span>
<span id="L1560"><span class="lineNum">    1560</span>              :          * he_bss_color - Whether the BSS Color is disabled</span>
<span id="L1561"><span class="lineNum">    1561</span>              :          */</span>
<span id="L1562"><span class="lineNum">    1562</span>              :         int he_bss_color_disabled;</span>
<span id="L1563"><span class="lineNum">    1563</span>              : </span>
<span id="L1564"><span class="lineNum">    1564</span>              :         /**</span>
<span id="L1565"><span class="lineNum">    1565</span>              :          * he_bss_color_partial - The BSS Color AID equation</span>
<span id="L1566"><span class="lineNum">    1566</span>              :          */</span>
<span id="L1567"><span class="lineNum">    1567</span>              :         int he_bss_color_partial;</span>
<span id="L1568"><span class="lineNum">    1568</span>              : </span>
<span id="L1569"><span class="lineNum">    1569</span>              :         /**</span>
<span id="L1570"><span class="lineNum">    1570</span>              :          * he_bss_color - The BSS Color of the AP</span>
<span id="L1571"><span class="lineNum">    1571</span>              :          */</span>
<span id="L1572"><span class="lineNum">    1572</span>              :         int he_bss_color;</span>
<span id="L1573"><span class="lineNum">    1573</span>              : </span>
<span id="L1574"><span class="lineNum">    1574</span>              :         /**</span>
<span id="L1575"><span class="lineNum">    1575</span>              :          * twt_responder - Whether Target Wait Time responder is enabled</span>
<span id="L1576"><span class="lineNum">    1576</span>              :          */</span>
<span id="L1577"><span class="lineNum">    1577</span>              :         int twt_responder;</span>
<span id="L1578"><span class="lineNum">    1578</span>              : </span>
<span id="L1579"><span class="lineNum">    1579</span>              :         /**</span>
<span id="L1580"><span class="lineNum">    1580</span>              :          * sae_pwe - SAE mechanism for PWE derivation</span>
<span id="L1581"><span class="lineNum">    1581</span>              :          * 0 = hunting-and-pecking loop only</span>
<span id="L1582"><span class="lineNum">    1582</span>              :          * 1 = hash-to-element only</span>
<span id="L1583"><span class="lineNum">    1583</span>              :          * 2 = both hunting-and-pecking loop and hash-to-element enabled</span>
<span id="L1584"><span class="lineNum">    1584</span>              :          */</span>
<span id="L1585"><span class="lineNum">    1585</span>              :         int sae_pwe;</span>
<span id="L1586"><span class="lineNum">    1586</span>              : </span>
<span id="L1587"><span class="lineNum">    1587</span>              :         /**</span>
<span id="L1588"><span class="lineNum">    1588</span>              :          * FILS Discovery frame minimum interval in TUs</span>
<span id="L1589"><span class="lineNum">    1589</span>              :          */</span>
<span id="L1590"><span class="lineNum">    1590</span>              :         u32 fd_min_int;</span>
<span id="L1591"><span class="lineNum">    1591</span>              : </span>
<span id="L1592"><span class="lineNum">    1592</span>              :         /**</span>
<span id="L1593"><span class="lineNum">    1593</span>              :          * FILS Discovery frame maximum interval in TUs (0 = FD frame disabled)</span>
<span id="L1594"><span class="lineNum">    1594</span>              :          */</span>
<span id="L1595"><span class="lineNum">    1595</span>              :         u32 fd_max_int;</span>
<span id="L1596"><span class="lineNum">    1596</span>              : </span>
<span id="L1597"><span class="lineNum">    1597</span>              :         /**</span>
<span id="L1598"><span class="lineNum">    1598</span>              :          * FILS Discovery frame template data</span>
<span id="L1599"><span class="lineNum">    1599</span>              :          */</span>
<span id="L1600"><span class="lineNum">    1600</span>              :         u8 *fd_frame_tmpl;</span>
<span id="L1601"><span class="lineNum">    1601</span>              : </span>
<span id="L1602"><span class="lineNum">    1602</span>              :         /**</span>
<span id="L1603"><span class="lineNum">    1603</span>              :          * FILS Discovery frame template length</span>
<span id="L1604"><span class="lineNum">    1604</span>              :          */</span>
<span id="L1605"><span class="lineNum">    1605</span>              :         size_t fd_frame_tmpl_len;</span>
<span id="L1606"><span class="lineNum">    1606</span>              : </span>
<span id="L1607"><span class="lineNum">    1607</span>              :         /**</span>
<span id="L1608"><span class="lineNum">    1608</span>              :          * Unsolicited broadcast Probe Response interval in TUs</span>
<span id="L1609"><span class="lineNum">    1609</span>              :          */</span>
<span id="L1610"><span class="lineNum">    1610</span>              :         unsigned int unsol_bcast_probe_resp_interval;</span>
<span id="L1611"><span class="lineNum">    1611</span>              : </span>
<span id="L1612"><span class="lineNum">    1612</span>              :         /**</span>
<span id="L1613"><span class="lineNum">    1613</span>              :          * Unsolicited broadcast Probe Response template data</span>
<span id="L1614"><span class="lineNum">    1614</span>              :          */</span>
<span id="L1615"><span class="lineNum">    1615</span>              :         u8 *unsol_bcast_probe_resp_tmpl;</span>
<span id="L1616"><span class="lineNum">    1616</span>              : </span>
<span id="L1617"><span class="lineNum">    1617</span>              :         /**</span>
<span id="L1618"><span class="lineNum">    1618</span>              :          * Unsolicited broadcast Probe Response template length</span>
<span id="L1619"><span class="lineNum">    1619</span>              :          */</span>
<span id="L1620"><span class="lineNum">    1620</span>              :         size_t unsol_bcast_probe_resp_tmpl_len;</span>
<span id="L1621"><span class="lineNum">    1621</span>              : };</span>
<span id="L1622"><span class="lineNum">    1622</span>              : </span>
<span id="L1623"><span class="lineNum">    1623</span>              : struct wpa_driver_mesh_bss_params {</span>
<span id="L1624"><span class="lineNum">    1624</span>              : #define WPA_DRIVER_MESH_CONF_FLAG_AUTO_PLINKS           0x00000001</span>
<span id="L1625"><span class="lineNum">    1625</span>              : #define WPA_DRIVER_MESH_CONF_FLAG_PEER_LINK_TIMEOUT     0x00000002</span>
<span id="L1626"><span class="lineNum">    1626</span>              : #define WPA_DRIVER_MESH_CONF_FLAG_MAX_PEER_LINKS        0x00000004</span>
<span id="L1627"><span class="lineNum">    1627</span>              : #define WPA_DRIVER_MESH_CONF_FLAG_HT_OP_MODE            0x00000008</span>
<span id="L1628"><span class="lineNum">    1628</span>              : #define WPA_DRIVER_MESH_CONF_FLAG_RSSI_THRESHOLD        0x00000010</span>
<span id="L1629"><span class="lineNum">    1629</span>              : #define WPA_DRIVER_MESH_CONF_FLAG_FORWARDING            0x00000020</span>
<span id="L1630"><span class="lineNum">    1630</span>              :         /*</span>
<span id="L1631"><span class="lineNum">    1631</span>              :          * TODO: Other mesh configuration parameters would go here.</span>
<span id="L1632"><span class="lineNum">    1632</span>              :          * See NL80211_MESHCONF_* for all the mesh config parameters.</span>
<span id="L1633"><span class="lineNum">    1633</span>              :          */</span>
<span id="L1634"><span class="lineNum">    1634</span>              :         unsigned int flags;</span>
<span id="L1635"><span class="lineNum">    1635</span>              :         int auto_plinks;</span>
<span id="L1636"><span class="lineNum">    1636</span>              :         int peer_link_timeout;</span>
<span id="L1637"><span class="lineNum">    1637</span>              :         int max_peer_links;</span>
<span id="L1638"><span class="lineNum">    1638</span>              :         int rssi_threshold;</span>
<span id="L1639"><span class="lineNum">    1639</span>              :         int forwarding;</span>
<span id="L1640"><span class="lineNum">    1640</span>              :         u16 ht_opmode;</span>
<span id="L1641"><span class="lineNum">    1641</span>              : };</span>
<span id="L1642"><span class="lineNum">    1642</span>              : </span>
<span id="L1643"><span class="lineNum">    1643</span>              : struct wpa_driver_mesh_join_params {</span>
<span id="L1644"><span class="lineNum">    1644</span>              :         const u8 *meshid;</span>
<span id="L1645"><span class="lineNum">    1645</span>              :         int meshid_len;</span>
<span id="L1646"><span class="lineNum">    1646</span>              :         const int *basic_rates;</span>
<span id="L1647"><span class="lineNum">    1647</span>              :         const u8 *ies;</span>
<span id="L1648"><span class="lineNum">    1648</span>              :         int ie_len;</span>
<span id="L1649"><span class="lineNum">    1649</span>              :         struct hostapd_freq_params freq;</span>
<span id="L1650"><span class="lineNum">    1650</span>              :         int beacon_int;</span>
<span id="L1651"><span class="lineNum">    1651</span>              :         int dtim_period;</span>
<span id="L1652"><span class="lineNum">    1652</span>              :         struct wpa_driver_mesh_bss_params conf;</span>
<span id="L1653"><span class="lineNum">    1653</span>              : #define WPA_DRIVER_MESH_FLAG_USER_MPM   0x00000001</span>
<span id="L1654"><span class="lineNum">    1654</span>              : #define WPA_DRIVER_MESH_FLAG_DRIVER_MPM 0x00000002</span>
<span id="L1655"><span class="lineNum">    1655</span>              : #define WPA_DRIVER_MESH_FLAG_SAE_AUTH   0x00000004</span>
<span id="L1656"><span class="lineNum">    1656</span>              : #define WPA_DRIVER_MESH_FLAG_AMPE       0x00000008</span>
<span id="L1657"><span class="lineNum">    1657</span>              :         unsigned int flags;</span>
<span id="L1658"><span class="lineNum">    1658</span>              :         bool handle_dfs;</span>
<span id="L1659"><span class="lineNum">    1659</span>              : };</span>
<span id="L1660"><span class="lineNum">    1660</span>              : </span>
<span id="L1661"><span class="lineNum">    1661</span>              : struct wpa_driver_set_key_params {</span>
<span id="L1662"><span class="lineNum">    1662</span>              :         /**</span>
<span id="L1663"><span class="lineNum">    1663</span>              :          * ifname - Interface name (for multi-SSID/VLAN support) */</span>
<span id="L1664"><span class="lineNum">    1664</span>              :         const char *ifname;</span>
<span id="L1665"><span class="lineNum">    1665</span>              : </span>
<span id="L1666"><span class="lineNum">    1666</span>              :         /**</span>
<span id="L1667"><span class="lineNum">    1667</span>              :          * alg - Encryption algorithm</span>
<span id="L1668"><span class="lineNum">    1668</span>              :          *</span>
<span id="L1669"><span class="lineNum">    1669</span>              :          * (%WPA_ALG_NONE, %WPA_ALG_WEP, %WPA_ALG_TKIP, %WPA_ALG_CCMP,</span>
<span id="L1670"><span class="lineNum">    1670</span>              :          * %WPA_ALG_BIP_AES_CMAC_128, %WPA_ALG_GCMP, %WPA_ALG_GCMP_256,</span>
<span id="L1671"><span class="lineNum">    1671</span>              :          * %WPA_ALG_CCMP_256, %WPA_ALG_BIP_GMAC_128, %WPA_ALG_BIP_GMAC_256,</span>
<span id="L1672"><span class="lineNum">    1672</span>              :          * %WPA_ALG_BIP_CMAC_256);</span>
<span id="L1673"><span class="lineNum">    1673</span>              :          * %WPA_ALG_NONE clears the key. */</span>
<span id="L1674"><span class="lineNum">    1674</span>              :         enum wpa_alg alg;</span>
<span id="L1675"><span class="lineNum">    1675</span>              : </span>
<span id="L1676"><span class="lineNum">    1676</span>              :         /**</span>
<span id="L1677"><span class="lineNum">    1677</span>              :          * addr - Address of the peer STA</span>
<span id="L1678"><span class="lineNum">    1678</span>              :          *</span>
<span id="L1679"><span class="lineNum">    1679</span>              :          * (BSSID of the current AP when setting pairwise key in station mode),</span>
<span id="L1680"><span class="lineNum">    1680</span>              :          * ff:ff:ff:ff:ff:ff for broadcast keys, %NULL for default keys that</span>
<span id="L1681"><span class="lineNum">    1681</span>              :          * are used both for broadcast and unicast; when clearing keys, %NULL</span>
<span id="L1682"><span class="lineNum">    1682</span>              :          * is used to indicate that both the broadcast-only and default key of</span>
<span id="L1683"><span class="lineNum">    1683</span>              :          * the specified key index is to be cleared */</span>
<span id="L1684"><span class="lineNum">    1684</span>              :         const u8 *addr;</span>
<span id="L1685"><span class="lineNum">    1685</span>              : </span>
<span id="L1686"><span class="lineNum">    1686</span>              :         /**</span>
<span id="L1687"><span class="lineNum">    1687</span>              :          * key_idx - Key index</span>
<span id="L1688"><span class="lineNum">    1688</span>              :          *</span>
<span id="L1689"><span class="lineNum">    1689</span>              :          * (0..3), usually 0 for unicast keys; 4..5 for IGTK; 6..7 for BIGTK */</span>
<span id="L1690"><span class="lineNum">    1690</span>              :         int key_idx;</span>
<span id="L1691"><span class="lineNum">    1691</span>              : </span>
<span id="L1692"><span class="lineNum">    1692</span>              :         /**</span>
<span id="L1693"><span class="lineNum">    1693</span>              :          * set_tx - Configure this key as the default Tx key</span>
<span id="L1694"><span class="lineNum">    1694</span>              :          *</span>
<span id="L1695"><span class="lineNum">    1695</span>              :          * Only used when driver does not support separate unicast/individual</span>
<span id="L1696"><span class="lineNum">    1696</span>              :          * key */</span>
<span id="L1697"><span class="lineNum">    1697</span>              :         int set_tx;</span>
<span id="L1698"><span class="lineNum">    1698</span>              : </span>
<span id="L1699"><span class="lineNum">    1699</span>              :         /**</span>
<span id="L1700"><span class="lineNum">    1700</span>              :          * seq - Sequence number/packet number</span>
<span id="L1701"><span class="lineNum">    1701</span>              :          *</span>
<span id="L1702"><span class="lineNum">    1702</span>              :          * seq_len octets, the next packet number to be used for in replay</span>
<span id="L1703"><span class="lineNum">    1703</span>              :          * protection; configured for Rx keys (in most cases, this is only used</span>
<span id="L1704"><span class="lineNum">    1704</span>              :          * with broadcast keys and set to zero for unicast keys); %NULL if not</span>
<span id="L1705"><span class="lineNum">    1705</span>              :          * set */</span>
<span id="L1706"><span class="lineNum">    1706</span>              :         const u8 *seq;</span>
<span id="L1707"><span class="lineNum">    1707</span>              : </span>
<span id="L1708"><span class="lineNum">    1708</span>              :         /**</span>
<span id="L1709"><span class="lineNum">    1709</span>              :          * seq_len - Length of the seq, depends on the algorithm</span>
<span id="L1710"><span class="lineNum">    1710</span>              :          *</span>
<span id="L1711"><span class="lineNum">    1711</span>              :          * TKIP: 6 octets, CCMP/GCMP: 6 octets, IGTK: 6 octets */</span>
<span id="L1712"><span class="lineNum">    1712</span>              :         size_t seq_len;</span>
<span id="L1713"><span class="lineNum">    1713</span>              : </span>
<span id="L1714"><span class="lineNum">    1714</span>              :         /**</span>
<span id="L1715"><span class="lineNum">    1715</span>              :          * key - Key buffer</span>
<span id="L1716"><span class="lineNum">    1716</span>              :          *</span>
<span id="L1717"><span class="lineNum">    1717</span>              :          * TKIP: 16-byte temporal key, 8-byte Tx Mic key, 8-byte Rx Mic Key */</span>
<span id="L1718"><span class="lineNum">    1718</span>              :         const u8 *key;</span>
<span id="L1719"><span class="lineNum">    1719</span>              : </span>
<span id="L1720"><span class="lineNum">    1720</span>              :         /**</span>
<span id="L1721"><span class="lineNum">    1721</span>              :          * key_len - Length of the key buffer in octets</span>
<span id="L1722"><span class="lineNum">    1722</span>              :          *</span>
<span id="L1723"><span class="lineNum">    1723</span>              :          * WEP: 5 or 13, TKIP: 32, CCMP/GCMP: 16, IGTK: 16 */</span>
<span id="L1724"><span class="lineNum">    1724</span>              :         size_t key_len;</span>
<span id="L1725"><span class="lineNum">    1725</span>              : </span>
<span id="L1726"><span class="lineNum">    1726</span>              :         /**</span>
<span id="L1727"><span class="lineNum">    1727</span>              :          * vlan_id - VLAN index (0..4095) for VLAN offload cases */</span>
<span id="L1728"><span class="lineNum">    1728</span>              :         int vlan_id;</span>
<span id="L1729"><span class="lineNum">    1729</span>              : </span>
<span id="L1730"><span class="lineNum">    1730</span>              :         /**</span>
<span id="L1731"><span class="lineNum">    1731</span>              :          * key_flag - Additional key flags</span>
<span id="L1732"><span class="lineNum">    1732</span>              :          *</span>
<span id="L1733"><span class="lineNum">    1733</span>              :          * %KEY_FLAG_MODIFY</span>
<span id="L1734"><span class="lineNum">    1734</span>              :          *  Set when an already installed key must be updated.</span>
<span id="L1735"><span class="lineNum">    1735</span>              :          *  So far the only use-case is changing RX/TX status for</span>
<span id="L1736"><span class="lineNum">    1736</span>              :          *  pairwise keys. Must not be set when deleting a key.</span>
<span id="L1737"><span class="lineNum">    1737</span>              :          * %KEY_FLAG_DEFAULT</span>
<span id="L1738"><span class="lineNum">    1738</span>              :          *  Set when the key is also a default key. Must not be set when</span>
<span id="L1739"><span class="lineNum">    1739</span>              :          *  deleting a key.</span>
<span id="L1740"><span class="lineNum">    1740</span>              :          * %KEY_FLAG_RX</span>
<span id="L1741"><span class="lineNum">    1741</span>              :          *  The key is valid for RX. Must not be set when deleting a key.</span>
<span id="L1742"><span class="lineNum">    1742</span>              :          * %KEY_FLAG_TX</span>
<span id="L1743"><span class="lineNum">    1743</span>              :          *  The key is valid for TX. Must not be set when deleting a key.</span>
<span id="L1744"><span class="lineNum">    1744</span>              :          * %KEY_FLAG_GROUP</span>
<span id="L1745"><span class="lineNum">    1745</span>              :          *  The key is a broadcast or group key.</span>
<span id="L1746"><span class="lineNum">    1746</span>              :          * %KEY_FLAG_PAIRWISE</span>
<span id="L1747"><span class="lineNum">    1747</span>              :          *  The key is a pairwise key.</span>
<span id="L1748"><span class="lineNum">    1748</span>              :          * %KEY_FLAG_PMK</span>
<span id="L1749"><span class="lineNum">    1749</span>              :          *  The key is a Pairwise Master Key (PMK).</span>
<span id="L1750"><span class="lineNum">    1750</span>              :          *</span>
<span id="L1751"><span class="lineNum">    1751</span>              :          * Valid and pre-defined combinations are:</span>
<span id="L1752"><span class="lineNum">    1752</span>              :          * %KEY_FLAG_GROUP_RX_TX</span>
<span id="L1753"><span class="lineNum">    1753</span>              :          *  WEP key not to be installed as default key.</span>
<span id="L1754"><span class="lineNum">    1754</span>              :          * %KEY_FLAG_GROUP_RX_TX_DEFAULT</span>
<span id="L1755"><span class="lineNum">    1755</span>              :          *  Default WEP or WPA-NONE key.</span>
<span id="L1756"><span class="lineNum">    1756</span>              :          * %KEY_FLAG_GROUP_RX</span>
<span id="L1757"><span class="lineNum">    1757</span>              :          *  GTK key valid for RX only.</span>
<span id="L1758"><span class="lineNum">    1758</span>              :          * %KEY_FLAG_GROUP_TX_DEFAULT</span>
<span id="L1759"><span class="lineNum">    1759</span>              :          *  GTK key valid for TX only, immediately taking over TX.</span>
<span id="L1760"><span class="lineNum">    1760</span>              :          * %KEY_FLAG_PAIRWISE_RX_TX</span>
<span id="L1761"><span class="lineNum">    1761</span>              :          *  Pairwise key immediately becoming the active pairwise key.</span>
<span id="L1762"><span class="lineNum">    1762</span>              :          * %KEY_FLAG_PAIRWISE_RX</span>
<span id="L1763"><span class="lineNum">    1763</span>              :          *  Pairwise key not yet valid for TX. (Only usable when Extended</span>
<span id="L1764"><span class="lineNum">    1764</span>              :          *  Key ID is supported by the driver.)</span>
<span id="L1765"><span class="lineNum">    1765</span>              :          * %KEY_FLAG_PAIRWISE_RX_TX_MODIFY</span>
<span id="L1766"><span class="lineNum">    1766</span>              :          *  Enable TX for a pairwise key installed with</span>
<span id="L1767"><span class="lineNum">    1767</span>              :          *  KEY_FLAG_PAIRWISE_RX.</span>
<span id="L1768"><span class="lineNum">    1768</span>              :          *</span>
<span id="L1769"><span class="lineNum">    1769</span>              :          * Not a valid standalone key type but pre-defined to be combined</span>
<span id="L1770"><span class="lineNum">    1770</span>              :          * with other key_flags:</span>
<span id="L1771"><span class="lineNum">    1771</span>              :          * %KEY_FLAG_RX_TX</span>
<span id="L1772"><span class="lineNum">    1772</span>              :          *  RX/TX key. */</span>
<span id="L1773"><span class="lineNum">    1773</span>              :         enum key_flag key_flag;</span>
<span id="L1774"><span class="lineNum">    1774</span>              : };</span>
<span id="L1775"><span class="lineNum">    1775</span>              : </span>
<span id="L1776"><span class="lineNum">    1776</span>              : enum wpa_driver_if_type {</span>
<span id="L1777"><span class="lineNum">    1777</span>              :         /**</span>
<span id="L1778"><span class="lineNum">    1778</span>              :          * WPA_IF_STATION - Station mode interface</span>
<span id="L1779"><span class="lineNum">    1779</span>              :          */</span>
<span id="L1780"><span class="lineNum">    1780</span>              :         WPA_IF_STATION,</span>
<span id="L1781"><span class="lineNum">    1781</span>              : </span>
<span id="L1782"><span class="lineNum">    1782</span>              :         /**</span>
<span id="L1783"><span class="lineNum">    1783</span>              :          * WPA_IF_AP_VLAN - AP mode VLAN interface</span>
<span id="L1784"><span class="lineNum">    1784</span>              :          *</span>
<span id="L1785"><span class="lineNum">    1785</span>              :          * This interface shares its address and Beacon frame with the main</span>
<span id="L1786"><span class="lineNum">    1786</span>              :          * BSS.</span>
<span id="L1787"><span class="lineNum">    1787</span>              :          */</span>
<span id="L1788"><span class="lineNum">    1788</span>              :         WPA_IF_AP_VLAN,</span>
<span id="L1789"><span class="lineNum">    1789</span>              : </span>
<span id="L1790"><span class="lineNum">    1790</span>              :         /**</span>
<span id="L1791"><span class="lineNum">    1791</span>              :          * WPA_IF_AP_BSS - AP mode BSS interface</span>
<span id="L1792"><span class="lineNum">    1792</span>              :          *</span>
<span id="L1793"><span class="lineNum">    1793</span>              :          * This interface has its own address and Beacon frame.</span>
<span id="L1794"><span class="lineNum">    1794</span>              :          */</span>
<span id="L1795"><span class="lineNum">    1795</span>              :         WPA_IF_AP_BSS,</span>
<span id="L1796"><span class="lineNum">    1796</span>              : </span>
<span id="L1797"><span class="lineNum">    1797</span>              :         /**</span>
<span id="L1798"><span class="lineNum">    1798</span>              :          * WPA_IF_P2P_GO - P2P Group Owner</span>
<span id="L1799"><span class="lineNum">    1799</span>              :          */</span>
<span id="L1800"><span class="lineNum">    1800</span>              :         WPA_IF_P2P_GO,</span>
<span id="L1801"><span class="lineNum">    1801</span>              : </span>
<span id="L1802"><span class="lineNum">    1802</span>              :         /**</span>
<span id="L1803"><span class="lineNum">    1803</span>              :          * WPA_IF_P2P_CLIENT - P2P Client</span>
<span id="L1804"><span class="lineNum">    1804</span>              :          */</span>
<span id="L1805"><span class="lineNum">    1805</span>              :         WPA_IF_P2P_CLIENT,</span>
<span id="L1806"><span class="lineNum">    1806</span>              : </span>
<span id="L1807"><span class="lineNum">    1807</span>              :         /**</span>
<span id="L1808"><span class="lineNum">    1808</span>              :          * WPA_IF_P2P_GROUP - P2P Group interface (will become either</span>
<span id="L1809"><span class="lineNum">    1809</span>              :          * WPA_IF_P2P_GO or WPA_IF_P2P_CLIENT, but the role is not yet known)</span>
<span id="L1810"><span class="lineNum">    1810</span>              :          */</span>
<span id="L1811"><span class="lineNum">    1811</span>              :         WPA_IF_P2P_GROUP,</span>
<span id="L1812"><span class="lineNum">    1812</span>              : </span>
<span id="L1813"><span class="lineNum">    1813</span>              :         /**</span>
<span id="L1814"><span class="lineNum">    1814</span>              :          * WPA_IF_P2P_DEVICE - P2P Device interface is used to identify the</span>
<span id="L1815"><span class="lineNum">    1815</span>              :          * abstracted P2P Device function in the driver</span>
<span id="L1816"><span class="lineNum">    1816</span>              :          */</span>
<span id="L1817"><span class="lineNum">    1817</span>              :         WPA_IF_P2P_DEVICE,</span>
<span id="L1818"><span class="lineNum">    1818</span>              : </span>
<span id="L1819"><span class="lineNum">    1819</span>              :         /*</span>
<span id="L1820"><span class="lineNum">    1820</span>              :          * WPA_IF_MESH - Mesh interface</span>
<span id="L1821"><span class="lineNum">    1821</span>              :          */</span>
<span id="L1822"><span class="lineNum">    1822</span>              :         WPA_IF_MESH,</span>
<span id="L1823"><span class="lineNum">    1823</span>              : </span>
<span id="L1824"><span class="lineNum">    1824</span>              :         /*</span>
<span id="L1825"><span class="lineNum">    1825</span>              :          * WPA_IF_TDLS - TDLS offchannel interface (used for pref freq only)</span>
<span id="L1826"><span class="lineNum">    1826</span>              :          */</span>
<span id="L1827"><span class="lineNum">    1827</span>              :         WPA_IF_TDLS,</span>
<span id="L1828"><span class="lineNum">    1828</span>              : </span>
<span id="L1829"><span class="lineNum">    1829</span>              :         /*</span>
<span id="L1830"><span class="lineNum">    1830</span>              :          * WPA_IF_IBSS - IBSS interface (used for pref freq only)</span>
<span id="L1831"><span class="lineNum">    1831</span>              :          */</span>
<span id="L1832"><span class="lineNum">    1832</span>              :         WPA_IF_IBSS,</span>
<span id="L1833"><span class="lineNum">    1833</span>              : </span>
<span id="L1834"><span class="lineNum">    1834</span>              :         /*</span>
<span id="L1835"><span class="lineNum">    1835</span>              :          * WPA_IF_NAN - NAN Device</span>
<span id="L1836"><span class="lineNum">    1836</span>              :          */</span>
<span id="L1837"><span class="lineNum">    1837</span>              :         WPA_IF_NAN,</span>
<span id="L1838"><span class="lineNum">    1838</span>              : </span>
<span id="L1839"><span class="lineNum">    1839</span>              :         /* keep last */</span>
<span id="L1840"><span class="lineNum">    1840</span>              :         WPA_IF_MAX</span>
<span id="L1841"><span class="lineNum">    1841</span>              : };</span>
<span id="L1842"><span class="lineNum">    1842</span>              : </span>
<span id="L1843"><span class="lineNum">    1843</span>              : /**</span>
<span id="L1844"><span class="lineNum">    1844</span>              :  * struct wpa_driver_capa - Driver capability information</span>
<span id="L1845"><span class="lineNum">    1845</span>              :  */</span>
<span id="L1846"><span class="lineNum">    1846</span>              : struct wpa_driver_capa {</span>
<span id="L1847"><span class="lineNum">    1847</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_WPA            0x00000001</span>
<span id="L1848"><span class="lineNum">    1848</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_WPA2           0x00000002</span>
<span id="L1849"><span class="lineNum">    1849</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK        0x00000004</span>
<span id="L1850"><span class="lineNum">    1850</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK       0x00000008</span>
<span id="L1851"><span class="lineNum">    1851</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_WPA_NONE       0x00000010</span>
<span id="L1852"><span class="lineNum">    1852</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_FT             0x00000020</span>
<span id="L1853"><span class="lineNum">    1853</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_FT_PSK         0x00000040</span>
<span id="L1854"><span class="lineNum">    1854</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_WAPI_PSK       0x00000080</span>
<span id="L1855"><span class="lineNum">    1855</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_SUITE_B        0x00000100</span>
<span id="L1856"><span class="lineNum">    1856</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_SUITE_B_192    0x00000200</span>
<span id="L1857"><span class="lineNum">    1857</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_OWE            0x00000400</span>
<span id="L1858"><span class="lineNum">    1858</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_DPP            0x00000800</span>
<span id="L1859"><span class="lineNum">    1859</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_FILS_SHA256    0x00001000</span>
<span id="L1860"><span class="lineNum">    1860</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_FILS_SHA384    0x00002000</span>
<span id="L1861"><span class="lineNum">    1861</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_FT_FILS_SHA256 0x00004000</span>
<span id="L1862"><span class="lineNum">    1862</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_FT_FILS_SHA384 0x00008000</span>
<span id="L1863"><span class="lineNum">    1863</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_SAE            0x00010000</span>
<span id="L1864"><span class="lineNum">    1864</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_802_1X_SHA256  0x00020000</span>
<span id="L1865"><span class="lineNum">    1865</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_PSK_SHA256     0x00040000</span>
<span id="L1866"><span class="lineNum">    1866</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_TPK_HANDSHAKE  0x00080000</span>
<span id="L1867"><span class="lineNum">    1867</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_FT_SAE         0x00100000</span>
<span id="L1868"><span class="lineNum">    1868</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_FT_802_1X_SHA384       0x00200000</span>
<span id="L1869"><span class="lineNum">    1869</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_CCKM           0x00400000</span>
<span id="L1870"><span class="lineNum">    1870</span>              : #define WPA_DRIVER_CAPA_KEY_MGMT_OSEN           0x00800000</span>
<span id="L1871"><span class="lineNum">    1871</span>              :         /** Bitfield of supported key management suites */</span>
<span id="L1872"><span class="lineNum">    1872</span>              :         unsigned int key_mgmt;</span>
<span id="L1873"><span class="lineNum">    1873</span>              :         unsigned int key_mgmt_iftype[WPA_IF_MAX];</span>
<span id="L1874"><span class="lineNum">    1874</span>              : </span>
<span id="L1875"><span class="lineNum">    1875</span>              : #define WPA_DRIVER_CAPA_ENC_WEP40       0x00000001</span>
<span id="L1876"><span class="lineNum">    1876</span>              : #define WPA_DRIVER_CAPA_ENC_WEP104      0x00000002</span>
<span id="L1877"><span class="lineNum">    1877</span>              : #define WPA_DRIVER_CAPA_ENC_TKIP        0x00000004</span>
<span id="L1878"><span class="lineNum">    1878</span>              : #define WPA_DRIVER_CAPA_ENC_CCMP        0x00000008</span>
<span id="L1879"><span class="lineNum">    1879</span>              : #define WPA_DRIVER_CAPA_ENC_WEP128      0x00000010</span>
<span id="L1880"><span class="lineNum">    1880</span>              : #define WPA_DRIVER_CAPA_ENC_GCMP        0x00000020</span>
<span id="L1881"><span class="lineNum">    1881</span>              : #define WPA_DRIVER_CAPA_ENC_GCMP_256    0x00000040</span>
<span id="L1882"><span class="lineNum">    1882</span>              : #define WPA_DRIVER_CAPA_ENC_CCMP_256    0x00000080</span>
<span id="L1883"><span class="lineNum">    1883</span>              : #define WPA_DRIVER_CAPA_ENC_BIP         0x00000100</span>
<span id="L1884"><span class="lineNum">    1884</span>              : #define WPA_DRIVER_CAPA_ENC_BIP_GMAC_128        0x00000200</span>
<span id="L1885"><span class="lineNum">    1885</span>              : #define WPA_DRIVER_CAPA_ENC_BIP_GMAC_256        0x00000400</span>
<span id="L1886"><span class="lineNum">    1886</span>              : #define WPA_DRIVER_CAPA_ENC_BIP_CMAC_256        0x00000800</span>
<span id="L1887"><span class="lineNum">    1887</span>              : #define WPA_DRIVER_CAPA_ENC_GTK_NOT_USED        0x00001000</span>
<span id="L1888"><span class="lineNum">    1888</span>              :         /** Bitfield of supported cipher suites */</span>
<span id="L1889"><span class="lineNum">    1889</span>              :         unsigned int enc;</span>
<span id="L1890"><span class="lineNum">    1890</span>              : </span>
<span id="L1891"><span class="lineNum">    1891</span>              : #define WPA_DRIVER_AUTH_OPEN            0x00000001</span>
<span id="L1892"><span class="lineNum">    1892</span>              : #define WPA_DRIVER_AUTH_SHARED          0x00000002</span>
<span id="L1893"><span class="lineNum">    1893</span>              : #define WPA_DRIVER_AUTH_LEAP            0x00000004</span>
<span id="L1894"><span class="lineNum">    1894</span>              :         /** Bitfield of supported IEEE 802.11 authentication algorithms */</span>
<span id="L1895"><span class="lineNum">    1895</span>              :         unsigned int auth;</span>
<span id="L1896"><span class="lineNum">    1896</span>              : </span>
<span id="L1897"><span class="lineNum">    1897</span>              : /** Driver generated WPA/RSN IE */</span>
<span id="L1898"><span class="lineNum">    1898</span>              : #define WPA_DRIVER_FLAGS_DRIVER_IE      0x00000001</span>
<span id="L1899"><span class="lineNum">    1899</span>              : /** Driver needs static WEP key setup after association command */</span>
<span id="L1900"><span class="lineNum">    1900</span>              : #define WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC 0x00000002</span>
<span id="L1901"><span class="lineNum">    1901</span>              : /** Driver takes care of all DFS operations */</span>
<span id="L1902"><span class="lineNum">    1902</span>              : #define WPA_DRIVER_FLAGS_DFS_OFFLOAD                    0x00000004</span>
<span id="L1903"><span class="lineNum">    1903</span>              : /** Driver takes care of RSN 4-way handshake internally; PMK is configured with</span>
<span id="L1904"><span class="lineNum">    1904</span>              :  * struct wpa_driver_ops::set_key using key_flag = KEY_FLAG_PMK */</span>
<span id="L1905"><span class="lineNum">    1905</span>              : #define WPA_DRIVER_FLAGS_4WAY_HANDSHAKE_8021X           0x00000008</span>
<span id="L1906"><span class="lineNum">    1906</span>              : /** Driver is for a wired Ethernet interface */</span>
<span id="L1907"><span class="lineNum">    1907</span>              : #define WPA_DRIVER_FLAGS_WIRED          0x00000010</span>
<span id="L1908"><span class="lineNum">    1908</span>              : /** Driver provides separate commands for authentication and association (SME in</span>
<span id="L1909"><span class="lineNum">    1909</span>              :  * wpa_supplicant). */</span>
<span id="L1910"><span class="lineNum">    1910</span>              : #define WPA_DRIVER_FLAGS_SME            0x00000020</span>
<span id="L1911"><span class="lineNum">    1911</span>              : /** Driver supports AP mode */</span>
<span id="L1912"><span class="lineNum">    1912</span>              : #define WPA_DRIVER_FLAGS_AP             0x00000040</span>
<span id="L1913"><span class="lineNum">    1913</span>              : /** Driver needs static WEP key setup after association has been completed */</span>
<span id="L1914"><span class="lineNum">    1914</span>              : #define WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC_DONE      0x00000080</span>
<span id="L1915"><span class="lineNum">    1915</span>              : /** Driver supports dynamic HT 20/40 MHz channel changes during BSS lifetime */</span>
<span id="L1916"><span class="lineNum">    1916</span>              : #define WPA_DRIVER_FLAGS_HT_2040_COEX                   0x00000100</span>
<span id="L1917"><span class="lineNum">    1917</span>              : /** Driver supports concurrent P2P operations */</span>
<span id="L1918"><span class="lineNum">    1918</span>              : #define WPA_DRIVER_FLAGS_P2P_CONCURRENT 0x00000200</span>
<span id="L1919"><span class="lineNum">    1919</span>              : /**</span>
<span id="L1920"><span class="lineNum">    1920</span>              :  * Driver uses the initial interface as a dedicated management interface, i.e.,</span>
<span id="L1921"><span class="lineNum">    1921</span>              :  * it cannot be used for P2P group operations or non-P2P purposes.</span>
<span id="L1922"><span class="lineNum">    1922</span>              :  */</span>
<span id="L1923"><span class="lineNum">    1923</span>              : #define WPA_DRIVER_FLAGS_P2P_DEDICATED_INTERFACE        0x00000400</span>
<span id="L1924"><span class="lineNum">    1924</span>              : /** This interface is P2P capable (P2P GO or P2P Client) */</span>
<span id="L1925"><span class="lineNum">    1925</span>              : #define WPA_DRIVER_FLAGS_P2P_CAPABLE    0x00000800</span>
<span id="L1926"><span class="lineNum">    1926</span>              : /** Driver supports station and key removal when stopping an AP */</span>
<span id="L1927"><span class="lineNum">    1927</span>              : #define WPA_DRIVER_FLAGS_AP_TEARDOWN_SUPPORT            0x00001000</span>
<span id="L1928"><span class="lineNum">    1928</span>              : /**</span>
<span id="L1929"><span class="lineNum">    1929</span>              :  * Driver uses the initial interface for P2P management interface and non-P2P</span>
<span id="L1930"><span class="lineNum">    1930</span>              :  * purposes (e.g., connect to infra AP), but this interface cannot be used for</span>
<span id="L1931"><span class="lineNum">    1931</span>              :  * P2P group operations.</span>
<span id="L1932"><span class="lineNum">    1932</span>              :  */</span>
<span id="L1933"><span class="lineNum">    1933</span>              : #define WPA_DRIVER_FLAGS_P2P_MGMT_AND_NON_P2P           0x00002000</span>
<span id="L1934"><span class="lineNum">    1934</span>              : /**</span>
<span id="L1935"><span class="lineNum">    1935</span>              :  * Driver is known to use valid error codes, i.e., when it indicates that</span>
<span id="L1936"><span class="lineNum">    1936</span>              :  * something (e.g., association) fails, there was indeed a failure and the</span>
<span id="L1937"><span class="lineNum">    1937</span>              :  * operation does not end up getting completed successfully later.</span>
<span id="L1938"><span class="lineNum">    1938</span>              :  */</span>
<span id="L1939"><span class="lineNum">    1939</span>              : #define WPA_DRIVER_FLAGS_VALID_ERROR_CODES              0x00004000</span>
<span id="L1940"><span class="lineNum">    1940</span>              : /** Driver supports off-channel TX */</span>
<span id="L1941"><span class="lineNum">    1941</span>              : #define WPA_DRIVER_FLAGS_OFFCHANNEL_TX                  0x00008000</span>
<span id="L1942"><span class="lineNum">    1942</span>              : /** Driver indicates TX status events for EAPOL Data frames */</span>
<span id="L1943"><span class="lineNum">    1943</span>              : #define WPA_DRIVER_FLAGS_EAPOL_TX_STATUS                0x00010000</span>
<span id="L1944"><span class="lineNum">    1944</span>              : /** Driver indicates TX status events for Deauth/Disassoc frames */</span>
<span id="L1945"><span class="lineNum">    1945</span>              : #define WPA_DRIVER_FLAGS_DEAUTH_TX_STATUS               0x00020000</span>
<span id="L1946"><span class="lineNum">    1946</span>              : /** Driver supports roaming (BSS selection) in firmware */</span>
<span id="L1947"><span class="lineNum">    1947</span>              : #define WPA_DRIVER_FLAGS_BSS_SELECTION                  0x00040000</span>
<span id="L1948"><span class="lineNum">    1948</span>              : /** Driver supports operating as a TDLS peer */</span>
<span id="L1949"><span class="lineNum">    1949</span>              : #define WPA_DRIVER_FLAGS_TDLS_SUPPORT                   0x00080000</span>
<span id="L1950"><span class="lineNum">    1950</span>              : /** Driver requires external TDLS setup/teardown/discovery */</span>
<span id="L1951"><span class="lineNum">    1951</span>              : #define WPA_DRIVER_FLAGS_TDLS_EXTERNAL_SETUP            0x00100000</span>
<span id="L1952"><span class="lineNum">    1952</span>              : /** Driver indicates support for Probe Response offloading in AP mode */</span>
<span id="L1953"><span class="lineNum">    1953</span>              : #define WPA_DRIVER_FLAGS_PROBE_RESP_OFFLOAD             0x00200000</span>
<span id="L1954"><span class="lineNum">    1954</span>              : /** Driver supports U-APSD in AP mode */</span>
<span id="L1955"><span class="lineNum">    1955</span>              : #define WPA_DRIVER_FLAGS_AP_UAPSD                       0x00400000</span>
<span id="L1956"><span class="lineNum">    1956</span>              : /** Driver supports inactivity timer in AP mode */</span>
<span id="L1957"><span class="lineNum">    1957</span>              : #define WPA_DRIVER_FLAGS_INACTIVITY_TIMER               0x00800000</span>
<span id="L1958"><span class="lineNum">    1958</span>              : /** Driver expects user space implementation of MLME in AP mode */</span>
<span id="L1959"><span class="lineNum">    1959</span>              : #define WPA_DRIVER_FLAGS_AP_MLME                        0x01000000</span>
<span id="L1960"><span class="lineNum">    1960</span>              : /** Driver supports SAE with user space SME */</span>
<span id="L1961"><span class="lineNum">    1961</span>              : #define WPA_DRIVER_FLAGS_SAE                            0x02000000</span>
<span id="L1962"><span class="lineNum">    1962</span>              : /** Driver makes use of OBSS scan mechanism in wpa_supplicant */</span>
<span id="L1963"><span class="lineNum">    1963</span>              : #define WPA_DRIVER_FLAGS_OBSS_SCAN                      0x04000000</span>
<span id="L1964"><span class="lineNum">    1964</span>              : /** Driver supports IBSS (Ad-hoc) mode */</span>
<span id="L1965"><span class="lineNum">    1965</span>              : #define WPA_DRIVER_FLAGS_IBSS                           0x08000000</span>
<span id="L1966"><span class="lineNum">    1966</span>              : /** Driver supports radar detection */</span>
<span id="L1967"><span class="lineNum">    1967</span>              : #define WPA_DRIVER_FLAGS_RADAR                          0x10000000</span>
<span id="L1968"><span class="lineNum">    1968</span>              : /** Driver supports a dedicated interface for P2P Device */</span>
<span id="L1969"><span class="lineNum">    1969</span>              : #define WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE           0x20000000</span>
<span id="L1970"><span class="lineNum">    1970</span>              : /** Driver supports QoS Mapping */</span>
<span id="L1971"><span class="lineNum">    1971</span>              : #define WPA_DRIVER_FLAGS_QOS_MAPPING                    0x40000000</span>
<span id="L1972"><span class="lineNum">    1972</span>              : /** Driver supports CSA in AP mode */</span>
<span id="L1973"><span class="lineNum">    1973</span>              : #define WPA_DRIVER_FLAGS_AP_CSA                         0x80000000</span>
<span id="L1974"><span class="lineNum">    1974</span>              : /** Driver supports mesh */</span>
<span id="L1975"><span class="lineNum">    1975</span>              : #define WPA_DRIVER_FLAGS_MESH                   0x0000000100000000ULL</span>
<span id="L1976"><span class="lineNum">    1976</span>              : /** Driver support ACS offload */</span>
<span id="L1977"><span class="lineNum">    1977</span>              : #define WPA_DRIVER_FLAGS_ACS_OFFLOAD            0x0000000200000000ULL</span>
<span id="L1978"><span class="lineNum">    1978</span>              : /** Driver supports key management offload */</span>
<span id="L1979"><span class="lineNum">    1979</span>              : #define WPA_DRIVER_FLAGS_KEY_MGMT_OFFLOAD       0x0000000400000000ULL</span>
<span id="L1980"><span class="lineNum">    1980</span>              : /** Driver supports TDLS channel switching */</span>
<span id="L1981"><span class="lineNum">    1981</span>              : #define WPA_DRIVER_FLAGS_TDLS_CHANNEL_SWITCH    0x0000000800000000ULL</span>
<span id="L1982"><span class="lineNum">    1982</span>              : /** Driver supports IBSS with HT datarates */</span>
<span id="L1983"><span class="lineNum">    1983</span>              : #define WPA_DRIVER_FLAGS_HT_IBSS                0x0000001000000000ULL</span>
<span id="L1984"><span class="lineNum">    1984</span>              : /** Driver supports IBSS with VHT datarates */</span>
<span id="L1985"><span class="lineNum">    1985</span>              : #define WPA_DRIVER_FLAGS_VHT_IBSS               0x0000002000000000ULL</span>
<span id="L1986"><span class="lineNum">    1986</span>              : /** Driver supports automatic band selection */</span>
<span id="L1987"><span class="lineNum">    1987</span>              : #define WPA_DRIVER_FLAGS_SUPPORT_HW_MODE_ANY    0x0000004000000000ULL</span>
<span id="L1988"><span class="lineNum">    1988</span>              : /** Driver supports simultaneous off-channel operations */</span>
<span id="L1989"><span class="lineNum">    1989</span>              : #define WPA_DRIVER_FLAGS_OFFCHANNEL_SIMULTANEOUS        0x0000008000000000ULL</span>
<span id="L1990"><span class="lineNum">    1990</span>              : /** Driver supports full AP client state */</span>
<span id="L1991"><span class="lineNum">    1991</span>              : #define WPA_DRIVER_FLAGS_FULL_AP_CLIENT_STATE   0x0000010000000000ULL</span>
<span id="L1992"><span class="lineNum">    1992</span>              : /** Driver supports P2P Listen offload */</span>
<span id="L1993"><span class="lineNum">    1993</span>              : #define WPA_DRIVER_FLAGS_P2P_LISTEN_OFFLOAD     0x0000020000000000ULL</span>
<span id="L1994"><span class="lineNum">    1994</span>              : /** Driver supports FILS */</span>
<span id="L1995"><span class="lineNum">    1995</span>              : #define WPA_DRIVER_FLAGS_SUPPORT_FILS           0x0000040000000000ULL</span>
<span id="L1996"><span class="lineNum">    1996</span>              : /** Driver supports Beacon frame TX rate configuration (legacy rates) */</span>
<span id="L1997"><span class="lineNum">    1997</span>              : #define WPA_DRIVER_FLAGS_BEACON_RATE_LEGACY     0x0000080000000000ULL</span>
<span id="L1998"><span class="lineNum">    1998</span>              : /** Driver supports Beacon frame TX rate configuration (HT rates) */</span>
<span id="L1999"><span class="lineNum">    1999</span>              : #define WPA_DRIVER_FLAGS_BEACON_RATE_HT         0x0000100000000000ULL</span>
<span id="L2000"><span class="lineNum">    2000</span>              : /** Driver supports Beacon frame TX rate configuration (VHT rates) */</span>
<span id="L2001"><span class="lineNum">    2001</span>              : #define WPA_DRIVER_FLAGS_BEACON_RATE_VHT        0x0000200000000000ULL</span>
<span id="L2002"><span class="lineNum">    2002</span>              : /** Driver supports mgmt_tx with random TX address in non-connected state */</span>
<span id="L2003"><span class="lineNum">    2003</span>              : #define WPA_DRIVER_FLAGS_MGMT_TX_RANDOM_TA      0x0000400000000000ULL</span>
<span id="L2004"><span class="lineNum">    2004</span>              : /** Driver supports mgmt_tx with random TX addr in connected state */</span>
<span id="L2005"><span class="lineNum">    2005</span>              : #define WPA_DRIVER_FLAGS_MGMT_TX_RANDOM_TA_CONNECTED    0x0000800000000000ULL</span>
<span id="L2006"><span class="lineNum">    2006</span>              : /** Driver supports better BSS reporting with sched_scan in connected mode */</span>
<span id="L2007"><span class="lineNum">    2007</span>              : #define WPA_DRIVER_FLAGS_SCHED_SCAN_RELATIVE_RSSI       0x0001000000000000ULL</span>
<span id="L2008"><span class="lineNum">    2008</span>              : /** Driver supports HE capabilities */</span>
<span id="L2009"><span class="lineNum">    2009</span>              : #define WPA_DRIVER_FLAGS_HE_CAPABILITIES        0x0002000000000000ULL</span>
<span id="L2010"><span class="lineNum">    2010</span>              : /** Driver supports FILS shared key offload */</span>
<span id="L2011"><span class="lineNum">    2011</span>              : #define WPA_DRIVER_FLAGS_FILS_SK_OFFLOAD        0x0004000000000000ULL</span>
<span id="L2012"><span class="lineNum">    2012</span>              : /** Driver supports all OCE STA specific mandatory features */</span>
<span id="L2013"><span class="lineNum">    2013</span>              : #define WPA_DRIVER_FLAGS_OCE_STA                0x0008000000000000ULL</span>
<span id="L2014"><span class="lineNum">    2014</span>              : /** Driver supports all OCE AP specific mandatory features */</span>
<span id="L2015"><span class="lineNum">    2015</span>              : #define WPA_DRIVER_FLAGS_OCE_AP                 0x0010000000000000ULL</span>
<span id="L2016"><span class="lineNum">    2016</span>              : /**</span>
<span id="L2017"><span class="lineNum">    2017</span>              :  * Driver supports all OCE STA-CFON specific mandatory features only.</span>
<span id="L2018"><span class="lineNum">    2018</span>              :  * If a driver sets this bit but not the %WPA_DRIVER_FLAGS_OCE_AP, the</span>
<span id="L2019"><span class="lineNum">    2019</span>              :  * userspace shall assume that this driver may not support all OCE AP</span>
<span id="L2020"><span class="lineNum">    2020</span>              :  * functionality but can support only OCE STA-CFON functionality.</span>
<span id="L2021"><span class="lineNum">    2021</span>              :  */</span>
<span id="L2022"><span class="lineNum">    2022</span>              : #define WPA_DRIVER_FLAGS_OCE_STA_CFON           0x0020000000000000ULL</span>
<span id="L2023"><span class="lineNum">    2023</span>              : /** Driver supports MFP-optional in the connect command */</span>
<span id="L2024"><span class="lineNum">    2024</span>              : #define WPA_DRIVER_FLAGS_MFP_OPTIONAL           0x0040000000000000ULL</span>
<span id="L2025"><span class="lineNum">    2025</span>              : /** Driver is a self-managed regulatory device */</span>
<span id="L2026"><span class="lineNum">    2026</span>              : #define WPA_DRIVER_FLAGS_SELF_MANAGED_REGULATORY       0x0080000000000000ULL</span>
<span id="L2027"><span class="lineNum">    2027</span>              : /** Driver supports FTM responder functionality */</span>
<span id="L2028"><span class="lineNum">    2028</span>              : #define WPA_DRIVER_FLAGS_FTM_RESPONDER          0x0100000000000000ULL</span>
<span id="L2029"><span class="lineNum">    2029</span>              : /** Driver support 4-way handshake offload for WPA-Personal */</span>
<span id="L2030"><span class="lineNum">    2030</span>              : #define WPA_DRIVER_FLAGS_4WAY_HANDSHAKE_PSK     0x0200000000000000ULL</span>
<span id="L2031"><span class="lineNum">    2031</span>              : /** Driver supports a separate control port TX for EAPOL frames */</span>
<span id="L2032"><span class="lineNum">    2032</span>              : #define WPA_DRIVER_FLAGS_CONTROL_PORT           0x0400000000000000ULL</span>
<span id="L2033"><span class="lineNum">    2033</span>              : /** Driver supports VLAN offload */</span>
<span id="L2034"><span class="lineNum">    2034</span>              : #define WPA_DRIVER_FLAGS_VLAN_OFFLOAD           0x0800000000000000ULL</span>
<span id="L2035"><span class="lineNum">    2035</span>              : /** Driver supports UPDATE_FT_IES command */</span>
<span id="L2036"><span class="lineNum">    2036</span>              : #define WPA_DRIVER_FLAGS_UPDATE_FT_IES          0x1000000000000000ULL</span>
<span id="L2037"><span class="lineNum">    2037</span>              : /** Driver can correctly rekey PTKs without Extended Key ID */</span>
<span id="L2038"><span class="lineNum">    2038</span>              : #define WPA_DRIVER_FLAGS_SAFE_PTK0_REKEYS       0x2000000000000000ULL</span>
<span id="L2039"><span class="lineNum">    2039</span>              : /** Driver supports Beacon protection */</span>
<span id="L2040"><span class="lineNum">    2040</span>              : #define WPA_DRIVER_FLAGS_BEACON_PROTECTION      0x4000000000000000ULL</span>
<span id="L2041"><span class="lineNum">    2041</span>              : /** Driver supports Extended Key ID */</span>
<span id="L2042"><span class="lineNum">    2042</span>              : #define WPA_DRIVER_FLAGS_EXTENDED_KEY_ID        0x8000000000000000ULL</span>
<span id="L2043"><span class="lineNum">    2043</span>              :         u64 flags;</span>
<span id="L2044"><span class="lineNum">    2044</span>              : </span>
<span id="L2045"><span class="lineNum">    2045</span>              : /** Driver supports a separate control port RX for EAPOL frames */</span>
<span id="L2046"><span class="lineNum">    2046</span>              : #define WPA_DRIVER_FLAGS2_CONTROL_PORT_RX       0x0000000000000001ULL</span>
<span id="L2047"><span class="lineNum">    2047</span>              : /** Driver supports TX status reports for EAPOL frames through control port */</span>
<span id="L2048"><span class="lineNum">    2048</span>              : #define WPA_DRIVER_FLAGS2_CONTROL_PORT_TX_STATUS 0x0000000000000002ULL</span>
<span id="L2049"><span class="lineNum">    2049</span>              : /** Driver supports secure LTF */</span>
<span id="L2050"><span class="lineNum">    2050</span>              : #define WPA_DRIVER_FLAGS2_SEC_LTF               0x0000000000000004ULL</span>
<span id="L2051"><span class="lineNum">    2051</span>              : /** Driver supports secure RTT measurement exchange */</span>
<span id="L2052"><span class="lineNum">    2052</span>              : #define WPA_DRIVER_FLAGS2_SEC_RTT               0x0000000000000008ULL</span>
<span id="L2053"><span class="lineNum">    2053</span>              : /**</span>
<span id="L2054"><span class="lineNum">    2054</span>              :  * Driver supports protection of range negotiation and measurement management</span>
<span id="L2055"><span class="lineNum">    2055</span>              :  * frames</span>
<span id="L2056"><span class="lineNum">    2056</span>              :  */</span>
<span id="L2057"><span class="lineNum">    2057</span>              : #define WPA_DRIVER_FLAGS2_PROT_RANGE_NEG        0x0000000000000010ULL</span>
<span id="L2058"><span class="lineNum">    2058</span>              : /** Driver supports Beacon frame TX rate configuration (HE rates) */</span>
<span id="L2059"><span class="lineNum">    2059</span>              : #define WPA_DRIVER_FLAGS2_BEACON_RATE_HE        0x0000000000000020ULL</span>
<span id="L2060"><span class="lineNum">    2060</span>              : /** Driver supports Beacon protection only in client mode */</span>
<span id="L2061"><span class="lineNum">    2061</span>              : #define WPA_DRIVER_FLAGS2_BEACON_PROTECTION_CLIENT 0x0000000000000040ULL</span>
<span id="L2062"><span class="lineNum">    2062</span>              : /** Driver supports Operating Channel Validation */</span>
<span id="L2063"><span class="lineNum">    2063</span>              : #define WPA_DRIVER_FLAGS2_OCV                   0x0000000000000080ULL</span>
<span id="L2064"><span class="lineNum">    2064</span>              : /** Driver expects user space implementation of SME in AP mode */</span>
<span id="L2065"><span class="lineNum">    2065</span>              : #define WPA_DRIVER_FLAGS2_AP_SME                0x0000000000000100ULL</span>
<span id="L2066"><span class="lineNum">    2066</span>              : /** Driver handles SA Query procedures in AP mode */</span>
<span id="L2067"><span class="lineNum">    2067</span>              : #define WPA_DRIVER_FLAGS2_SA_QUERY_OFFLOAD_AP   0x0000000000000200ULL</span>
<span id="L2068"><span class="lineNum">    2068</span>              : /** Driver supports background radar/CAC detection */</span>
<span id="L2069"><span class="lineNum">    2069</span>              : #define WPA_DRIVER_RADAR_BACKGROUND             0x0000000000000400ULL</span>
<span id="L2070"><span class="lineNum">    2070</span>              :         u64 flags2;</span>
<span id="L2071"><span class="lineNum">    2071</span>              : </span>
<span id="L2072"><span class="lineNum">    2072</span>              : #define FULL_AP_CLIENT_STATE_SUPP(drv_flags) \</span>
<span id="L2073"><span class="lineNum">    2073</span>              :         (drv_flags &amp; WPA_DRIVER_FLAGS_FULL_AP_CLIENT_STATE)</span>
<span id="L2074"><span class="lineNum">    2074</span>              : </span>
<span id="L2075"><span class="lineNum">    2075</span>              :         unsigned int wmm_ac_supported:1;</span>
<span id="L2076"><span class="lineNum">    2076</span>              : </span>
<span id="L2077"><span class="lineNum">    2077</span>              :         unsigned int mac_addr_rand_scan_supported:1;</span>
<span id="L2078"><span class="lineNum">    2078</span>              :         unsigned int mac_addr_rand_sched_scan_supported:1;</span>
<span id="L2079"><span class="lineNum">    2079</span>              : </span>
<span id="L2080"><span class="lineNum">    2080</span>              :         /** Maximum number of supported active probe SSIDs */</span>
<span id="L2081"><span class="lineNum">    2081</span>              :         int max_scan_ssids;</span>
<span id="L2082"><span class="lineNum">    2082</span>              : </span>
<span id="L2083"><span class="lineNum">    2083</span>              :         /** Maximum number of supported active probe SSIDs for sched_scan */</span>
<span id="L2084"><span class="lineNum">    2084</span>              :         int max_sched_scan_ssids;</span>
<span id="L2085"><span class="lineNum">    2085</span>              : </span>
<span id="L2086"><span class="lineNum">    2086</span>              :         /** Maximum number of supported scan plans for scheduled scan */</span>
<span id="L2087"><span class="lineNum">    2087</span>              :         unsigned int max_sched_scan_plans;</span>
<span id="L2088"><span class="lineNum">    2088</span>              : </span>
<span id="L2089"><span class="lineNum">    2089</span>              :         /** Maximum interval in a scan plan. In seconds */</span>
<span id="L2090"><span class="lineNum">    2090</span>              :         u32 max_sched_scan_plan_interval;</span>
<span id="L2091"><span class="lineNum">    2091</span>              : </span>
<span id="L2092"><span class="lineNum">    2092</span>              :         /** Maximum number of iterations in a single scan plan */</span>
<span id="L2093"><span class="lineNum">    2093</span>              :         u32 max_sched_scan_plan_iterations;</span>
<span id="L2094"><span class="lineNum">    2094</span>              : </span>
<span id="L2095"><span class="lineNum">    2095</span>              :         /** Whether sched_scan (offloaded scanning) is supported */</span>
<span id="L2096"><span class="lineNum">    2096</span>              :         int sched_scan_supported;</span>
<span id="L2097"><span class="lineNum">    2097</span>              : </span>
<span id="L2098"><span class="lineNum">    2098</span>              :         /** Maximum number of supported match sets for sched_scan */</span>
<span id="L2099"><span class="lineNum">    2099</span>              :         int max_match_sets;</span>
<span id="L2100"><span class="lineNum">    2100</span>              : </span>
<span id="L2101"><span class="lineNum">    2101</span>              :         /**</span>
<span id="L2102"><span class="lineNum">    2102</span>              :          * max_remain_on_chan - Maximum remain-on-channel duration in msec</span>
<span id="L2103"><span class="lineNum">    2103</span>              :          */</span>
<span id="L2104"><span class="lineNum">    2104</span>              :         unsigned int max_remain_on_chan;</span>
<span id="L2105"><span class="lineNum">    2105</span>              : </span>
<span id="L2106"><span class="lineNum">    2106</span>              :         /**</span>
<span id="L2107"><span class="lineNum">    2107</span>              :          * max_stations - Maximum number of associated stations the driver</span>
<span id="L2108"><span class="lineNum">    2108</span>              :          * supports in AP mode</span>
<span id="L2109"><span class="lineNum">    2109</span>              :          */</span>
<span id="L2110"><span class="lineNum">    2110</span>              :         unsigned int max_stations;</span>
<span id="L2111"><span class="lineNum">    2111</span>              : </span>
<span id="L2112"><span class="lineNum">    2112</span>              :         /**</span>
<span id="L2113"><span class="lineNum">    2113</span>              :          * probe_resp_offloads - Bitmap of supported protocols by the driver</span>
<span id="L2114"><span class="lineNum">    2114</span>              :          * for Probe Response offloading.</span>
<span id="L2115"><span class="lineNum">    2115</span>              :          */</span>
<span id="L2116"><span class="lineNum">    2116</span>              : /** Driver Probe Response offloading support for WPS ver. 1 */</span>
<span id="L2117"><span class="lineNum">    2117</span>              : #define WPA_DRIVER_PROBE_RESP_OFFLOAD_WPS               0x00000001</span>
<span id="L2118"><span class="lineNum">    2118</span>              : /** Driver Probe Response offloading support for WPS ver. 2 */</span>
<span id="L2119"><span class="lineNum">    2119</span>              : #define WPA_DRIVER_PROBE_RESP_OFFLOAD_WPS2              0x00000002</span>
<span id="L2120"><span class="lineNum">    2120</span>              : /** Driver Probe Response offloading support for P2P */</span>
<span id="L2121"><span class="lineNum">    2121</span>              : #define WPA_DRIVER_PROBE_RESP_OFFLOAD_P2P               0x00000004</span>
<span id="L2122"><span class="lineNum">    2122</span>              : /** Driver Probe Response offloading support for IEEE 802.11u (Interworking) */</span>
<span id="L2123"><span class="lineNum">    2123</span>              : #define WPA_DRIVER_PROBE_RESP_OFFLOAD_INTERWORKING      0x00000008</span>
<span id="L2124"><span class="lineNum">    2124</span>              :         unsigned int probe_resp_offloads;</span>
<span id="L2125"><span class="lineNum">    2125</span>              : </span>
<span id="L2126"><span class="lineNum">    2126</span>              :         unsigned int max_acl_mac_addrs;</span>
<span id="L2127"><span class="lineNum">    2127</span>              : </span>
<span id="L2128"><span class="lineNum">    2128</span>              :         /**</span>
<span id="L2129"><span class="lineNum">    2129</span>              :          * Number of supported concurrent channels</span>
<span id="L2130"><span class="lineNum">    2130</span>              :          */</span>
<span id="L2131"><span class="lineNum">    2131</span>              :         unsigned int num_multichan_concurrent;</span>
<span id="L2132"><span class="lineNum">    2132</span>              : </span>
<span id="L2133"><span class="lineNum">    2133</span>              :         /**</span>
<span id="L2134"><span class="lineNum">    2134</span>              :          * extended_capa - extended capabilities in driver/device</span>
<span id="L2135"><span class="lineNum">    2135</span>              :          *</span>
<span id="L2136"><span class="lineNum">    2136</span>              :          * Must be allocated and freed by driver and the pointers must be</span>
<span id="L2137"><span class="lineNum">    2137</span>              :          * valid for the lifetime of the driver, i.e., freed in deinit()</span>
<span id="L2138"><span class="lineNum">    2138</span>              :          */</span>
<span id="L2139"><span class="lineNum">    2139</span>              :         const u8 *extended_capa, *extended_capa_mask;</span>
<span id="L2140"><span class="lineNum">    2140</span>              :         unsigned int extended_capa_len;</span>
<span id="L2141"><span class="lineNum">    2141</span>              : </span>
<span id="L2142"><span class="lineNum">    2142</span>              :         struct wowlan_triggers wowlan_triggers;</span>
<span id="L2143"><span class="lineNum">    2143</span>              : </span>
<span id="L2144"><span class="lineNum">    2144</span>              : /** Driver adds the DS Params Set IE in Probe Request frames */</span>
<span id="L2145"><span class="lineNum">    2145</span>              : #define WPA_DRIVER_FLAGS_DS_PARAM_SET_IE_IN_PROBES      0x00000001</span>
<span id="L2146"><span class="lineNum">    2146</span>              : /** Driver adds the WFA TPC IE in Probe Request frames */</span>
<span id="L2147"><span class="lineNum">    2147</span>              : #define WPA_DRIVER_FLAGS_WFA_TPC_IE_IN_PROBES           0x00000002</span>
<span id="L2148"><span class="lineNum">    2148</span>              : /** Driver handles quiet period requests */</span>
<span id="L2149"><span class="lineNum">    2149</span>              : #define WPA_DRIVER_FLAGS_QUIET                          0x00000004</span>
<span id="L2150"><span class="lineNum">    2150</span>              : /**</span>
<span id="L2151"><span class="lineNum">    2151</span>              :  * Driver is capable of inserting the current TX power value into the body of</span>
<span id="L2152"><span class="lineNum">    2152</span>              :  * transmitted frames.</span>
<span id="L2153"><span class="lineNum">    2153</span>              :  * Background: Some Action frames include a TPC Report IE. This IE contains a</span>
<span id="L2154"><span class="lineNum">    2154</span>              :  * TX power field, which has to be updated by lower layers. One such Action</span>
<span id="L2155"><span class="lineNum">    2155</span>              :  * frame is Link Measurement Report (part of RRM). Another is TPC Report (part</span>
<span id="L2156"><span class="lineNum">    2156</span>              :  * of spectrum management). Note that this insertion takes place at a fixed</span>
<span id="L2157"><span class="lineNum">    2157</span>              :  * offset, namely the 6th byte in the Action frame body.</span>
<span id="L2158"><span class="lineNum">    2158</span>              :  */</span>
<span id="L2159"><span class="lineNum">    2159</span>              : #define WPA_DRIVER_FLAGS_TX_POWER_INSERTION             0x00000008</span>
<span id="L2160"><span class="lineNum">    2160</span>              : /**</span>
<span id="L2161"><span class="lineNum">    2161</span>              :  * Driver supports RRM. With this support, the driver will accept to use RRM in</span>
<span id="L2162"><span class="lineNum">    2162</span>              :  * (Re)Association Request frames, without supporting quiet period.</span>
<span id="L2163"><span class="lineNum">    2163</span>              :  */</span>
<span id="L2164"><span class="lineNum">    2164</span>              : #define WPA_DRIVER_FLAGS_SUPPORT_RRM                    0x00000010</span>
<span id="L2165"><span class="lineNum">    2165</span>              : </span>
<span id="L2166"><span class="lineNum">    2166</span>              : /** Driver supports setting the scan dwell time */</span>
<span id="L2167"><span class="lineNum">    2167</span>              : #define WPA_DRIVER_FLAGS_SUPPORT_SET_SCAN_DWELL         0x00000020</span>
<span id="L2168"><span class="lineNum">    2168</span>              : /** Driver supports Beacon Report Measurement */</span>
<span id="L2169"><span class="lineNum">    2169</span>              : #define WPA_DRIVER_FLAGS_SUPPORT_BEACON_REPORT          0x00000040</span>
<span id="L2170"><span class="lineNum">    2170</span>              : </span>
<span id="L2171"><span class="lineNum">    2171</span>              :         u32 rrm_flags;</span>
<span id="L2172"><span class="lineNum">    2172</span>              : </span>
<span id="L2173"><span class="lineNum">    2173</span>              :         /* Driver concurrency capabilities */</span>
<span id="L2174"><span class="lineNum">    2174</span>              :         unsigned int conc_capab;</span>
<span id="L2175"><span class="lineNum">    2175</span>              :         /* Maximum number of concurrent channels on 2.4 GHz */</span>
<span id="L2176"><span class="lineNum">    2176</span>              :         unsigned int max_conc_chan_2_4;</span>
<span id="L2177"><span class="lineNum">    2177</span>              :         /* Maximum number of concurrent channels on 5 GHz */</span>
<span id="L2178"><span class="lineNum">    2178</span>              :         unsigned int max_conc_chan_5_0;</span>
<span id="L2179"><span class="lineNum">    2179</span>              : </span>
<span id="L2180"><span class="lineNum">    2180</span>              :         /* Maximum number of supported CSA counters */</span>
<span id="L2181"><span class="lineNum">    2181</span>              :         u16 max_csa_counters;</span>
<span id="L2182"><span class="lineNum">    2182</span>              : };</span>
<span id="L2183"><span class="lineNum">    2183</span>              : </span>
<span id="L2184"><span class="lineNum">    2184</span>              : </span>
<span id="L2185"><span class="lineNum">    2185</span>              : struct hostapd_data;</span>
<span id="L2186"><span class="lineNum">    2186</span>              : </span>
<span id="L2187"><span class="lineNum">    2187</span>              : #define STA_DRV_DATA_TX_MCS BIT(0)</span>
<span id="L2188"><span class="lineNum">    2188</span>              : #define STA_DRV_DATA_RX_MCS BIT(1)</span>
<span id="L2189"><span class="lineNum">    2189</span>              : #define STA_DRV_DATA_TX_VHT_MCS BIT(2)</span>
<span id="L2190"><span class="lineNum">    2190</span>              : #define STA_DRV_DATA_RX_VHT_MCS BIT(3)</span>
<span id="L2191"><span class="lineNum">    2191</span>              : #define STA_DRV_DATA_TX_VHT_NSS BIT(4)</span>
<span id="L2192"><span class="lineNum">    2192</span>              : #define STA_DRV_DATA_RX_VHT_NSS BIT(5)</span>
<span id="L2193"><span class="lineNum">    2193</span>              : #define STA_DRV_DATA_TX_SHORT_GI BIT(6)</span>
<span id="L2194"><span class="lineNum">    2194</span>              : #define STA_DRV_DATA_RX_SHORT_GI BIT(7)</span>
<span id="L2195"><span class="lineNum">    2195</span>              : #define STA_DRV_DATA_LAST_ACK_RSSI BIT(8)</span>
<span id="L2196"><span class="lineNum">    2196</span>              : #define STA_DRV_DATA_CONN_TIME BIT(9)</span>
<span id="L2197"><span class="lineNum">    2197</span>              : </span>
<span id="L2198"><span class="lineNum">    2198</span>              : struct hostap_sta_driver_data {</span>
<span id="L2199"><span class="lineNum">    2199</span>              :         unsigned long rx_packets, tx_packets;</span>
<span id="L2200"><span class="lineNum">    2200</span>              :         unsigned long long rx_bytes, tx_bytes;</span>
<span id="L2201"><span class="lineNum">    2201</span>              :         unsigned long long rx_airtime, tx_airtime;</span>
<span id="L2202"><span class="lineNum">    2202</span>              :         int bytes_64bit; /* whether 64-bit byte counters are supported */</span>
<span id="L2203"><span class="lineNum">    2203</span>              :         unsigned long current_tx_rate;</span>
<span id="L2204"><span class="lineNum">    2204</span>              :         unsigned long current_rx_rate;</span>
<span id="L2205"><span class="lineNum">    2205</span>              :         unsigned long inactive_msec;</span>
<span id="L2206"><span class="lineNum">    2206</span>              :         unsigned long connected_sec;</span>
<span id="L2207"><span class="lineNum">    2207</span>              :         unsigned long flags; /* bitfield of STA_DRV_DATA_* */</span>
<span id="L2208"><span class="lineNum">    2208</span>              :         unsigned long num_ps_buf_frames;</span>
<span id="L2209"><span class="lineNum">    2209</span>              :         unsigned long tx_retry_failed;</span>
<span id="L2210"><span class="lineNum">    2210</span>              :         unsigned long tx_retry_count;</span>
<span id="L2211"><span class="lineNum">    2211</span>              :         s8 last_ack_rssi;</span>
<span id="L2212"><span class="lineNum">    2212</span>              :         unsigned long backlog_packets;</span>
<span id="L2213"><span class="lineNum">    2213</span>              :         unsigned long backlog_bytes;</span>
<span id="L2214"><span class="lineNum">    2214</span>              :         s8 signal;</span>
<span id="L2215"><span class="lineNum">    2215</span>              :         u8 rx_vhtmcs;</span>
<span id="L2216"><span class="lineNum">    2216</span>              :         u8 tx_vhtmcs;</span>
<span id="L2217"><span class="lineNum">    2217</span>              :         u8 rx_mcs;</span>
<span id="L2218"><span class="lineNum">    2218</span>              :         u8 tx_mcs;</span>
<span id="L2219"><span class="lineNum">    2219</span>              :         u8 rx_vht_nss;</span>
<span id="L2220"><span class="lineNum">    2220</span>              :         u8 tx_vht_nss;</span>
<span id="L2221"><span class="lineNum">    2221</span>              : };</span>
<span id="L2222"><span class="lineNum">    2222</span>              : </span>
<span id="L2223"><span class="lineNum">    2223</span>              : struct hostapd_sta_add_params {</span>
<span id="L2224"><span class="lineNum">    2224</span>              :         const u8 *addr;</span>
<span id="L2225"><span class="lineNum">    2225</span>              :         u16 aid;</span>
<span id="L2226"><span class="lineNum">    2226</span>              :         u16 capability;</span>
<span id="L2227"><span class="lineNum">    2227</span>              :         const u8 *supp_rates;</span>
<span id="L2228"><span class="lineNum">    2228</span>              :         size_t supp_rates_len;</span>
<span id="L2229"><span class="lineNum">    2229</span>              :         u16 listen_interval;</span>
<span id="L2230"><span class="lineNum">    2230</span>              :         const struct ieee80211_ht_capabilities *ht_capabilities;</span>
<span id="L2231"><span class="lineNum">    2231</span>              :         const struct ieee80211_vht_capabilities *vht_capabilities;</span>
<span id="L2232"><span class="lineNum">    2232</span>              :         int vht_opmode_enabled;</span>
<span id="L2233"><span class="lineNum">    2233</span>              :         u8 vht_opmode;</span>
<span id="L2234"><span class="lineNum">    2234</span>              :         const struct ieee80211_he_capabilities *he_capab;</span>
<span id="L2235"><span class="lineNum">    2235</span>              :         size_t he_capab_len;</span>
<span id="L2236"><span class="lineNum">    2236</span>              :         const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab;</span>
<span id="L2237"><span class="lineNum">    2237</span>              :         const struct ieee80211_eht_capabilities *eht_capab;</span>
<span id="L2238"><span class="lineNum">    2238</span>              :         size_t eht_capab_len;</span>
<span id="L2239"><span class="lineNum">    2239</span>              :         u32 flags; /* bitmask of WPA_STA_* flags */</span>
<span id="L2240"><span class="lineNum">    2240</span>              :         u32 flags_mask; /* unset bits in flags */</span>
<span id="L2241"><span class="lineNum">    2241</span>              : #ifdef CONFIG_MESH</span>
<span id="L2242"><span class="lineNum">    2242</span>              :         enum mesh_plink_state plink_state;</span>
<span id="L2243"><span class="lineNum">    2243</span>              :         u16 peer_aid;</span>
<span id="L2244"><span class="lineNum">    2244</span>              : #endif /* CONFIG_MESH */</span>
<span id="L2245"><span class="lineNum">    2245</span>              :         int set; /* Set STA parameters instead of add */</span>
<span id="L2246"><span class="lineNum">    2246</span>              :         u8 qosinfo;</span>
<span id="L2247"><span class="lineNum">    2247</span>              :         const u8 *ext_capab;</span>
<span id="L2248"><span class="lineNum">    2248</span>              :         size_t ext_capab_len;</span>
<span id="L2249"><span class="lineNum">    2249</span>              :         const u8 *supp_channels;</span>
<span id="L2250"><span class="lineNum">    2250</span>              :         size_t supp_channels_len;</span>
<span id="L2251"><span class="lineNum">    2251</span>              :         const u8 *supp_oper_classes;</span>
<span id="L2252"><span class="lineNum">    2252</span>              :         size_t supp_oper_classes_len;</span>
<span id="L2253"><span class="lineNum">    2253</span>              :         int support_p2p_ps;</span>
<span id="L2254"><span class="lineNum">    2254</span>              : };</span>
<span id="L2255"><span class="lineNum">    2255</span>              : </span>
<span id="L2256"><span class="lineNum">    2256</span>              : struct mac_address {</span>
<span id="L2257"><span class="lineNum">    2257</span>              :         u8 addr[ETH_ALEN];</span>
<span id="L2258"><span class="lineNum">    2258</span>              : };</span>
<span id="L2259"><span class="lineNum">    2259</span>              : </span>
<span id="L2260"><span class="lineNum">    2260</span>              : struct hostapd_acl_params {</span>
<span id="L2261"><span class="lineNum">    2261</span>              :         u8 acl_policy;</span>
<span id="L2262"><span class="lineNum">    2262</span>              :         unsigned int num_mac_acl;</span>
<span id="L2263"><span class="lineNum">    2263</span>              :         struct mac_address mac_acl[0];</span>
<span id="L2264"><span class="lineNum">    2264</span>              : };</span>
<span id="L2265"><span class="lineNum">    2265</span>              : </span>
<span id="L2266"><span class="lineNum">    2266</span>              : struct wpa_init_params {</span>
<span id="L2267"><span class="lineNum">    2267</span>              :         void *global_priv;</span>
<span id="L2268"><span class="lineNum">    2268</span>              :         const u8 *bssid;</span>
<span id="L2269"><span class="lineNum">    2269</span>              :         const char *ifname;</span>
<span id="L2270"><span class="lineNum">    2270</span>              :         const char *driver_params;</span>
<span id="L2271"><span class="lineNum">    2271</span>              :         int use_pae_group_addr;</span>
<span id="L2272"><span class="lineNum">    2272</span>              :         char **bridge;</span>
<span id="L2273"><span class="lineNum">    2273</span>              :         size_t num_bridge;</span>
<span id="L2274"><span class="lineNum">    2274</span>              : </span>
<span id="L2275"><span class="lineNum">    2275</span>              :         u8 *own_addr; /* buffer for writing own MAC address */</span>
<span id="L2276"><span class="lineNum">    2276</span>              : };</span>
<span id="L2277"><span class="lineNum">    2277</span>              : </span>
<span id="L2278"><span class="lineNum">    2278</span>              : </span>
<span id="L2279"><span class="lineNum">    2279</span>              : struct wpa_bss_params {</span>
<span id="L2280"><span class="lineNum">    2280</span>              :         /** Interface name (for multi-SSID/VLAN support) */</span>
<span id="L2281"><span class="lineNum">    2281</span>              :         const char *ifname;</span>
<span id="L2282"><span class="lineNum">    2282</span>              :         /** Whether IEEE 802.1X or WPA/WPA2 is enabled */</span>
<span id="L2283"><span class="lineNum">    2283</span>              :         int enabled;</span>
<span id="L2284"><span class="lineNum">    2284</span>              : </span>
<span id="L2285"><span class="lineNum">    2285</span>              :         int wpa;</span>
<span id="L2286"><span class="lineNum">    2286</span>              :         int ieee802_1x;</span>
<span id="L2287"><span class="lineNum">    2287</span>              :         int wpa_group;</span>
<span id="L2288"><span class="lineNum">    2288</span>              :         int wpa_pairwise;</span>
<span id="L2289"><span class="lineNum">    2289</span>              :         int wpa_key_mgmt;</span>
<span id="L2290"><span class="lineNum">    2290</span>              :         int rsn_preauth;</span>
<span id="L2291"><span class="lineNum">    2291</span>              :         enum mfp_options ieee80211w;</span>
<span id="L2292"><span class="lineNum">    2292</span>              : };</span>
<span id="L2293"><span class="lineNum">    2293</span>              : </span>
<span id="L2294"><span class="lineNum">    2294</span>              : #define WPA_STA_AUTHORIZED BIT(0)</span>
<span id="L2295"><span class="lineNum">    2295</span>              : #define WPA_STA_WMM BIT(1)</span>
<span id="L2296"><span class="lineNum">    2296</span>              : #define WPA_STA_SHORT_PREAMBLE BIT(2)</span>
<span id="L2297"><span class="lineNum">    2297</span>              : #define WPA_STA_MFP BIT(3)</span>
<span id="L2298"><span class="lineNum">    2298</span>              : #define WPA_STA_TDLS_PEER BIT(4)</span>
<span id="L2299"><span class="lineNum">    2299</span>              : #define WPA_STA_AUTHENTICATED BIT(5)</span>
<span id="L2300"><span class="lineNum">    2300</span>              : #define WPA_STA_ASSOCIATED BIT(6)</span>
<span id="L2301"><span class="lineNum">    2301</span>              : </span>
<span id="L2302"><span class="lineNum">    2302</span>              : enum tdls_oper {</span>
<span id="L2303"><span class="lineNum">    2303</span>              :         TDLS_DISCOVERY_REQ,</span>
<span id="L2304"><span class="lineNum">    2304</span>              :         TDLS_SETUP,</span>
<span id="L2305"><span class="lineNum">    2305</span>              :         TDLS_TEARDOWN,</span>
<span id="L2306"><span class="lineNum">    2306</span>              :         TDLS_ENABLE_LINK,</span>
<span id="L2307"><span class="lineNum">    2307</span>              :         TDLS_DISABLE_LINK,</span>
<span id="L2308"><span class="lineNum">    2308</span>              :         TDLS_ENABLE,</span>
<span id="L2309"><span class="lineNum">    2309</span>              :         TDLS_DISABLE</span>
<span id="L2310"><span class="lineNum">    2310</span>              : };</span>
<span id="L2311"><span class="lineNum">    2311</span>              : </span>
<span id="L2312"><span class="lineNum">    2312</span>              : enum wnm_oper {</span>
<span id="L2313"><span class="lineNum">    2313</span>              :         WNM_SLEEP_ENTER_CONFIRM,</span>
<span id="L2314"><span class="lineNum">    2314</span>              :         WNM_SLEEP_ENTER_FAIL,</span>
<span id="L2315"><span class="lineNum">    2315</span>              :         WNM_SLEEP_EXIT_CONFIRM,</span>
<span id="L2316"><span class="lineNum">    2316</span>              :         WNM_SLEEP_EXIT_FAIL,</span>
<span id="L2317"><span class="lineNum">    2317</span>              :         WNM_SLEEP_TFS_REQ_IE_ADD,   /* STA requests driver to add TFS req IE */</span>
<span id="L2318"><span class="lineNum">    2318</span>              :         WNM_SLEEP_TFS_REQ_IE_NONE,  /* STA requests empty TFS req IE */</span>
<span id="L2319"><span class="lineNum">    2319</span>              :         WNM_SLEEP_TFS_REQ_IE_SET,   /* AP requests driver to set TFS req IE for</span>
<span id="L2320"><span class="lineNum">    2320</span>              :                                      * a STA */</span>
<span id="L2321"><span class="lineNum">    2321</span>              :         WNM_SLEEP_TFS_RESP_IE_ADD,  /* AP requests driver to add TFS resp IE</span>
<span id="L2322"><span class="lineNum">    2322</span>              :                                      * for a STA */</span>
<span id="L2323"><span class="lineNum">    2323</span>              :         WNM_SLEEP_TFS_RESP_IE_NONE, /* AP requests empty TFS resp IE */</span>
<span id="L2324"><span class="lineNum">    2324</span>              :         WNM_SLEEP_TFS_RESP_IE_SET,  /* AP requests driver to set TFS resp IE</span>
<span id="L2325"><span class="lineNum">    2325</span>              :                                      * for a STA */</span>
<span id="L2326"><span class="lineNum">    2326</span>              :         WNM_SLEEP_TFS_IE_DEL        /* AP delete the TFS IE */</span>
<span id="L2327"><span class="lineNum">    2327</span>              : };</span>
<span id="L2328"><span class="lineNum">    2328</span>              : </span>
<span id="L2329"><span class="lineNum">    2329</span>              : /* enum smps_mode - SMPS mode definitions */</span>
<span id="L2330"><span class="lineNum">    2330</span>              : enum smps_mode {</span>
<span id="L2331"><span class="lineNum">    2331</span>              :         SMPS_AUTOMATIC,</span>
<span id="L2332"><span class="lineNum">    2332</span>              :         SMPS_OFF,</span>
<span id="L2333"><span class="lineNum">    2333</span>              :         SMPS_DYNAMIC,</span>
<span id="L2334"><span class="lineNum">    2334</span>              :         SMPS_STATIC,</span>
<span id="L2335"><span class="lineNum">    2335</span>              : </span>
<span id="L2336"><span class="lineNum">    2336</span>              :         /* Keep last */</span>
<span id="L2337"><span class="lineNum">    2337</span>              :         SMPS_INVALID,</span>
<span id="L2338"><span class="lineNum">    2338</span>              : };</span>
<span id="L2339"><span class="lineNum">    2339</span>              : </span>
<span id="L2340"><span class="lineNum">    2340</span>              : #define WPA_INVALID_NOISE 9999</span>
<span id="L2341"><span class="lineNum">    2341</span>              : </span>
<span id="L2342"><span class="lineNum">    2342</span>              : /**</span>
<span id="L2343"><span class="lineNum">    2343</span>              :  * struct wpa_signal_info - Information about channel signal quality</span>
<span id="L2344"><span class="lineNum">    2344</span>              :  * @frequency: control frequency</span>
<span id="L2345"><span class="lineNum">    2345</span>              :  * @above_threshold: true if the above threshold was crossed</span>
<span id="L2346"><span class="lineNum">    2346</span>              :  *      (relevant for a CQM event)</span>
<span id="L2347"><span class="lineNum">    2347</span>              :  * @current_signal: in dBm</span>
<span id="L2348"><span class="lineNum">    2348</span>              :  * @avg_signal: in dBm</span>
<span id="L2349"><span class="lineNum">    2349</span>              :  * @avg_beacon_signal: in dBm</span>
<span id="L2350"><span class="lineNum">    2350</span>              :  * @current_noise: %WPA_INVALID_NOISE if not supported</span>
<span id="L2351"><span class="lineNum">    2351</span>              :  * @current_txrate: current TX rate</span>
<span id="L2352"><span class="lineNum">    2352</span>              :  * @chanwidth: channel width</span>
<span id="L2353"><span class="lineNum">    2353</span>              :  * @center_frq1: center frequency for the first segment</span>
<span id="L2354"><span class="lineNum">    2354</span>              :  * @center_frq2: center frequency for the second segment (if relevant)</span>
<span id="L2355"><span class="lineNum">    2355</span>              :  */</span>
<span id="L2356"><span class="lineNum">    2356</span>              : struct wpa_signal_info {</span>
<span id="L2357"><span class="lineNum">    2357</span>              :         u32 frequency;</span>
<span id="L2358"><span class="lineNum">    2358</span>              :         int above_threshold;</span>
<span id="L2359"><span class="lineNum">    2359</span>              :         int current_signal;</span>
<span id="L2360"><span class="lineNum">    2360</span>              :         int avg_signal;</span>
<span id="L2361"><span class="lineNum">    2361</span>              :         int avg_beacon_signal;</span>
<span id="L2362"><span class="lineNum">    2362</span>              :         int current_noise;</span>
<span id="L2363"><span class="lineNum">    2363</span>              :         int current_txrate;</span>
<span id="L2364"><span class="lineNum">    2364</span>              :         enum chan_width chanwidth;</span>
<span id="L2365"><span class="lineNum">    2365</span>              :         int center_frq1;</span>
<span id="L2366"><span class="lineNum">    2366</span>              :         int center_frq2;</span>
<span id="L2367"><span class="lineNum">    2367</span>              : };</span>
<span id="L2368"><span class="lineNum">    2368</span>              : </span>
<span id="L2369"><span class="lineNum">    2369</span>              : /**</span>
<span id="L2370"><span class="lineNum">    2370</span>              :  * struct wpa_channel_info - Information about the current channel</span>
<span id="L2371"><span class="lineNum">    2371</span>              :  * @frequency: Center frequency of the primary 20 MHz channel</span>
<span id="L2372"><span class="lineNum">    2372</span>              :  * @chanwidth: Width of the current operating channel</span>
<span id="L2373"><span class="lineNum">    2373</span>              :  * @sec_channel: Location of the secondary 20 MHz channel (either +1 or -1).</span>
<span id="L2374"><span class="lineNum">    2374</span>              :  *      This field is only filled in when using a 40 MHz channel.</span>
<span id="L2375"><span class="lineNum">    2375</span>              :  * @center_frq1: Center frequency of frequency segment 0</span>
<span id="L2376"><span class="lineNum">    2376</span>              :  * @center_frq2: Center frequency of frequency segment 1 (for 80+80 channels)</span>
<span id="L2377"><span class="lineNum">    2377</span>              :  * @seg1_idx: Frequency segment 1 index when using a 80+80 channel. This is</span>
<span id="L2378"><span class="lineNum">    2378</span>              :  *      derived from center_frq2 for convenience.</span>
<span id="L2379"><span class="lineNum">    2379</span>              :  */</span>
<span id="L2380"><span class="lineNum">    2380</span>              : struct wpa_channel_info {</span>
<span id="L2381"><span class="lineNum">    2381</span>              :         u32 frequency;</span>
<span id="L2382"><span class="lineNum">    2382</span>              :         enum chan_width chanwidth;</span>
<span id="L2383"><span class="lineNum">    2383</span>              :         int sec_channel;</span>
<span id="L2384"><span class="lineNum">    2384</span>              :         int center_frq1;</span>
<span id="L2385"><span class="lineNum">    2385</span>              :         int center_frq2;</span>
<span id="L2386"><span class="lineNum">    2386</span>              :         u8 seg1_idx;</span>
<span id="L2387"><span class="lineNum">    2387</span>              : };</span>
<span id="L2388"><span class="lineNum">    2388</span>              : </span>
<span id="L2389"><span class="lineNum">    2389</span>              : /**</span>
<span id="L2390"><span class="lineNum">    2390</span>              :  * struct beacon_data - Beacon data</span>
<span id="L2391"><span class="lineNum">    2391</span>              :  * @head: Head portion of Beacon frame (before TIM IE)</span>
<span id="L2392"><span class="lineNum">    2392</span>              :  * @tail: Tail portion of Beacon frame (after TIM IE)</span>
<span id="L2393"><span class="lineNum">    2393</span>              :  * @beacon_ies: Extra information element(s) to add into Beacon frames or %NULL</span>
<span id="L2394"><span class="lineNum">    2394</span>              :  * @proberesp_ies: Extra information element(s) to add into Probe Response</span>
<span id="L2395"><span class="lineNum">    2395</span>              :  *      frames or %NULL</span>
<span id="L2396"><span class="lineNum">    2396</span>              :  * @assocresp_ies: Extra information element(s) to add into (Re)Association</span>
<span id="L2397"><span class="lineNum">    2397</span>              :  *      Response frames or %NULL</span>
<span id="L2398"><span class="lineNum">    2398</span>              :  * @probe_resp: Probe Response frame template</span>
<span id="L2399"><span class="lineNum">    2399</span>              :  * @head_len: Length of @head</span>
<span id="L2400"><span class="lineNum">    2400</span>              :  * @tail_len: Length of @tail</span>
<span id="L2401"><span class="lineNum">    2401</span>              :  * @beacon_ies_len: Length of beacon_ies in octets</span>
<span id="L2402"><span class="lineNum">    2402</span>              :  * @proberesp_ies_len: Length of proberesp_ies in octets</span>
<span id="L2403"><span class="lineNum">    2403</span>              :  * @proberesp_ies_len: Length of proberesp_ies in octets</span>
<span id="L2404"><span class="lineNum">    2404</span>              :  * @probe_resp_len: Length of probe response template (@probe_resp)</span>
<span id="L2405"><span class="lineNum">    2405</span>              :  */</span>
<span id="L2406"><span class="lineNum">    2406</span>              : struct beacon_data {</span>
<span id="L2407"><span class="lineNum">    2407</span>              :         u8 *head, *tail;</span>
<span id="L2408"><span class="lineNum">    2408</span>              :         u8 *beacon_ies;</span>
<span id="L2409"><span class="lineNum">    2409</span>              :         u8 *proberesp_ies;</span>
<span id="L2410"><span class="lineNum">    2410</span>              :         u8 *assocresp_ies;</span>
<span id="L2411"><span class="lineNum">    2411</span>              :         u8 *probe_resp;</span>
<span id="L2412"><span class="lineNum">    2412</span>              : </span>
<span id="L2413"><span class="lineNum">    2413</span>              :         size_t head_len, tail_len;</span>
<span id="L2414"><span class="lineNum">    2414</span>              :         size_t beacon_ies_len;</span>
<span id="L2415"><span class="lineNum">    2415</span>              :         size_t proberesp_ies_len;</span>
<span id="L2416"><span class="lineNum">    2416</span>              :         size_t assocresp_ies_len;</span>
<span id="L2417"><span class="lineNum">    2417</span>              :         size_t probe_resp_len;</span>
<span id="L2418"><span class="lineNum">    2418</span>              : };</span>
<span id="L2419"><span class="lineNum">    2419</span>              : </span>
<span id="L2420"><span class="lineNum">    2420</span>              : /**</span>
<span id="L2421"><span class="lineNum">    2421</span>              :  * struct csa_settings - Settings for channel switch command</span>
<span id="L2422"><span class="lineNum">    2422</span>              :  * @cs_count: Count in Beacon frames (TBTT) to perform the switch</span>
<span id="L2423"><span class="lineNum">    2423</span>              :  * @block_tx: 1 - block transmission for CSA period</span>
<span id="L2424"><span class="lineNum">    2424</span>              :  * @freq_params: Next channel frequency parameter</span>
<span id="L2425"><span class="lineNum">    2425</span>              :  * @beacon_csa: Beacon/probe resp/asooc resp info for CSA period</span>
<span id="L2426"><span class="lineNum">    2426</span>              :  * @beacon_after: Next beacon/probe resp/asooc resp info</span>
<span id="L2427"><span class="lineNum">    2427</span>              :  * @counter_offset_beacon: Offset to the count field in beacon's tail</span>
<span id="L2428"><span class="lineNum">    2428</span>              :  * @counter_offset_presp: Offset to the count field in probe resp.</span>
<span id="L2429"><span class="lineNum">    2429</span>              :  */</span>
<span id="L2430"><span class="lineNum">    2430</span>              : struct csa_settings {</span>
<span id="L2431"><span class="lineNum">    2431</span>              :         u8 cs_count;</span>
<span id="L2432"><span class="lineNum">    2432</span>              :         u8 block_tx;</span>
<span id="L2433"><span class="lineNum">    2433</span>              : </span>
<span id="L2434"><span class="lineNum">    2434</span>              :         struct hostapd_freq_params freq_params;</span>
<span id="L2435"><span class="lineNum">    2435</span>              :         struct beacon_data beacon_csa;</span>
<span id="L2436"><span class="lineNum">    2436</span>              :         struct beacon_data beacon_after;</span>
<span id="L2437"><span class="lineNum">    2437</span>              : </span>
<span id="L2438"><span class="lineNum">    2438</span>              :         u16 counter_offset_beacon[2];</span>
<span id="L2439"><span class="lineNum">    2439</span>              :         u16 counter_offset_presp[2];</span>
<span id="L2440"><span class="lineNum">    2440</span>              : };</span>
<span id="L2441"><span class="lineNum">    2441</span>              : </span>
<span id="L2442"><span class="lineNum">    2442</span>              : /**</span>
<span id="L2443"><span class="lineNum">    2443</span>              :  * struct cca_settings - Settings for color switch command</span>
<span id="L2444"><span class="lineNum">    2444</span>              :  * @cca_count: Count in Beacon frames (TBTT) to perform the switch</span>
<span id="L2445"><span class="lineNum">    2445</span>              :  * @cca_color: The new color that we are switching to</span>
<span id="L2446"><span class="lineNum">    2446</span>              :  * @beacon_cca: Beacon/Probe Response/(Re)Association Response frame info for</span>
<span id="L2447"><span class="lineNum">    2447</span>              :  * color switch period</span>
<span id="L2448"><span class="lineNum">    2448</span>              :  * @beacon_after: Next Beacon/Probe Response/(Re)Association Response frame info</span>
<span id="L2449"><span class="lineNum">    2449</span>              :  * @counter_offset_beacon: Offset to the count field in Beacon frame tail</span>
<span id="L2450"><span class="lineNum">    2450</span>              :  * @counter_offset_presp: Offset to the count field in Probe Response frame</span>
<span id="L2451"><span class="lineNum">    2451</span>              :  */</span>
<span id="L2452"><span class="lineNum">    2452</span>              : struct cca_settings {</span>
<span id="L2453"><span class="lineNum">    2453</span>              :         u8 cca_count;</span>
<span id="L2454"><span class="lineNum">    2454</span>              :         u8 cca_color;</span>
<span id="L2455"><span class="lineNum">    2455</span>              : </span>
<span id="L2456"><span class="lineNum">    2456</span>              :         struct beacon_data beacon_cca;</span>
<span id="L2457"><span class="lineNum">    2457</span>              :         struct beacon_data beacon_after;</span>
<span id="L2458"><span class="lineNum">    2458</span>              : </span>
<span id="L2459"><span class="lineNum">    2459</span>              :         u16 counter_offset_beacon;</span>
<span id="L2460"><span class="lineNum">    2460</span>              :         u16 counter_offset_presp;</span>
<span id="L2461"><span class="lineNum">    2461</span>              : };</span>
<span id="L2462"><span class="lineNum">    2462</span>              : </span>
<span id="L2463"><span class="lineNum">    2463</span>              : /* TDLS peer capabilities for send_tdls_mgmt() */</span>
<span id="L2464"><span class="lineNum">    2464</span>              : enum tdls_peer_capability {</span>
<span id="L2465"><span class="lineNum">    2465</span>              :         TDLS_PEER_HT = BIT(0),</span>
<span id="L2466"><span class="lineNum">    2466</span>              :         TDLS_PEER_VHT = BIT(1),</span>
<span id="L2467"><span class="lineNum">    2467</span>              :         TDLS_PEER_WMM = BIT(2),</span>
<span id="L2468"><span class="lineNum">    2468</span>              :         TDLS_PEER_HE = BIT(3),</span>
<span id="L2469"><span class="lineNum">    2469</span>              : };</span>
<span id="L2470"><span class="lineNum">    2470</span>              : </span>
<span id="L2471"><span class="lineNum">    2471</span>              : /* valid info in the wmm_params struct */</span>
<span id="L2472"><span class="lineNum">    2472</span>              : enum wmm_params_valid_info {</span>
<span id="L2473"><span class="lineNum">    2473</span>              :         WMM_PARAMS_UAPSD_QUEUES_INFO = BIT(0),</span>
<span id="L2474"><span class="lineNum">    2474</span>              : };</span>
<span id="L2475"><span class="lineNum">    2475</span>              : </span>
<span id="L2476"><span class="lineNum">    2476</span>              : /**</span>
<span id="L2477"><span class="lineNum">    2477</span>              :  * struct wmm_params - WMM parameterss configured for this association</span>
<span id="L2478"><span class="lineNum">    2478</span>              :  * @info_bitmap: Bitmap of valid wmm_params info; indicates what fields</span>
<span id="L2479"><span class="lineNum">    2479</span>              :  *      of the struct contain valid information.</span>
<span id="L2480"><span class="lineNum">    2480</span>              :  * @uapsd_queues: Bitmap of ACs configured for uapsd (valid only if</span>
<span id="L2481"><span class="lineNum">    2481</span>              :  *      %WMM_PARAMS_UAPSD_QUEUES_INFO is set)</span>
<span id="L2482"><span class="lineNum">    2482</span>              :  */</span>
<span id="L2483"><span class="lineNum">    2483</span>              : struct wmm_params {</span>
<span id="L2484"><span class="lineNum">    2484</span>              :         u8 info_bitmap;</span>
<span id="L2485"><span class="lineNum">    2485</span>              :         u8 uapsd_queues;</span>
<span id="L2486"><span class="lineNum">    2486</span>              : };</span>
<span id="L2487"><span class="lineNum">    2487</span>              : </span>
<span id="L2488"><span class="lineNum">    2488</span>              : #ifdef CONFIG_MACSEC</span>
<span id="L2489"><span class="lineNum">    2489</span>              : struct macsec_init_params {</span>
<span id="L2490"><span class="lineNum">    2490</span>              :         bool always_include_sci;</span>
<span id="L2491"><span class="lineNum">    2491</span>              :         bool use_es;</span>
<span id="L2492"><span class="lineNum">    2492</span>              :         bool use_scb;</span>
<span id="L2493"><span class="lineNum">    2493</span>              : };</span>
<span id="L2494"><span class="lineNum">    2494</span>              : #endif /* CONFIG_MACSEC */</span>
<span id="L2495"><span class="lineNum">    2495</span>              : </span>
<span id="L2496"><span class="lineNum">    2496</span>              : enum drv_br_port_attr {</span>
<span id="L2497"><span class="lineNum">    2497</span>              :         DRV_BR_PORT_ATTR_PROXYARP,</span>
<span id="L2498"><span class="lineNum">    2498</span>              :         DRV_BR_PORT_ATTR_HAIRPIN_MODE,</span>
<span id="L2499"><span class="lineNum">    2499</span>              : };</span>
<span id="L2500"><span class="lineNum">    2500</span>              : </span>
<span id="L2501"><span class="lineNum">    2501</span>              : enum drv_br_net_param {</span>
<span id="L2502"><span class="lineNum">    2502</span>              :         DRV_BR_NET_PARAM_GARP_ACCEPT,</span>
<span id="L2503"><span class="lineNum">    2503</span>              :         DRV_BR_MULTICAST_SNOOPING,</span>
<span id="L2504"><span class="lineNum">    2504</span>              : };</span>
<span id="L2505"><span class="lineNum">    2505</span>              : </span>
<span id="L2506"><span class="lineNum">    2506</span>              : struct drv_acs_params {</span>
<span id="L2507"><span class="lineNum">    2507</span>              :         /* Selected mode (HOSTAPD_MODE_*) */</span>
<span id="L2508"><span class="lineNum">    2508</span>              :         enum hostapd_hw_mode hw_mode;</span>
<span id="L2509"><span class="lineNum">    2509</span>              : </span>
<span id="L2510"><span class="lineNum">    2510</span>              :         /* Indicates whether HT is enabled */</span>
<span id="L2511"><span class="lineNum">    2511</span>              :         int ht_enabled;</span>
<span id="L2512"><span class="lineNum">    2512</span>              : </span>
<span id="L2513"><span class="lineNum">    2513</span>              :         /* Indicates whether HT40 is enabled */</span>
<span id="L2514"><span class="lineNum">    2514</span>              :         int ht40_enabled;</span>
<span id="L2515"><span class="lineNum">    2515</span>              : </span>
<span id="L2516"><span class="lineNum">    2516</span>              :         /* Indicates whether VHT is enabled */</span>
<span id="L2517"><span class="lineNum">    2517</span>              :         int vht_enabled;</span>
<span id="L2518"><span class="lineNum">    2518</span>              : </span>
<span id="L2519"><span class="lineNum">    2519</span>              :         /* Configured ACS channel width */</span>
<span id="L2520"><span class="lineNum">    2520</span>              :         u16 ch_width;</span>
<span id="L2521"><span class="lineNum">    2521</span>              : </span>
<span id="L2522"><span class="lineNum">    2522</span>              :         /* ACS frequency list info */</span>
<span id="L2523"><span class="lineNum">    2523</span>              :         const int *freq_list;</span>
<span id="L2524"><span class="lineNum">    2524</span>              : </span>
<span id="L2525"><span class="lineNum">    2525</span>              :         /* Indicates whether EDMG is enabled */</span>
<span id="L2526"><span class="lineNum">    2526</span>              :         int edmg_enabled;</span>
<span id="L2527"><span class="lineNum">    2527</span>              : </span>
<span id="L2528"><span class="lineNum">    2528</span>              :         /* Indicates whether EHT is enabled */</span>
<span id="L2529"><span class="lineNum">    2529</span>              :         bool eht_enabled;</span>
<span id="L2530"><span class="lineNum">    2530</span>              : };</span>
<span id="L2531"><span class="lineNum">    2531</span>              : </span>
<span id="L2532"><span class="lineNum">    2532</span>              : struct wpa_bss_trans_info {</span>
<span id="L2533"><span class="lineNum">    2533</span>              :         u8 mbo_transition_reason;</span>
<span id="L2534"><span class="lineNum">    2534</span>              :         u8 n_candidates;</span>
<span id="L2535"><span class="lineNum">    2535</span>              :         u8 *bssid;</span>
<span id="L2536"><span class="lineNum">    2536</span>              : };</span>
<span id="L2537"><span class="lineNum">    2537</span>              : </span>
<span id="L2538"><span class="lineNum">    2538</span>              : struct wpa_bss_candidate_info {</span>
<span id="L2539"><span class="lineNum">    2539</span>              :         u8 num;</span>
<span id="L2540"><span class="lineNum">    2540</span>              :         struct candidate_list {</span>
<span id="L2541"><span class="lineNum">    2541</span>              :                 u8 bssid[ETH_ALEN];</span>
<span id="L2542"><span class="lineNum">    2542</span>              :                 u8 is_accept;</span>
<span id="L2543"><span class="lineNum">    2543</span>              :                 u32 reject_reason;</span>
<span id="L2544"><span class="lineNum">    2544</span>              :         } *candidates;</span>
<span id="L2545"><span class="lineNum">    2545</span>              : };</span>
<span id="L2546"><span class="lineNum">    2546</span>              : </span>
<span id="L2547"><span class="lineNum">    2547</span>              : struct wpa_pmkid_params {</span>
<span id="L2548"><span class="lineNum">    2548</span>              :         const u8 *bssid;</span>
<span id="L2549"><span class="lineNum">    2549</span>              :         const u8 *ssid;</span>
<span id="L2550"><span class="lineNum">    2550</span>              :         size_t ssid_len;</span>
<span id="L2551"><span class="lineNum">    2551</span>              :         const u8 *fils_cache_id;</span>
<span id="L2552"><span class="lineNum">    2552</span>              :         const u8 *pmkid;</span>
<span id="L2553"><span class="lineNum">    2553</span>              :         const u8 *pmk;</span>
<span id="L2554"><span class="lineNum">    2554</span>              :         size_t pmk_len;</span>
<span id="L2555"><span class="lineNum">    2555</span>              :         u32 pmk_lifetime;</span>
<span id="L2556"><span class="lineNum">    2556</span>              :         u8 pmk_reauth_threshold;</span>
<span id="L2557"><span class="lineNum">    2557</span>              : };</span>
<span id="L2558"><span class="lineNum">    2558</span>              : </span>
<span id="L2559"><span class="lineNum">    2559</span>              : /* Mask used to specify which connection parameters have to be updated */</span>
<span id="L2560"><span class="lineNum">    2560</span>              : enum wpa_drv_update_connect_params_mask {</span>
<span id="L2561"><span class="lineNum">    2561</span>              :         WPA_DRV_UPDATE_ASSOC_IES        = BIT(0),</span>
<span id="L2562"><span class="lineNum">    2562</span>              :         WPA_DRV_UPDATE_FILS_ERP_INFO    = BIT(1),</span>
<span id="L2563"><span class="lineNum">    2563</span>              :         WPA_DRV_UPDATE_AUTH_TYPE        = BIT(2),</span>
<span id="L2564"><span class="lineNum">    2564</span>              : };</span>
<span id="L2565"><span class="lineNum">    2565</span>              : </span>
<span id="L2566"><span class="lineNum">    2566</span>              : /**</span>
<span id="L2567"><span class="lineNum">    2567</span>              :  * struct external_auth - External authentication trigger parameters</span>
<span id="L2568"><span class="lineNum">    2568</span>              :  *</span>
<span id="L2569"><span class="lineNum">    2569</span>              :  * These are used across the external authentication request and event</span>
<span id="L2570"><span class="lineNum">    2570</span>              :  * interfaces.</span>
<span id="L2571"><span class="lineNum">    2571</span>              :  * @action: Action type / trigger for external authentication. Only significant</span>
<span id="L2572"><span class="lineNum">    2572</span>              :  *      for the event interface.</span>
<span id="L2573"><span class="lineNum">    2573</span>              :  * @bssid: BSSID of the peer with which the authentication has to happen. Used</span>
<span id="L2574"><span class="lineNum">    2574</span>              :  *      by both the request and event interface.</span>
<span id="L2575"><span class="lineNum">    2575</span>              :  * @ssid: SSID of the AP. Used by both the request and event interface.</span>
<span id="L2576"><span class="lineNum">    2576</span>              :  * @ssid_len: SSID length in octets.</span>
<span id="L2577"><span class="lineNum">    2577</span>              :  * @key_mgmt_suite: AKM suite of the respective authentication. Optional for</span>
<span id="L2578"><span class="lineNum">    2578</span>              :  *      the request interface.</span>
<span id="L2579"><span class="lineNum">    2579</span>              :  * @status: Status code, %WLAN_STATUS_SUCCESS for successful authentication,</span>
<span id="L2580"><span class="lineNum">    2580</span>              :  *      use %WLAN_STATUS_UNSPECIFIED_FAILURE if wpa_supplicant cannot give</span>
<span id="L2581"><span class="lineNum">    2581</span>              :  *      the real status code for failures. Used only for the request interface</span>
<span id="L2582"><span class="lineNum">    2582</span>              :  *      from user space to the driver.</span>
<span id="L2583"><span class="lineNum">    2583</span>              :  * @pmkid: Generated PMKID as part of external auth exchange (e.g., SAE).</span>
<span id="L2584"><span class="lineNum">    2584</span>              :  */</span>
<span id="L2585"><span class="lineNum">    2585</span>              : struct external_auth {</span>
<span id="L2586"><span class="lineNum">    2586</span>              :         enum {</span>
<span id="L2587"><span class="lineNum">    2587</span>              :                 EXT_AUTH_START,</span>
<span id="L2588"><span class="lineNum">    2588</span>              :                 EXT_AUTH_ABORT,</span>
<span id="L2589"><span class="lineNum">    2589</span>              :         } action;</span>
<span id="L2590"><span class="lineNum">    2590</span>              :         const u8 *bssid;</span>
<span id="L2591"><span class="lineNum">    2591</span>              :         const u8 *ssid;</span>
<span id="L2592"><span class="lineNum">    2592</span>              :         size_t ssid_len;</span>
<span id="L2593"><span class="lineNum">    2593</span>              :         unsigned int key_mgmt_suite;</span>
<span id="L2594"><span class="lineNum">    2594</span>              :         u16 status;</span>
<span id="L2595"><span class="lineNum">    2595</span>              :         const u8 *pmkid;</span>
<span id="L2596"><span class="lineNum">    2596</span>              : };</span>
<span id="L2597"><span class="lineNum">    2597</span>              : </span>
<span id="L2598"><span class="lineNum">    2598</span>              : /* enum nested_attr - Used to specify if subcommand uses nested attributes */</span>
<span id="L2599"><span class="lineNum">    2599</span>              : enum nested_attr {</span>
<span id="L2600"><span class="lineNum">    2600</span>              :         NESTED_ATTR_NOT_USED = 0,</span>
<span id="L2601"><span class="lineNum">    2601</span>              :         NESTED_ATTR_USED = 1,</span>
<span id="L2602"><span class="lineNum">    2602</span>              :         NESTED_ATTR_UNSPECIFIED = 2,</span>
<span id="L2603"><span class="lineNum">    2603</span>              : };</span>
<span id="L2604"><span class="lineNum">    2604</span>              : </span>
<span id="L2605"><span class="lineNum">    2605</span>              : /**</span>
<span id="L2606"><span class="lineNum">    2606</span>              :  * struct wpa_driver_ops - Driver interface API definition</span>
<span id="L2607"><span class="lineNum">    2607</span>              :  *</span>
<span id="L2608"><span class="lineNum">    2608</span>              :  * This structure defines the API that each driver interface needs to implement</span>
<span id="L2609"><span class="lineNum">    2609</span>              :  * for core wpa_supplicant code. All driver specific functionality is captured</span>
<span id="L2610"><span class="lineNum">    2610</span>              :  * in this wrapper.</span>
<span id="L2611"><span class="lineNum">    2611</span>              :  */</span>
<span id="L2612"><span class="lineNum">    2612</span>              : struct wpa_driver_ops {</span>
<span id="L2613"><span class="lineNum">    2613</span>              :         /** Name of the driver interface */</span>
<span id="L2614"><span class="lineNum">    2614</span>              :         const char *name;</span>
<span id="L2615"><span class="lineNum">    2615</span>              :         /** One line description of the driver interface */</span>
<span id="L2616"><span class="lineNum">    2616</span>              :         const char *desc;</span>
<span id="L2617"><span class="lineNum">    2617</span>              : </span>
<span id="L2618"><span class="lineNum">    2618</span>              :         /**</span>
<span id="L2619"><span class="lineNum">    2619</span>              :          * get_bssid - Get the current BSSID</span>
<span id="L2620"><span class="lineNum">    2620</span>              :          * @priv: private driver interface data</span>
<span id="L2621"><span class="lineNum">    2621</span>              :          * @bssid: buffer for BSSID (ETH_ALEN = 6 bytes)</span>
<span id="L2622"><span class="lineNum">    2622</span>              :          *</span>
<span id="L2623"><span class="lineNum">    2623</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2624"><span class="lineNum">    2624</span>              :          *</span>
<span id="L2625"><span class="lineNum">    2625</span>              :          * Query kernel driver for the current BSSID and copy it to bssid.</span>
<span id="L2626"><span class="lineNum">    2626</span>              :          * Setting bssid to 00:00:00:00:00:00 is recommended if the STA is not</span>
<span id="L2627"><span class="lineNum">    2627</span>              :          * associated.</span>
<span id="L2628"><span class="lineNum">    2628</span>              :          */</span>
<span id="L2629"><span class="lineNum">    2629</span>              :         int (*get_bssid)(void *priv, u8 *bssid);</span>
<span id="L2630"><span class="lineNum">    2630</span>              : </span>
<span id="L2631"><span class="lineNum">    2631</span>              :         /**</span>
<span id="L2632"><span class="lineNum">    2632</span>              :          * get_ssid - Get the current SSID</span>
<span id="L2633"><span class="lineNum">    2633</span>              :          * @priv: private driver interface data</span>
<span id="L2634"><span class="lineNum">    2634</span>              :          * @ssid: buffer for SSID (at least 32 bytes)</span>
<span id="L2635"><span class="lineNum">    2635</span>              :          *</span>
<span id="L2636"><span class="lineNum">    2636</span>              :          * Returns: Length of the SSID on success, -1 on failure</span>
<span id="L2637"><span class="lineNum">    2637</span>              :          *</span>
<span id="L2638"><span class="lineNum">    2638</span>              :          * Query kernel driver for the current SSID and copy it to ssid.</span>
<span id="L2639"><span class="lineNum">    2639</span>              :          * Returning zero is recommended if the STA is not associated.</span>
<span id="L2640"><span class="lineNum">    2640</span>              :          *</span>
<span id="L2641"><span class="lineNum">    2641</span>              :          * Note: SSID is an array of octets, i.e., it is not nul terminated and</span>
<span id="L2642"><span class="lineNum">    2642</span>              :          * can, at least in theory, contain control characters (including nul)</span>
<span id="L2643"><span class="lineNum">    2643</span>              :          * and as such, should be processed as binary data, not a printable</span>
<span id="L2644"><span class="lineNum">    2644</span>              :          * string.</span>
<span id="L2645"><span class="lineNum">    2645</span>              :          */</span>
<span id="L2646"><span class="lineNum">    2646</span>              :         int (*get_ssid)(void *priv, u8 *ssid);</span>
<span id="L2647"><span class="lineNum">    2647</span>              : </span>
<span id="L2648"><span class="lineNum">    2648</span>              :         /**</span>
<span id="L2649"><span class="lineNum">    2649</span>              :          * set_key - Configure encryption key</span>
<span id="L2650"><span class="lineNum">    2650</span>              :          * @priv: private driver interface data</span>
<span id="L2651"><span class="lineNum">    2651</span>              :          * @params: Key parameters</span>
<span id="L2652"><span class="lineNum">    2652</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2653"><span class="lineNum">    2653</span>              :          *</span>
<span id="L2654"><span class="lineNum">    2654</span>              :          * Configure the given key for the kernel driver. If the driver</span>
<span id="L2655"><span class="lineNum">    2655</span>              :          * supports separate individual keys (4 default keys + 1 individual),</span>
<span id="L2656"><span class="lineNum">    2656</span>              :          * addr can be used to determine whether the key is default or</span>
<span id="L2657"><span class="lineNum">    2657</span>              :          * individual. If only 4 keys are supported, the default key with key</span>
<span id="L2658"><span class="lineNum">    2658</span>              :          * index 0 is used as the individual key. STA must be configured to use</span>
<span id="L2659"><span class="lineNum">    2659</span>              :          * it as the default Tx key (set_tx is set) and accept Rx for all the</span>
<span id="L2660"><span class="lineNum">    2660</span>              :          * key indexes. In most cases, WPA uses only key indexes 1 and 2 for</span>
<span id="L2661"><span class="lineNum">    2661</span>              :          * broadcast keys, so key index 0 is available for this kind of</span>
<span id="L2662"><span class="lineNum">    2662</span>              :          * configuration.</span>
<span id="L2663"><span class="lineNum">    2663</span>              :          *</span>
<span id="L2664"><span class="lineNum">    2664</span>              :          * Please note that TKIP keys include separate TX and RX MIC keys and</span>
<span id="L2665"><span class="lineNum">    2665</span>              :          * some drivers may expect them in different order than wpa_supplicant</span>
<span id="L2666"><span class="lineNum">    2666</span>              :          * is using. If the TX/RX keys are swapped, all TKIP encrypted packets</span>
<span id="L2667"><span class="lineNum">    2667</span>              :          * will trigger Michael MIC errors. This can be fixed by changing the</span>
<span id="L2668"><span class="lineNum">    2668</span>              :          * order of MIC keys by swapping the bytes 16..23 and 24..31 of the key</span>
<span id="L2669"><span class="lineNum">    2669</span>              :          * in driver_*.c set_key() implementation, see driver_ndis.c for an</span>
<span id="L2670"><span class="lineNum">    2670</span>              :          * example on how this can be done.</span>
<span id="L2671"><span class="lineNum">    2671</span>              :          */</span>
<span id="L2672"><span class="lineNum">    2672</span>              :         int (*set_key)(void *priv, struct wpa_driver_set_key_params *params);</span>
<span id="L2673"><span class="lineNum">    2673</span>              : </span>
<span id="L2674"><span class="lineNum">    2674</span>              :         /**</span>
<span id="L2675"><span class="lineNum">    2675</span>              :          * init - Initialize driver interface</span>
<span id="L2676"><span class="lineNum">    2676</span>              :          * @ctx: context to be used when calling wpa_supplicant functions,</span>
<span id="L2677"><span class="lineNum">    2677</span>              :          * e.g., wpa_supplicant_event()</span>
<span id="L2678"><span class="lineNum">    2678</span>              :          * @ifname: interface name, e.g., wlan0</span>
<span id="L2679"><span class="lineNum">    2679</span>              :          *</span>
<span id="L2680"><span class="lineNum">    2680</span>              :          * Returns: Pointer to private data, %NULL on failure</span>
<span id="L2681"><span class="lineNum">    2681</span>              :          *</span>
<span id="L2682"><span class="lineNum">    2682</span>              :          * Initialize driver interface, including event processing for kernel</span>
<span id="L2683"><span class="lineNum">    2683</span>              :          * driver events (e.g., associated, scan results, Michael MIC failure).</span>
<span id="L2684"><span class="lineNum">    2684</span>              :          * This function can allocate a private configuration data area for</span>
<span id="L2685"><span class="lineNum">    2685</span>              :          * @ctx, file descriptor, interface name, etc. information that may be</span>
<span id="L2686"><span class="lineNum">    2686</span>              :          * needed in future driver operations. If this is not used, non-NULL</span>
<span id="L2687"><span class="lineNum">    2687</span>              :          * value will need to be returned because %NULL is used to indicate</span>
<span id="L2688"><span class="lineNum">    2688</span>              :          * failure. The returned value will be used as 'void *priv' data for</span>
<span id="L2689"><span class="lineNum">    2689</span>              :          * all other driver_ops functions.</span>
<span id="L2690"><span class="lineNum">    2690</span>              :          *</span>
<span id="L2691"><span class="lineNum">    2691</span>              :          * The main event loop (eloop.c) of wpa_supplicant can be used to</span>
<span id="L2692"><span class="lineNum">    2692</span>              :          * register callback for read sockets (eloop_register_read_sock()).</span>
<span id="L2693"><span class="lineNum">    2693</span>              :          *</span>
<span id="L2694"><span class="lineNum">    2694</span>              :          * See below for more information about events and</span>
<span id="L2695"><span class="lineNum">    2695</span>              :          * wpa_supplicant_event() function.</span>
<span id="L2696"><span class="lineNum">    2696</span>              :          */</span>
<span id="L2697"><span class="lineNum">    2697</span>              :         void * (*init)(void *ctx, const char *ifname);</span>
<span id="L2698"><span class="lineNum">    2698</span>              : </span>
<span id="L2699"><span class="lineNum">    2699</span>              :         /**</span>
<span id="L2700"><span class="lineNum">    2700</span>              :          * deinit - Deinitialize driver interface</span>
<span id="L2701"><span class="lineNum">    2701</span>              :          * @priv: private driver interface data from init()</span>
<span id="L2702"><span class="lineNum">    2702</span>              :          *</span>
<span id="L2703"><span class="lineNum">    2703</span>              :          * Shut down driver interface and processing of driver events. Free</span>
<span id="L2704"><span class="lineNum">    2704</span>              :          * private data buffer if one was allocated in init() handler.</span>
<span id="L2705"><span class="lineNum">    2705</span>              :          */</span>
<span id="L2706"><span class="lineNum">    2706</span>              :         void (*deinit)(void *priv);</span>
<span id="L2707"><span class="lineNum">    2707</span>              : </span>
<span id="L2708"><span class="lineNum">    2708</span>              :         /**</span>
<span id="L2709"><span class="lineNum">    2709</span>              :          * set_param - Set driver configuration parameters</span>
<span id="L2710"><span class="lineNum">    2710</span>              :          * @priv: private driver interface data from init()</span>
<span id="L2711"><span class="lineNum">    2711</span>              :          * @param: driver specific configuration parameters</span>
<span id="L2712"><span class="lineNum">    2712</span>              :          *</span>
<span id="L2713"><span class="lineNum">    2713</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2714"><span class="lineNum">    2714</span>              :          *</span>
<span id="L2715"><span class="lineNum">    2715</span>              :          * Optional handler for notifying driver interface about configuration</span>
<span id="L2716"><span class="lineNum">    2716</span>              :          * parameters (driver_param).</span>
<span id="L2717"><span class="lineNum">    2717</span>              :          */</span>
<span id="L2718"><span class="lineNum">    2718</span>              :         int (*set_param)(void *priv, const char *param);</span>
<span id="L2719"><span class="lineNum">    2719</span>              : </span>
<span id="L2720"><span class="lineNum">    2720</span>              :         /**</span>
<span id="L2721"><span class="lineNum">    2721</span>              :          * set_countermeasures - Enable/disable TKIP countermeasures</span>
<span id="L2722"><span class="lineNum">    2722</span>              :          * @priv: private driver interface data</span>
<span id="L2723"><span class="lineNum">    2723</span>              :          * @enabled: 1 = countermeasures enabled, 0 = disabled</span>
<span id="L2724"><span class="lineNum">    2724</span>              :          *</span>
<span id="L2725"><span class="lineNum">    2725</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2726"><span class="lineNum">    2726</span>              :          *</span>
<span id="L2727"><span class="lineNum">    2727</span>              :          * Configure TKIP countermeasures. When these are enabled, the driver</span>
<span id="L2728"><span class="lineNum">    2728</span>              :          * should drop all received and queued frames that are using TKIP.</span>
<span id="L2729"><span class="lineNum">    2729</span>              :          */</span>
<span id="L2730"><span class="lineNum">    2730</span>              :         int (*set_countermeasures)(void *priv, int enabled);</span>
<span id="L2731"><span class="lineNum">    2731</span>              : </span>
<span id="L2732"><span class="lineNum">    2732</span>              :         /**</span>
<span id="L2733"><span class="lineNum">    2733</span>              :          * deauthenticate - Request driver to deauthenticate</span>
<span id="L2734"><span class="lineNum">    2734</span>              :          * @priv: private driver interface data</span>
<span id="L2735"><span class="lineNum">    2735</span>              :          * @addr: peer address (BSSID of the AP)</span>
<span id="L2736"><span class="lineNum">    2736</span>              :          * @reason_code: 16-bit reason code to be sent in the deauthentication</span>
<span id="L2737"><span class="lineNum">    2737</span>              :          *      frame</span>
<span id="L2738"><span class="lineNum">    2738</span>              :          *</span>
<span id="L2739"><span class="lineNum">    2739</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2740"><span class="lineNum">    2740</span>              :          */</span>
<span id="L2741"><span class="lineNum">    2741</span>              :         int (*deauthenticate)(void *priv, const u8 *addr, u16 reason_code);</span>
<span id="L2742"><span class="lineNum">    2742</span>              : </span>
<span id="L2743"><span class="lineNum">    2743</span>              :         /**</span>
<span id="L2744"><span class="lineNum">    2744</span>              :          * associate - Request driver to associate</span>
<span id="L2745"><span class="lineNum">    2745</span>              :          * @priv: private driver interface data</span>
<span id="L2746"><span class="lineNum">    2746</span>              :          * @params: association parameters</span>
<span id="L2747"><span class="lineNum">    2747</span>              :          *</span>
<span id="L2748"><span class="lineNum">    2748</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2749"><span class="lineNum">    2749</span>              :          */</span>
<span id="L2750"><span class="lineNum">    2750</span>              :         int (*associate)(void *priv,</span>
<span id="L2751"><span class="lineNum">    2751</span>              :                          struct wpa_driver_associate_params *params);</span>
<span id="L2752"><span class="lineNum">    2752</span>              : </span>
<span id="L2753"><span class="lineNum">    2753</span>              :         /**</span>
<span id="L2754"><span class="lineNum">    2754</span>              :          * add_pmkid - Add PMKSA cache entry to the driver</span>
<span id="L2755"><span class="lineNum">    2755</span>              :          * @priv: private driver interface data</span>
<span id="L2756"><span class="lineNum">    2756</span>              :          * @params: PMKSA parameters</span>
<span id="L2757"><span class="lineNum">    2757</span>              :          *</span>
<span id="L2758"><span class="lineNum">    2758</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2759"><span class="lineNum">    2759</span>              :          *</span>
<span id="L2760"><span class="lineNum">    2760</span>              :          * This function is called when a new PMK is received, as a result of</span>
<span id="L2761"><span class="lineNum">    2761</span>              :          * either normal authentication or RSN pre-authentication. The PMKSA</span>
<span id="L2762"><span class="lineNum">    2762</span>              :          * parameters are either a set of bssid, pmkid, and pmk; or a set of</span>
<span id="L2763"><span class="lineNum">    2763</span>              :          * ssid, fils_cache_id, pmkid, and pmk.</span>
<span id="L2764"><span class="lineNum">    2764</span>              :          *</span>
<span id="L2765"><span class="lineNum">    2765</span>              :          * If the driver generates RSN IE, i.e., it does not use wpa_ie in</span>
<span id="L2766"><span class="lineNum">    2766</span>              :          * associate(), add_pmkid() can be used to add new PMKSA cache entries</span>
<span id="L2767"><span class="lineNum">    2767</span>              :          * in the driver. If the driver uses wpa_ie from wpa_supplicant, this</span>
<span id="L2768"><span class="lineNum">    2768</span>              :          * driver_ops function does not need to be implemented. Likewise, if</span>
<span id="L2769"><span class="lineNum">    2769</span>              :          * the driver does not support WPA, this function is not needed.</span>
<span id="L2770"><span class="lineNum">    2770</span>              :          */</span>
<span id="L2771"><span class="lineNum">    2771</span>              :         int (*add_pmkid)(void *priv, struct wpa_pmkid_params *params);</span>
<span id="L2772"><span class="lineNum">    2772</span>              : </span>
<span id="L2773"><span class="lineNum">    2773</span>              :         /**</span>
<span id="L2774"><span class="lineNum">    2774</span>              :          * remove_pmkid - Remove PMKSA cache entry to the driver</span>
<span id="L2775"><span class="lineNum">    2775</span>              :          * @priv: private driver interface data</span>
<span id="L2776"><span class="lineNum">    2776</span>              :          * @params: PMKSA parameters</span>
<span id="L2777"><span class="lineNum">    2777</span>              :          *</span>
<span id="L2778"><span class="lineNum">    2778</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2779"><span class="lineNum">    2779</span>              :          *</span>
<span id="L2780"><span class="lineNum">    2780</span>              :          * This function is called when the supplicant drops a PMKSA cache</span>
<span id="L2781"><span class="lineNum">    2781</span>              :          * entry for any reason. The PMKSA parameters are either a set of</span>
<span id="L2782"><span class="lineNum">    2782</span>              :          * bssid and pmkid; or a set of ssid, fils_cache_id, and pmkid.</span>
<span id="L2783"><span class="lineNum">    2783</span>              :          *</span>
<span id="L2784"><span class="lineNum">    2784</span>              :          * If the driver generates RSN IE, i.e., it does not use wpa_ie in</span>
<span id="L2785"><span class="lineNum">    2785</span>              :          * associate(), remove_pmkid() can be used to synchronize PMKSA caches</span>
<span id="L2786"><span class="lineNum">    2786</span>              :          * between the driver and wpa_supplicant. If the driver uses wpa_ie</span>
<span id="L2787"><span class="lineNum">    2787</span>              :          * from wpa_supplicant, this driver_ops function does not need to be</span>
<span id="L2788"><span class="lineNum">    2788</span>              :          * implemented. Likewise, if the driver does not support WPA, this</span>
<span id="L2789"><span class="lineNum">    2789</span>              :          * function is not needed.</span>
<span id="L2790"><span class="lineNum">    2790</span>              :          */</span>
<span id="L2791"><span class="lineNum">    2791</span>              :         int (*remove_pmkid)(void *priv, struct wpa_pmkid_params *params);</span>
<span id="L2792"><span class="lineNum">    2792</span>              : </span>
<span id="L2793"><span class="lineNum">    2793</span>              :         /**</span>
<span id="L2794"><span class="lineNum">    2794</span>              :          * flush_pmkid - Flush PMKSA cache</span>
<span id="L2795"><span class="lineNum">    2795</span>              :          * @priv: private driver interface data</span>
<span id="L2796"><span class="lineNum">    2796</span>              :          *</span>
<span id="L2797"><span class="lineNum">    2797</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2798"><span class="lineNum">    2798</span>              :          *</span>
<span id="L2799"><span class="lineNum">    2799</span>              :          * This function is called when the supplicant drops all PMKSA cache</span>
<span id="L2800"><span class="lineNum">    2800</span>              :          * entries for any reason.</span>
<span id="L2801"><span class="lineNum">    2801</span>              :          *</span>
<span id="L2802"><span class="lineNum">    2802</span>              :          * If the driver generates RSN IE, i.e., it does not use wpa_ie in</span>
<span id="L2803"><span class="lineNum">    2803</span>              :          * associate(), remove_pmkid() can be used to synchronize PMKSA caches</span>
<span id="L2804"><span class="lineNum">    2804</span>              :          * between the driver and wpa_supplicant. If the driver uses wpa_ie</span>
<span id="L2805"><span class="lineNum">    2805</span>              :          * from wpa_supplicant, this driver_ops function does not need to be</span>
<span id="L2806"><span class="lineNum">    2806</span>              :          * implemented. Likewise, if the driver does not support WPA, this</span>
<span id="L2807"><span class="lineNum">    2807</span>              :          * function is not needed.</span>
<span id="L2808"><span class="lineNum">    2808</span>              :          */</span>
<span id="L2809"><span class="lineNum">    2809</span>              :         int (*flush_pmkid)(void *priv);</span>
<span id="L2810"><span class="lineNum">    2810</span>              : </span>
<span id="L2811"><span class="lineNum">    2811</span>              :         /**</span>
<span id="L2812"><span class="lineNum">    2812</span>              :          * get_capa - Get driver capabilities</span>
<span id="L2813"><span class="lineNum">    2813</span>              :          * @priv: private driver interface data</span>
<span id="L2814"><span class="lineNum">    2814</span>              :          *</span>
<span id="L2815"><span class="lineNum">    2815</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2816"><span class="lineNum">    2816</span>              :          *</span>
<span id="L2817"><span class="lineNum">    2817</span>              :          * Get driver/firmware/hardware capabilities.</span>
<span id="L2818"><span class="lineNum">    2818</span>              :          */</span>
<span id="L2819"><span class="lineNum">    2819</span>              :         int (*get_capa)(void *priv, struct wpa_driver_capa *capa);</span>
<span id="L2820"><span class="lineNum">    2820</span>              : </span>
<span id="L2821"><span class="lineNum">    2821</span>              :         /**</span>
<span id="L2822"><span class="lineNum">    2822</span>              :          * poll - Poll driver for association information</span>
<span id="L2823"><span class="lineNum">    2823</span>              :          * @priv: private driver interface data</span>
<span id="L2824"><span class="lineNum">    2824</span>              :          *</span>
<span id="L2825"><span class="lineNum">    2825</span>              :          * This is an option callback that can be used when the driver does not</span>
<span id="L2826"><span class="lineNum">    2826</span>              :          * provide event mechanism for association events. This is called when</span>
<span id="L2827"><span class="lineNum">    2827</span>              :          * receiving WPA EAPOL-Key messages that require association</span>
<span id="L2828"><span class="lineNum">    2828</span>              :          * information. The driver interface is supposed to generate associnfo</span>
<span id="L2829"><span class="lineNum">    2829</span>              :          * event before returning from this callback function. In addition, the</span>
<span id="L2830"><span class="lineNum">    2830</span>              :          * driver interface should generate an association event after having</span>
<span id="L2831"><span class="lineNum">    2831</span>              :          * sent out associnfo.</span>
<span id="L2832"><span class="lineNum">    2832</span>              :          */</span>
<span id="L2833"><span class="lineNum">    2833</span>              :         void (*poll)(void *priv);</span>
<span id="L2834"><span class="lineNum">    2834</span>              : </span>
<span id="L2835"><span class="lineNum">    2835</span>              :         /**</span>
<span id="L2836"><span class="lineNum">    2836</span>              :          * get_ifindex - Get interface index</span>
<span id="L2837"><span class="lineNum">    2837</span>              :          * @priv: private driver interface data</span>
<span id="L2838"><span class="lineNum">    2838</span>              :          *</span>
<span id="L2839"><span class="lineNum">    2839</span>              :          * Returns: Interface index</span>
<span id="L2840"><span class="lineNum">    2840</span>              :          */</span>
<span id="L2841"><span class="lineNum">    2841</span>              :         unsigned int (*get_ifindex)(void *priv);</span>
<span id="L2842"><span class="lineNum">    2842</span>              : </span>
<span id="L2843"><span class="lineNum">    2843</span>              :         /**</span>
<span id="L2844"><span class="lineNum">    2844</span>              :          * get_ifname - Get interface name</span>
<span id="L2845"><span class="lineNum">    2845</span>              :          * @priv: private driver interface data</span>
<span id="L2846"><span class="lineNum">    2846</span>              :          *</span>
<span id="L2847"><span class="lineNum">    2847</span>              :          * Returns: Pointer to the interface name. This can differ from the</span>
<span id="L2848"><span class="lineNum">    2848</span>              :          * interface name used in init() call. Init() is called first.</span>
<span id="L2849"><span class="lineNum">    2849</span>              :          *</span>
<span id="L2850"><span class="lineNum">    2850</span>              :          * This optional function can be used to allow the driver interface to</span>
<span id="L2851"><span class="lineNum">    2851</span>              :          * replace the interface name with something else, e.g., based on an</span>
<span id="L2852"><span class="lineNum">    2852</span>              :          * interface mapping from a more descriptive name.</span>
<span id="L2853"><span class="lineNum">    2853</span>              :          */</span>
<span id="L2854"><span class="lineNum">    2854</span>              :         const char * (*get_ifname)(void *priv);</span>
<span id="L2855"><span class="lineNum">    2855</span>              : </span>
<span id="L2856"><span class="lineNum">    2856</span>              :         /**</span>
<span id="L2857"><span class="lineNum">    2857</span>              :          * get_mac_addr - Get own MAC address</span>
<span id="L2858"><span class="lineNum">    2858</span>              :          * @priv: private driver interface data</span>
<span id="L2859"><span class="lineNum">    2859</span>              :          *</span>
<span id="L2860"><span class="lineNum">    2860</span>              :          * Returns: Pointer to own MAC address or %NULL on failure</span>
<span id="L2861"><span class="lineNum">    2861</span>              :          *</span>
<span id="L2862"><span class="lineNum">    2862</span>              :          * This optional function can be used to get the own MAC address of the</span>
<span id="L2863"><span class="lineNum">    2863</span>              :          * device from the driver interface code. This is only needed if the</span>
<span id="L2864"><span class="lineNum">    2864</span>              :          * l2_packet implementation for the OS does not provide easy access to</span>
<span id="L2865"><span class="lineNum">    2865</span>              :          * a MAC address. */</span>
<span id="L2866"><span class="lineNum">    2866</span>              :         const u8 * (*get_mac_addr)(void *priv);</span>
<span id="L2867"><span class="lineNum">    2867</span>              : </span>
<span id="L2868"><span class="lineNum">    2868</span>              :         /**</span>
<span id="L2869"><span class="lineNum">    2869</span>              :          * set_operstate - Sets device operating state to DORMANT or UP</span>
<span id="L2870"><span class="lineNum">    2870</span>              :          * @priv: private driver interface data</span>
<span id="L2871"><span class="lineNum">    2871</span>              :          * @state: 0 = dormant, 1 = up</span>
<span id="L2872"><span class="lineNum">    2872</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2873"><span class="lineNum">    2873</span>              :          *</span>
<span id="L2874"><span class="lineNum">    2874</span>              :          * This is an optional function that can be used on operating systems</span>
<span id="L2875"><span class="lineNum">    2875</span>              :          * that support a concept of controlling network device state from user</span>
<span id="L2876"><span class="lineNum">    2876</span>              :          * space applications. This function, if set, gets called with</span>
<span id="L2877"><span class="lineNum">    2877</span>              :          * state = 1 when authentication has been completed and with state = 0</span>
<span id="L2878"><span class="lineNum">    2878</span>              :          * when connection is lost.</span>
<span id="L2879"><span class="lineNum">    2879</span>              :          */</span>
<span id="L2880"><span class="lineNum">    2880</span>              :         int (*set_operstate)(void *priv, int state);</span>
<span id="L2881"><span class="lineNum">    2881</span>              : </span>
<span id="L2882"><span class="lineNum">    2882</span>              :         /**</span>
<span id="L2883"><span class="lineNum">    2883</span>              :          * mlme_setprotection - MLME-SETPROTECTION.request primitive</span>
<span id="L2884"><span class="lineNum">    2884</span>              :          * @priv: Private driver interface data</span>
<span id="L2885"><span class="lineNum">    2885</span>              :          * @addr: Address of the station for which to set protection (may be</span>
<span id="L2886"><span class="lineNum">    2886</span>              :          * %NULL for group keys)</span>
<span id="L2887"><span class="lineNum">    2887</span>              :          * @protect_type: MLME_SETPROTECTION_PROTECT_TYPE_*</span>
<span id="L2888"><span class="lineNum">    2888</span>              :          * @key_type: MLME_SETPROTECTION_KEY_TYPE_*</span>
<span id="L2889"><span class="lineNum">    2889</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2890"><span class="lineNum">    2890</span>              :          *</span>
<span id="L2891"><span class="lineNum">    2891</span>              :          * This is an optional function that can be used to set the driver to</span>
<span id="L2892"><span class="lineNum">    2892</span>              :          * require protection for Tx and/or Rx frames. This uses the layer</span>
<span id="L2893"><span class="lineNum">    2893</span>              :          * interface defined in IEEE 802.11i-2004 clause 10.3.22.1</span>
<span id="L2894"><span class="lineNum">    2894</span>              :          * (MLME-SETPROTECTION.request). Many drivers do not use explicit</span>
<span id="L2895"><span class="lineNum">    2895</span>              :          * set protection operation; instead, they set protection implicitly</span>
<span id="L2896"><span class="lineNum">    2896</span>              :          * based on configured keys.</span>
<span id="L2897"><span class="lineNum">    2897</span>              :          */</span>
<span id="L2898"><span class="lineNum">    2898</span>              :         int (*mlme_setprotection)(void *priv, const u8 *addr, int protect_type,</span>
<span id="L2899"><span class="lineNum">    2899</span>              :                                   int key_type);</span>
<span id="L2900"><span class="lineNum">    2900</span>              : </span>
<span id="L2901"><span class="lineNum">    2901</span>              :         /**</span>
<span id="L2902"><span class="lineNum">    2902</span>              :          * get_hw_feature_data - Get hardware support data (channels and rates)</span>
<span id="L2903"><span class="lineNum">    2903</span>              :          * @priv: Private driver interface data</span>
<span id="L2904"><span class="lineNum">    2904</span>              :          * @num_modes: Variable for returning the number of returned modes</span>
<span id="L2905"><span class="lineNum">    2905</span>              :          * flags: Variable for returning hardware feature flags</span>
<span id="L2906"><span class="lineNum">    2906</span>              :          * @dfs: Variable for returning DFS region (HOSTAPD_DFS_REGION_*)</span>
<span id="L2907"><span class="lineNum">    2907</span>              :          * Returns: Pointer to allocated hardware data on success or %NULL on</span>
<span id="L2908"><span class="lineNum">    2908</span>              :          * failure. Caller is responsible for freeing this.</span>
<span id="L2909"><span class="lineNum">    2909</span>              :          */</span>
<span id="L2910"><span class="lineNum">    2910</span>              :         struct hostapd_hw_modes * (*get_hw_feature_data)(void *priv,</span>
<span id="L2911"><span class="lineNum">    2911</span>              :                                                          u16 *num_modes,</span>
<span id="L2912"><span class="lineNum">    2912</span>              :                                                          u16 *flags, u8 *dfs);</span>
<span id="L2913"><span class="lineNum">    2913</span>              : </span>
<span id="L2914"><span class="lineNum">    2914</span>              :         /**</span>
<span id="L2915"><span class="lineNum">    2915</span>              :          * send_mlme - Send management frame from MLME</span>
<span id="L2916"><span class="lineNum">    2916</span>              :          * @priv: Private driver interface data</span>
<span id="L2917"><span class="lineNum">    2917</span>              :          * @data: IEEE 802.11 management frame with IEEE 802.11 header</span>
<span id="L2918"><span class="lineNum">    2918</span>              :          * @data_len: Size of the management frame</span>
<span id="L2919"><span class="lineNum">    2919</span>              :          * @noack: Do not wait for this frame to be acked (disable retries)</span>
<span id="L2920"><span class="lineNum">    2920</span>              :          * @freq: Frequency (in MHz) to send the frame on, or 0 to let the</span>
<span id="L2921"><span class="lineNum">    2921</span>              :          * driver decide</span>
<span id="L2922"><span class="lineNum">    2922</span>              :          * @csa_offs: Array of CSA offsets or %NULL</span>
<span id="L2923"><span class="lineNum">    2923</span>              :          * @csa_offs_len: Number of elements in csa_offs</span>
<span id="L2924"><span class="lineNum">    2924</span>              :          * @no_encrypt: Do not encrypt frame even if appropriate key exists</span>
<span id="L2925"><span class="lineNum">    2925</span>              :          *      (used only for testing purposes)</span>
<span id="L2926"><span class="lineNum">    2926</span>              :          * @wait: Time to wait off-channel for a response (in ms), or zero</span>
<span id="L2927"><span class="lineNum">    2927</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2928"><span class="lineNum">    2928</span>              :          */</span>
<span id="L2929"><span class="lineNum">    2929</span>              :         int (*send_mlme)(void *priv, const u8 *data, size_t data_len,</span>
<span id="L2930"><span class="lineNum">    2930</span>              :                          int noack, unsigned int freq, const u16 *csa_offs,</span>
<span id="L2931"><span class="lineNum">    2931</span>              :                          size_t csa_offs_len, int no_encrypt,</span>
<span id="L2932"><span class="lineNum">    2932</span>              :                          unsigned int wait);</span>
<span id="L2933"><span class="lineNum">    2933</span>              : </span>
<span id="L2934"><span class="lineNum">    2934</span>              :         /**</span>
<span id="L2935"><span class="lineNum">    2935</span>              :          * update_ft_ies - Update FT (IEEE 802.11r) IEs</span>
<span id="L2936"><span class="lineNum">    2936</span>              :          * @priv: Private driver interface data</span>
<span id="L2937"><span class="lineNum">    2937</span>              :          * @md: Mobility domain (2 octets) (also included inside ies)</span>
<span id="L2938"><span class="lineNum">    2938</span>              :          * @ies: FT IEs (MDIE, FTIE, ...) or %NULL to remove IEs</span>
<span id="L2939"><span class="lineNum">    2939</span>              :          * @ies_len: Length of FT IEs in bytes</span>
<span id="L2940"><span class="lineNum">    2940</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2941"><span class="lineNum">    2941</span>              :          *</span>
<span id="L2942"><span class="lineNum">    2942</span>              :          * The supplicant uses this callback to let the driver know that keying</span>
<span id="L2943"><span class="lineNum">    2943</span>              :          * material for FT is available and that the driver can use the</span>
<span id="L2944"><span class="lineNum">    2944</span>              :          * provided IEs in the next message in FT authentication sequence.</span>
<span id="L2945"><span class="lineNum">    2945</span>              :          *</span>
<span id="L2946"><span class="lineNum">    2946</span>              :          * This function is only needed for driver that support IEEE 802.11r</span>
<span id="L2947"><span class="lineNum">    2947</span>              :          * (Fast BSS Transition).</span>
<span id="L2948"><span class="lineNum">    2948</span>              :          */</span>
<span id="L2949"><span class="lineNum">    2949</span>              :         int (*update_ft_ies)(void *priv, const u8 *md, const u8 *ies,</span>
<span id="L2950"><span class="lineNum">    2950</span>              :                              size_t ies_len);</span>
<span id="L2951"><span class="lineNum">    2951</span>              : </span>
<span id="L2952"><span class="lineNum">    2952</span>              :         /**</span>
<span id="L2953"><span class="lineNum">    2953</span>              :          * get_scan_results2 - Fetch the latest scan results</span>
<span id="L2954"><span class="lineNum">    2954</span>              :          * @priv: private driver interface data</span>
<span id="L2955"><span class="lineNum">    2955</span>              :          *</span>
<span id="L2956"><span class="lineNum">    2956</span>              :          * Returns: Allocated buffer of scan results (caller is responsible for</span>
<span id="L2957"><span class="lineNum">    2957</span>              :          * freeing the data structure) on success, NULL on failure</span>
<span id="L2958"><span class="lineNum">    2958</span>              :          */</span>
<span id="L2959"><span class="lineNum">    2959</span>              :          struct wpa_scan_results * (*get_scan_results2)(void *priv);</span>
<span id="L2960"><span class="lineNum">    2960</span>              : </span>
<span id="L2961"><span class="lineNum">    2961</span>              :         /**</span>
<span id="L2962"><span class="lineNum">    2962</span>              :          * set_country - Set country</span>
<span id="L2963"><span class="lineNum">    2963</span>              :          * @priv: Private driver interface data</span>
<span id="L2964"><span class="lineNum">    2964</span>              :          * @alpha2: country to which to switch to</span>
<span id="L2965"><span class="lineNum">    2965</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2966"><span class="lineNum">    2966</span>              :          *</span>
<span id="L2967"><span class="lineNum">    2967</span>              :          * This function is for drivers which support some form</span>
<span id="L2968"><span class="lineNum">    2968</span>              :          * of setting a regulatory domain.</span>
<span id="L2969"><span class="lineNum">    2969</span>              :          */</span>
<span id="L2970"><span class="lineNum">    2970</span>              :         int (*set_country)(void *priv, const char *alpha2);</span>
<span id="L2971"><span class="lineNum">    2971</span>              : </span>
<span id="L2972"><span class="lineNum">    2972</span>              :         /**</span>
<span id="L2973"><span class="lineNum">    2973</span>              :          * get_country - Get country</span>
<span id="L2974"><span class="lineNum">    2974</span>              :          * @priv: Private driver interface data</span>
<span id="L2975"><span class="lineNum">    2975</span>              :          * @alpha2: Buffer for returning country code (at least 3 octets)</span>
<span id="L2976"><span class="lineNum">    2976</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L2977"><span class="lineNum">    2977</span>              :          */</span>
<span id="L2978"><span class="lineNum">    2978</span>              :         int (*get_country)(void *priv, char *alpha2);</span>
<span id="L2979"><span class="lineNum">    2979</span>              : </span>
<span id="L2980"><span class="lineNum">    2980</span>              :         /**</span>
<span id="L2981"><span class="lineNum">    2981</span>              :          * global_init - Global driver initialization</span>
<span id="L2982"><span class="lineNum">    2982</span>              :          * @ctx: wpa_global pointer</span>
<span id="L2983"><span class="lineNum">    2983</span>              :          * Returns: Pointer to private data (global), %NULL on failure</span>
<span id="L2984"><span class="lineNum">    2984</span>              :          *</span>
<span id="L2985"><span class="lineNum">    2985</span>              :          * This optional function is called to initialize the driver wrapper</span>
<span id="L2986"><span class="lineNum">    2986</span>              :          * for global data, i.e., data that applies to all interfaces. If this</span>
<span id="L2987"><span class="lineNum">    2987</span>              :          * function is implemented, global_deinit() will also need to be</span>
<span id="L2988"><span class="lineNum">    2988</span>              :          * implemented to free the private data. The driver will also likely</span>
<span id="L2989"><span class="lineNum">    2989</span>              :          * use init2() function instead of init() to get the pointer to global</span>
<span id="L2990"><span class="lineNum">    2990</span>              :          * data available to per-interface initializer.</span>
<span id="L2991"><span class="lineNum">    2991</span>              :          */</span>
<span id="L2992"><span class="lineNum">    2992</span>              :         void * (*global_init)(void *ctx);</span>
<span id="L2993"><span class="lineNum">    2993</span>              : </span>
<span id="L2994"><span class="lineNum">    2994</span>              :         /**</span>
<span id="L2995"><span class="lineNum">    2995</span>              :          * global_deinit - Global driver deinitialization</span>
<span id="L2996"><span class="lineNum">    2996</span>              :          * @priv: private driver global data from global_init()</span>
<span id="L2997"><span class="lineNum">    2997</span>              :          *</span>
<span id="L2998"><span class="lineNum">    2998</span>              :          * Terminate any global driver related functionality and free the</span>
<span id="L2999"><span class="lineNum">    2999</span>              :          * global data structure.</span>
<span id="L3000"><span class="lineNum">    3000</span>              :          */</span>
<span id="L3001"><span class="lineNum">    3001</span>              :         void (*global_deinit)(void *priv);</span>
<span id="L3002"><span class="lineNum">    3002</span>              : </span>
<span id="L3003"><span class="lineNum">    3003</span>              :         /**</span>
<span id="L3004"><span class="lineNum">    3004</span>              :          * init2 - Initialize driver interface (with global data)</span>
<span id="L3005"><span class="lineNum">    3005</span>              :          * @ctx: context to be used when calling wpa_supplicant functions,</span>
<span id="L3006"><span class="lineNum">    3006</span>              :          * e.g., wpa_supplicant_event()</span>
<span id="L3007"><span class="lineNum">    3007</span>              :          * @ifname: interface name, e.g., wlan0</span>
<span id="L3008"><span class="lineNum">    3008</span>              :          * @global_priv: private driver global data from global_init()</span>
<span id="L3009"><span class="lineNum">    3009</span>              :          * Returns: Pointer to private data, %NULL on failure</span>
<span id="L3010"><span class="lineNum">    3010</span>              :          *</span>
<span id="L3011"><span class="lineNum">    3011</span>              :          * This function can be used instead of init() if the driver wrapper</span>
<span id="L3012"><span class="lineNum">    3012</span>              :          * uses global data.</span>
<span id="L3013"><span class="lineNum">    3013</span>              :          */</span>
<span id="L3014"><span class="lineNum">    3014</span>              :         void * (*init2)(void *ctx, const char *ifname, void *global_priv);</span>
<span id="L3015"><span class="lineNum">    3015</span>              : </span>
<span id="L3016"><span class="lineNum">    3016</span>              :         /**</span>
<span id="L3017"><span class="lineNum">    3017</span>              :          * get_interfaces - Get information about available interfaces</span>
<span id="L3018"><span class="lineNum">    3018</span>              :          * @global_priv: private driver global data from global_init()</span>
<span id="L3019"><span class="lineNum">    3019</span>              :          * Returns: Allocated buffer of interface information (caller is</span>
<span id="L3020"><span class="lineNum">    3020</span>              :          * responsible for freeing the data structure) on success, NULL on</span>
<span id="L3021"><span class="lineNum">    3021</span>              :          * failure</span>
<span id="L3022"><span class="lineNum">    3022</span>              :          */</span>
<span id="L3023"><span class="lineNum">    3023</span>              :         struct wpa_interface_info * (*get_interfaces)(void *global_priv);</span>
<span id="L3024"><span class="lineNum">    3024</span>              : </span>
<span id="L3025"><span class="lineNum">    3025</span>              :         /**</span>
<span id="L3026"><span class="lineNum">    3026</span>              :          * scan2 - Request the driver to initiate scan</span>
<span id="L3027"><span class="lineNum">    3027</span>              :          * @priv: private driver interface data</span>
<span id="L3028"><span class="lineNum">    3028</span>              :          * @params: Scan parameters</span>
<span id="L3029"><span class="lineNum">    3029</span>              :          *</span>
<span id="L3030"><span class="lineNum">    3030</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3031"><span class="lineNum">    3031</span>              :          *</span>
<span id="L3032"><span class="lineNum">    3032</span>              :          * Once the scan results are ready, the driver should report scan</span>
<span id="L3033"><span class="lineNum">    3033</span>              :          * results event for wpa_supplicant which will eventually request the</span>
<span id="L3034"><span class="lineNum">    3034</span>              :          * results with wpa_driver_get_scan_results2().</span>
<span id="L3035"><span class="lineNum">    3035</span>              :          */</span>
<span id="L3036"><span class="lineNum">    3036</span>              :         int (*scan2)(void *priv, struct wpa_driver_scan_params *params);</span>
<span id="L3037"><span class="lineNum">    3037</span>              : </span>
<span id="L3038"><span class="lineNum">    3038</span>              :         /**</span>
<span id="L3039"><span class="lineNum">    3039</span>              :          * authenticate - Request driver to authenticate</span>
<span id="L3040"><span class="lineNum">    3040</span>              :          * @priv: private driver interface data</span>
<span id="L3041"><span class="lineNum">    3041</span>              :          * @params: authentication parameters</span>
<span id="L3042"><span class="lineNum">    3042</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3043"><span class="lineNum">    3043</span>              :          *</span>
<span id="L3044"><span class="lineNum">    3044</span>              :          * This is an optional function that can be used with drivers that</span>
<span id="L3045"><span class="lineNum">    3045</span>              :          * support separate authentication and association steps, i.e., when</span>
<span id="L3046"><span class="lineNum">    3046</span>              :          * wpa_supplicant can act as the SME. If not implemented, associate()</span>
<span id="L3047"><span class="lineNum">    3047</span>              :          * function is expected to take care of IEEE 802.11 authentication,</span>
<span id="L3048"><span class="lineNum">    3048</span>              :          * too.</span>
<span id="L3049"><span class="lineNum">    3049</span>              :          */</span>
<span id="L3050"><span class="lineNum">    3050</span>              :         int (*authenticate)(void *priv,</span>
<span id="L3051"><span class="lineNum">    3051</span>              :                             struct wpa_driver_auth_params *params);</span>
<span id="L3052"><span class="lineNum">    3052</span>              : </span>
<span id="L3053"><span class="lineNum">    3053</span>              :         /**</span>
<span id="L3054"><span class="lineNum">    3054</span>              :          * set_ap - Set Beacon and Probe Response information for AP mode</span>
<span id="L3055"><span class="lineNum">    3055</span>              :          * @priv: Private driver interface data</span>
<span id="L3056"><span class="lineNum">    3056</span>              :          * @params: Parameters to use in AP mode</span>
<span id="L3057"><span class="lineNum">    3057</span>              :          *</span>
<span id="L3058"><span class="lineNum">    3058</span>              :          * This function is used to configure Beacon template and/or extra IEs</span>
<span id="L3059"><span class="lineNum">    3059</span>              :          * to add for Beacon and Probe Response frames for the driver in</span>
<span id="L3060"><span class="lineNum">    3060</span>              :          * AP mode. The driver is responsible for building the full Beacon</span>
<span id="L3061"><span class="lineNum">    3061</span>              :          * frame by concatenating the head part with TIM IE generated by the</span>
<span id="L3062"><span class="lineNum">    3062</span>              :          * driver/firmware and finishing with the tail part. Depending on the</span>
<span id="L3063"><span class="lineNum">    3063</span>              :          * driver architectue, this can be done either by using the full</span>
<span id="L3064"><span class="lineNum">    3064</span>              :          * template or the set of additional IEs (e.g., WPS and P2P IE).</span>
<span id="L3065"><span class="lineNum">    3065</span>              :          * Similarly, Probe Response processing depends on the driver design.</span>
<span id="L3066"><span class="lineNum">    3066</span>              :          * If the driver (or firmware) takes care of replying to Probe Request</span>
<span id="L3067"><span class="lineNum">    3067</span>              :          * frames, the extra IEs provided here needs to be added to the Probe</span>
<span id="L3068"><span class="lineNum">    3068</span>              :          * Response frames.</span>
<span id="L3069"><span class="lineNum">    3069</span>              :          *</span>
<span id="L3070"><span class="lineNum">    3070</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3071"><span class="lineNum">    3071</span>              :          */</span>
<span id="L3072"><span class="lineNum">    3072</span>              :         int (*set_ap)(void *priv, struct wpa_driver_ap_params *params);</span>
<span id="L3073"><span class="lineNum">    3073</span>              : </span>
<span id="L3074"><span class="lineNum">    3074</span>              :         /**</span>
<span id="L3075"><span class="lineNum">    3075</span>              :          * set_acl - Set ACL in AP mode</span>
<span id="L3076"><span class="lineNum">    3076</span>              :          * @priv: Private driver interface data</span>
<span id="L3077"><span class="lineNum">    3077</span>              :          * @params: Parameters to configure ACL</span>
<span id="L3078"><span class="lineNum">    3078</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3079"><span class="lineNum">    3079</span>              :          *</span>
<span id="L3080"><span class="lineNum">    3080</span>              :          * This is used only for the drivers which support MAC address ACL.</span>
<span id="L3081"><span class="lineNum">    3081</span>              :          */</span>
<span id="L3082"><span class="lineNum">    3082</span>              :         int (*set_acl)(void *priv, struct hostapd_acl_params *params);</span>
<span id="L3083"><span class="lineNum">    3083</span>              : </span>
<span id="L3084"><span class="lineNum">    3084</span>              :         /**</span>
<span id="L3085"><span class="lineNum">    3085</span>              :          * hapd_init - Initialize driver interface (hostapd only)</span>
<span id="L3086"><span class="lineNum">    3086</span>              :          * @hapd: Pointer to hostapd context</span>
<span id="L3087"><span class="lineNum">    3087</span>              :          * @params: Configuration for the driver wrapper</span>
<span id="L3088"><span class="lineNum">    3088</span>              :          * Returns: Pointer to private data, %NULL on failure</span>
<span id="L3089"><span class="lineNum">    3089</span>              :          *</span>
<span id="L3090"><span class="lineNum">    3090</span>              :          * This function is used instead of init() or init2() when the driver</span>
<span id="L3091"><span class="lineNum">    3091</span>              :          * wrapper is used with hostapd.</span>
<span id="L3092"><span class="lineNum">    3092</span>              :          */</span>
<span id="L3093"><span class="lineNum">    3093</span>              :         void * (*hapd_init)(struct hostapd_data *hapd,</span>
<span id="L3094"><span class="lineNum">    3094</span>              :                             struct wpa_init_params *params);</span>
<span id="L3095"><span class="lineNum">    3095</span>              : </span>
<span id="L3096"><span class="lineNum">    3096</span>              :         /**</span>
<span id="L3097"><span class="lineNum">    3097</span>              :          * hapd_deinit - Deinitialize driver interface (hostapd only)</span>
<span id="L3098"><span class="lineNum">    3098</span>              :          * @priv: Private driver interface data from hapd_init()</span>
<span id="L3099"><span class="lineNum">    3099</span>              :          */</span>
<span id="L3100"><span class="lineNum">    3100</span>              :         void (*hapd_deinit)(void *priv);</span>
<span id="L3101"><span class="lineNum">    3101</span>              : </span>
<span id="L3102"><span class="lineNum">    3102</span>              :         /**</span>
<span id="L3103"><span class="lineNum">    3103</span>              :          * set_ieee8021x - Enable/disable IEEE 802.1X support (AP only)</span>
<span id="L3104"><span class="lineNum">    3104</span>              :          * @priv: Private driver interface data</span>
<span id="L3105"><span class="lineNum">    3105</span>              :          * @params: BSS parameters</span>
<span id="L3106"><span class="lineNum">    3106</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3107"><span class="lineNum">    3107</span>              :          *</span>
<span id="L3108"><span class="lineNum">    3108</span>              :          * This is an optional function to configure the kernel driver to</span>
<span id="L3109"><span class="lineNum">    3109</span>              :          * enable/disable IEEE 802.1X support and set WPA/WPA2 parameters. This</span>
<span id="L3110"><span class="lineNum">    3110</span>              :          * can be left undefined (set to %NULL) if IEEE 802.1X support is</span>
<span id="L3111"><span class="lineNum">    3111</span>              :          * always enabled and the driver uses set_ap() to set WPA/RSN IE</span>
<span id="L3112"><span class="lineNum">    3112</span>              :          * for Beacon frames.</span>
<span id="L3113"><span class="lineNum">    3113</span>              :          *</span>
<span id="L3114"><span class="lineNum">    3114</span>              :          * DEPRECATED - use set_ap() instead</span>
<span id="L3115"><span class="lineNum">    3115</span>              :          */</span>
<span id="L3116"><span class="lineNum">    3116</span>              :         int (*set_ieee8021x)(void *priv, struct wpa_bss_params *params);</span>
<span id="L3117"><span class="lineNum">    3117</span>              : </span>
<span id="L3118"><span class="lineNum">    3118</span>              :         /**</span>
<span id="L3119"><span class="lineNum">    3119</span>              :          * set_privacy - Enable/disable privacy (AP only)</span>
<span id="L3120"><span class="lineNum">    3120</span>              :          * @priv: Private driver interface data</span>
<span id="L3121"><span class="lineNum">    3121</span>              :          * @enabled: 1 = privacy enabled, 0 = disabled</span>
<span id="L3122"><span class="lineNum">    3122</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3123"><span class="lineNum">    3123</span>              :          *</span>
<span id="L3124"><span class="lineNum">    3124</span>              :          * This is an optional function to configure privacy field in the</span>
<span id="L3125"><span class="lineNum">    3125</span>              :          * kernel driver for Beacon frames. This can be left undefined (set to</span>
<span id="L3126"><span class="lineNum">    3126</span>              :          * %NULL) if the driver uses the Beacon template from set_ap().</span>
<span id="L3127"><span class="lineNum">    3127</span>              :          *</span>
<span id="L3128"><span class="lineNum">    3128</span>              :          * DEPRECATED - use set_ap() instead</span>
<span id="L3129"><span class="lineNum">    3129</span>              :          */</span>
<span id="L3130"><span class="lineNum">    3130</span>              :         int (*set_privacy)(void *priv, int enabled);</span>
<span id="L3131"><span class="lineNum">    3131</span>              : </span>
<span id="L3132"><span class="lineNum">    3132</span>              :         /**</span>
<span id="L3133"><span class="lineNum">    3133</span>              :          * get_seqnum - Fetch the current TSC/packet number (AP only)</span>
<span id="L3134"><span class="lineNum">    3134</span>              :          * @ifname: The interface name (main or virtual)</span>
<span id="L3135"><span class="lineNum">    3135</span>              :          * @priv: Private driver interface data</span>
<span id="L3136"><span class="lineNum">    3136</span>              :          * @addr: MAC address of the station or %NULL for group keys</span>
<span id="L3137"><span class="lineNum">    3137</span>              :          * @idx: Key index</span>
<span id="L3138"><span class="lineNum">    3138</span>              :          * @seq: Buffer for returning the latest used TSC/packet number</span>
<span id="L3139"><span class="lineNum">    3139</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3140"><span class="lineNum">    3140</span>              :          *</span>
<span id="L3141"><span class="lineNum">    3141</span>              :          * This function is used to fetch the last used TSC/packet number for</span>
<span id="L3142"><span class="lineNum">    3142</span>              :          * a TKIP, CCMP, GCMP, or BIP/IGTK key. It is mainly used with group</span>
<span id="L3143"><span class="lineNum">    3143</span>              :          * keys, so there is no strict requirement on implementing support for</span>
<span id="L3144"><span class="lineNum">    3144</span>              :          * unicast keys (i.e., addr != %NULL).</span>
<span id="L3145"><span class="lineNum">    3145</span>              :          */</span>
<span id="L3146"><span class="lineNum">    3146</span>              :         int (*get_seqnum)(const char *ifname, void *priv, const u8 *addr,</span>
<span id="L3147"><span class="lineNum">    3147</span>              :                           int idx, u8 *seq);</span>
<span id="L3148"><span class="lineNum">    3148</span>              : </span>
<span id="L3149"><span class="lineNum">    3149</span>              :         /**</span>
<span id="L3150"><span class="lineNum">    3150</span>              :          * flush - Flush all association stations (AP only)</span>
<span id="L3151"><span class="lineNum">    3151</span>              :          * @priv: Private driver interface data</span>
<span id="L3152"><span class="lineNum">    3152</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3153"><span class="lineNum">    3153</span>              :          *</span>
<span id="L3154"><span class="lineNum">    3154</span>              :          * This function requests the driver to disassociate all associated</span>
<span id="L3155"><span class="lineNum">    3155</span>              :          * stations. This function does not need to be implemented if the</span>
<span id="L3156"><span class="lineNum">    3156</span>              :          * driver does not process association frames internally.</span>
<span id="L3157"><span class="lineNum">    3157</span>              :          */</span>
<span id="L3158"><span class="lineNum">    3158</span>              :         int (*flush)(void *priv);</span>
<span id="L3159"><span class="lineNum">    3159</span>              : </span>
<span id="L3160"><span class="lineNum">    3160</span>              :         /**</span>
<span id="L3161"><span class="lineNum">    3161</span>              :          * set_generic_elem - Add IEs into Beacon/Probe Response frames (AP)</span>
<span id="L3162"><span class="lineNum">    3162</span>              :          * @priv: Private driver interface data</span>
<span id="L3163"><span class="lineNum">    3163</span>              :          * @elem: Information elements</span>
<span id="L3164"><span class="lineNum">    3164</span>              :          * @elem_len: Length of the elem buffer in octets</span>
<span id="L3165"><span class="lineNum">    3165</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3166"><span class="lineNum">    3166</span>              :          *</span>
<span id="L3167"><span class="lineNum">    3167</span>              :          * This is an optional function to add information elements in the</span>
<span id="L3168"><span class="lineNum">    3168</span>              :          * kernel driver for Beacon and Probe Response frames. This can be left</span>
<span id="L3169"><span class="lineNum">    3169</span>              :          * undefined (set to %NULL) if the driver uses the Beacon template from</span>
<span id="L3170"><span class="lineNum">    3170</span>              :          * set_ap().</span>
<span id="L3171"><span class="lineNum">    3171</span>              :          *</span>
<span id="L3172"><span class="lineNum">    3172</span>              :          * DEPRECATED - use set_ap() instead</span>
<span id="L3173"><span class="lineNum">    3173</span>              :          */</span>
<span id="L3174"><span class="lineNum">    3174</span>              :         int (*set_generic_elem)(void *priv, const u8 *elem, size_t elem_len);</span>
<span id="L3175"><span class="lineNum">    3175</span>              : </span>
<span id="L3176"><span class="lineNum">    3176</span>              :         /**</span>
<span id="L3177"><span class="lineNum">    3177</span>              :          * read_sta_data - Fetch station data</span>
<span id="L3178"><span class="lineNum">    3178</span>              :          * @priv: Private driver interface data</span>
<span id="L3179"><span class="lineNum">    3179</span>              :          * @data: Buffer for returning station information</span>
<span id="L3180"><span class="lineNum">    3180</span>              :          * @addr: MAC address of the station</span>
<span id="L3181"><span class="lineNum">    3181</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3182"><span class="lineNum">    3182</span>              :          */</span>
<span id="L3183"><span class="lineNum">    3183</span>              :         int (*read_sta_data)(void *priv, struct hostap_sta_driver_data *data,</span>
<span id="L3184"><span class="lineNum">    3184</span>              :                              const u8 *addr);</span>
<span id="L3185"><span class="lineNum">    3185</span>              : </span>
<span id="L3186"><span class="lineNum">    3186</span>              :         /**</span>
<span id="L3187"><span class="lineNum">    3187</span>              :          * tx_control_port - Send a frame over the 802.1X controlled port</span>
<span id="L3188"><span class="lineNum">    3188</span>              :          * @priv: Private driver interface data</span>
<span id="L3189"><span class="lineNum">    3189</span>              :          * @dest: Destination MAC address</span>
<span id="L3190"><span class="lineNum">    3190</span>              :          * @proto: Ethertype in host byte order</span>
<span id="L3191"><span class="lineNum">    3191</span>              :          * @buf: Frame payload starting from IEEE 802.1X header</span>
<span id="L3192"><span class="lineNum">    3192</span>              :          * @len: Frame payload length</span>
<span id="L3193"><span class="lineNum">    3193</span>              :          * @no_encrypt: Do not encrypt frame</span>
<span id="L3194"><span class="lineNum">    3194</span>              :          *</span>
<span id="L3195"><span class="lineNum">    3195</span>              :          * Returns 0 on success, else an error</span>
<span id="L3196"><span class="lineNum">    3196</span>              :          *</span>
<span id="L3197"><span class="lineNum">    3197</span>              :          * This is like a normal Ethernet send except that the driver is aware</span>
<span id="L3198"><span class="lineNum">    3198</span>              :          * (by other means than the Ethertype) that this frame is special,</span>
<span id="L3199"><span class="lineNum">    3199</span>              :          * and more importantly it gains an ordering between the transmission of</span>
<span id="L3200"><span class="lineNum">    3200</span>              :          * the frame and other driver management operations such as key</span>
<span id="L3201"><span class="lineNum">    3201</span>              :          * installations. This can be used to work around known limitations in</span>
<span id="L3202"><span class="lineNum">    3202</span>              :          * IEEE 802.11 protocols such as race conditions between rekeying 4-way</span>
<span id="L3203"><span class="lineNum">    3203</span>              :          * handshake message 4/4 and a PTK being overwritten.</span>
<span id="L3204"><span class="lineNum">    3204</span>              :          *</span>
<span id="L3205"><span class="lineNum">    3205</span>              :          * This function is only used for a given interface if the driver</span>
<span id="L3206"><span class="lineNum">    3206</span>              :          * instance reports WPA_DRIVER_FLAGS_CONTROL_PORT capability. Otherwise,</span>
<span id="L3207"><span class="lineNum">    3207</span>              :          * API users will fall back to sending the frame via a normal socket.</span>
<span id="L3208"><span class="lineNum">    3208</span>              :          */</span>
<span id="L3209"><span class="lineNum">    3209</span>              :         int (*tx_control_port)(void *priv, const u8 *dest,</span>
<span id="L3210"><span class="lineNum">    3210</span>              :                                u16 proto, const u8 *buf, size_t len,</span>
<span id="L3211"><span class="lineNum">    3211</span>              :                                int no_encrypt);</span>
<span id="L3212"><span class="lineNum">    3212</span>              : </span>
<span id="L3213"><span class="lineNum">    3213</span>              :         /**</span>
<span id="L3214"><span class="lineNum">    3214</span>              :          * hapd_send_eapol - Send an EAPOL packet (AP only)</span>
<span id="L3215"><span class="lineNum">    3215</span>              :          * @priv: private driver interface data</span>
<span id="L3216"><span class="lineNum">    3216</span>              :          * @addr: Destination MAC address</span>
<span id="L3217"><span class="lineNum">    3217</span>              :          * @data: EAPOL packet starting with IEEE 802.1X header</span>
<span id="L3218"><span class="lineNum">    3218</span>              :          * @data_len: Length of the EAPOL packet in octets</span>
<span id="L3219"><span class="lineNum">    3219</span>              :          * @encrypt: Whether the frame should be encrypted</span>
<span id="L3220"><span class="lineNum">    3220</span>              :          * @own_addr: Source MAC address</span>
<span id="L3221"><span class="lineNum">    3221</span>              :          * @flags: WPA_STA_* flags for the destination station</span>
<span id="L3222"><span class="lineNum">    3222</span>              :          *</span>
<span id="L3223"><span class="lineNum">    3223</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3224"><span class="lineNum">    3224</span>              :          */</span>
<span id="L3225"><span class="lineNum">    3225</span>              :         int (*hapd_send_eapol)(void *priv, const u8 *addr, const u8 *data,</span>
<span id="L3226"><span class="lineNum">    3226</span>              :                                size_t data_len, int encrypt,</span>
<span id="L3227"><span class="lineNum">    3227</span>              :                                const u8 *own_addr, u32 flags);</span>
<span id="L3228"><span class="lineNum">    3228</span>              : </span>
<span id="L3229"><span class="lineNum">    3229</span>              :         /**</span>
<span id="L3230"><span class="lineNum">    3230</span>              :          * sta_deauth - Deauthenticate a station (AP only)</span>
<span id="L3231"><span class="lineNum">    3231</span>              :          * @priv: Private driver interface data</span>
<span id="L3232"><span class="lineNum">    3232</span>              :          * @own_addr: Source address and BSSID for the Deauthentication frame</span>
<span id="L3233"><span class="lineNum">    3233</span>              :          * @addr: MAC address of the station to deauthenticate</span>
<span id="L3234"><span class="lineNum">    3234</span>              :          * @reason: Reason code for the Deauthentiation frame</span>
<span id="L3235"><span class="lineNum">    3235</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3236"><span class="lineNum">    3236</span>              :          *</span>
<span id="L3237"><span class="lineNum">    3237</span>              :          * This function requests a specific station to be deauthenticated and</span>
<span id="L3238"><span class="lineNum">    3238</span>              :          * a Deauthentication frame to be sent to it.</span>
<span id="L3239"><span class="lineNum">    3239</span>              :          */</span>
<span id="L3240"><span class="lineNum">    3240</span>              :         int (*sta_deauth)(void *priv, const u8 *own_addr, const u8 *addr,</span>
<span id="L3241"><span class="lineNum">    3241</span>              :                           u16 reason);</span>
<span id="L3242"><span class="lineNum">    3242</span>              : </span>
<span id="L3243"><span class="lineNum">    3243</span>              :         /**</span>
<span id="L3244"><span class="lineNum">    3244</span>              :          * sta_disassoc - Disassociate a station (AP only)</span>
<span id="L3245"><span class="lineNum">    3245</span>              :          * @priv: Private driver interface data</span>
<span id="L3246"><span class="lineNum">    3246</span>              :          * @own_addr: Source address and BSSID for the Disassociation frame</span>
<span id="L3247"><span class="lineNum">    3247</span>              :          * @addr: MAC address of the station to disassociate</span>
<span id="L3248"><span class="lineNum">    3248</span>              :          * @reason: Reason code for the Disassociation frame</span>
<span id="L3249"><span class="lineNum">    3249</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3250"><span class="lineNum">    3250</span>              :          *</span>
<span id="L3251"><span class="lineNum">    3251</span>              :          * This function requests a specific station to be disassociated and</span>
<span id="L3252"><span class="lineNum">    3252</span>              :          * a Disassociation frame to be sent to it.</span>
<span id="L3253"><span class="lineNum">    3253</span>              :          */</span>
<span id="L3254"><span class="lineNum">    3254</span>              :         int (*sta_disassoc)(void *priv, const u8 *own_addr, const u8 *addr,</span>
<span id="L3255"><span class="lineNum">    3255</span>              :                             u16 reason);</span>
<span id="L3256"><span class="lineNum">    3256</span>              : </span>
<span id="L3257"><span class="lineNum">    3257</span>              :         /**</span>
<span id="L3258"><span class="lineNum">    3258</span>              :          * sta_remove - Remove a station entry (AP only)</span>
<span id="L3259"><span class="lineNum">    3259</span>              :          * @priv: Private driver interface data</span>
<span id="L3260"><span class="lineNum">    3260</span>              :          * @addr: MAC address of the station to be removed</span>
<span id="L3261"><span class="lineNum">    3261</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3262"><span class="lineNum">    3262</span>              :          */</span>
<span id="L3263"><span class="lineNum">    3263</span>              :         int (*sta_remove)(void *priv, const u8 *addr);</span>
<span id="L3264"><span class="lineNum">    3264</span>              : </span>
<span id="L3265"><span class="lineNum">    3265</span>              :         /**</span>
<span id="L3266"><span class="lineNum">    3266</span>              :          * hapd_get_ssid - Get the current SSID (AP only)</span>
<span id="L3267"><span class="lineNum">    3267</span>              :          * @priv: Private driver interface data</span>
<span id="L3268"><span class="lineNum">    3268</span>              :          * @buf: Buffer for returning the SSID</span>
<span id="L3269"><span class="lineNum">    3269</span>              :          * @len: Maximum length of the buffer</span>
<span id="L3270"><span class="lineNum">    3270</span>              :          * Returns: Length of the SSID on success, -1 on failure</span>
<span id="L3271"><span class="lineNum">    3271</span>              :          *</span>
<span id="L3272"><span class="lineNum">    3272</span>              :          * This function need not be implemented if the driver uses Beacon</span>
<span id="L3273"><span class="lineNum">    3273</span>              :          * template from set_ap() and does not reply to Probe Request frames.</span>
<span id="L3274"><span class="lineNum">    3274</span>              :          */</span>
<span id="L3275"><span class="lineNum">    3275</span>              :         int (*hapd_get_ssid)(void *priv, u8 *buf, int len);</span>
<span id="L3276"><span class="lineNum">    3276</span>              : </span>
<span id="L3277"><span class="lineNum">    3277</span>              :         /**</span>
<span id="L3278"><span class="lineNum">    3278</span>              :          * hapd_set_ssid - Set SSID (AP only)</span>
<span id="L3279"><span class="lineNum">    3279</span>              :          * @priv: Private driver interface data</span>
<span id="L3280"><span class="lineNum">    3280</span>              :          * @buf: SSID</span>
<span id="L3281"><span class="lineNum">    3281</span>              :          * @len: Length of the SSID in octets</span>
<span id="L3282"><span class="lineNum">    3282</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3283"><span class="lineNum">    3283</span>              :          *</span>
<span id="L3284"><span class="lineNum">    3284</span>              :          * DEPRECATED - use set_ap() instead</span>
<span id="L3285"><span class="lineNum">    3285</span>              :          */</span>
<span id="L3286"><span class="lineNum">    3286</span>              :         int (*hapd_set_ssid)(void *priv, const u8 *buf, int len);</span>
<span id="L3287"><span class="lineNum">    3287</span>              : </span>
<span id="L3288"><span class="lineNum">    3288</span>              :         /**</span>
<span id="L3289"><span class="lineNum">    3289</span>              :          * hapd_set_countermeasures - Enable/disable TKIP countermeasures (AP)</span>
<span id="L3290"><span class="lineNum">    3290</span>              :          * @priv: Private driver interface data</span>
<span id="L3291"><span class="lineNum">    3291</span>              :          * @enabled: 1 = countermeasures enabled, 0 = disabled</span>
<span id="L3292"><span class="lineNum">    3292</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3293"><span class="lineNum">    3293</span>              :          *</span>
<span id="L3294"><span class="lineNum">    3294</span>              :          * This need not be implemented if the driver does not take care of</span>
<span id="L3295"><span class="lineNum">    3295</span>              :          * association processing.</span>
<span id="L3296"><span class="lineNum">    3296</span>              :          */</span>
<span id="L3297"><span class="lineNum">    3297</span>              :         int (*hapd_set_countermeasures)(void *priv, int enabled);</span>
<span id="L3298"><span class="lineNum">    3298</span>              : </span>
<span id="L3299"><span class="lineNum">    3299</span>              :         /**</span>
<span id="L3300"><span class="lineNum">    3300</span>              :          * sta_add - Add a station entry</span>
<span id="L3301"><span class="lineNum">    3301</span>              :          * @priv: Private driver interface data</span>
<span id="L3302"><span class="lineNum">    3302</span>              :          * @params: Station parameters</span>
<span id="L3303"><span class="lineNum">    3303</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3304"><span class="lineNum">    3304</span>              :          *</span>
<span id="L3305"><span class="lineNum">    3305</span>              :          * This function is used to add or set (params-&gt;set 1) a station</span>
<span id="L3306"><span class="lineNum">    3306</span>              :          * entry in the driver. Adding STA entries is used only if the driver</span>
<span id="L3307"><span class="lineNum">    3307</span>              :          * does not take care of association processing.</span>
<span id="L3308"><span class="lineNum">    3308</span>              :          *</span>
<span id="L3309"><span class="lineNum">    3309</span>              :          * With drivers that don't support full AP client state, this function</span>
<span id="L3310"><span class="lineNum">    3310</span>              :          * is used to add a station entry to the driver once the station has</span>
<span id="L3311"><span class="lineNum">    3311</span>              :          * completed association.</span>
<span id="L3312"><span class="lineNum">    3312</span>              :          *</span>
<span id="L3313"><span class="lineNum">    3313</span>              :          * With TDLS, this function is used to add or set (params-&gt;set 1)</span>
<span id="L3314"><span class="lineNum">    3314</span>              :          * TDLS peer entries (even with drivers that do not support full AP</span>
<span id="L3315"><span class="lineNum">    3315</span>              :          * client state).</span>
<span id="L3316"><span class="lineNum">    3316</span>              :          */</span>
<span id="L3317"><span class="lineNum">    3317</span>              :         int (*sta_add)(void *priv, struct hostapd_sta_add_params *params);</span>
<span id="L3318"><span class="lineNum">    3318</span>              : </span>
<span id="L3319"><span class="lineNum">    3319</span>              :         /**</span>
<span id="L3320"><span class="lineNum">    3320</span>              :          * get_inact_sec - Get station inactivity duration (AP only)</span>
<span id="L3321"><span class="lineNum">    3321</span>              :          * @priv: Private driver interface data</span>
<span id="L3322"><span class="lineNum">    3322</span>              :          * @addr: Station address</span>
<span id="L3323"><span class="lineNum">    3323</span>              :          * Returns: Number of seconds station has been inactive, -1 on failure</span>
<span id="L3324"><span class="lineNum">    3324</span>              :          */</span>
<span id="L3325"><span class="lineNum">    3325</span>              :         int (*get_inact_sec)(void *priv, const u8 *addr);</span>
<span id="L3326"><span class="lineNum">    3326</span>              : </span>
<span id="L3327"><span class="lineNum">    3327</span>              :         /**</span>
<span id="L3328"><span class="lineNum">    3328</span>              :          * sta_clear_stats - Clear station statistics (AP only)</span>
<span id="L3329"><span class="lineNum">    3329</span>              :          * @priv: Private driver interface data</span>
<span id="L3330"><span class="lineNum">    3330</span>              :          * @addr: Station address</span>
<span id="L3331"><span class="lineNum">    3331</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3332"><span class="lineNum">    3332</span>              :          */</span>
<span id="L3333"><span class="lineNum">    3333</span>              :         int (*sta_clear_stats)(void *priv, const u8 *addr);</span>
<span id="L3334"><span class="lineNum">    3334</span>              : </span>
<span id="L3335"><span class="lineNum">    3335</span>              :         /**</span>
<span id="L3336"><span class="lineNum">    3336</span>              :          * set_freq - Set channel/frequency (AP only)</span>
<span id="L3337"><span class="lineNum">    3337</span>              :          * @priv: Private driver interface data</span>
<span id="L3338"><span class="lineNum">    3338</span>              :          * @freq: Channel parameters</span>
<span id="L3339"><span class="lineNum">    3339</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3340"><span class="lineNum">    3340</span>              :          */</span>
<span id="L3341"><span class="lineNum">    3341</span>              :         int (*set_freq)(void *priv, struct hostapd_freq_params *freq);</span>
<span id="L3342"><span class="lineNum">    3342</span>              : </span>
<span id="L3343"><span class="lineNum">    3343</span>              :         /**</span>
<span id="L3344"><span class="lineNum">    3344</span>              :          * set_rts - Set RTS threshold</span>
<span id="L3345"><span class="lineNum">    3345</span>              :          * @priv: Private driver interface data</span>
<span id="L3346"><span class="lineNum">    3346</span>              :          * @rts: RTS threshold in octets</span>
<span id="L3347"><span class="lineNum">    3347</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3348"><span class="lineNum">    3348</span>              :          */</span>
<span id="L3349"><span class="lineNum">    3349</span>              :         int (*set_rts)(void *priv, int rts);</span>
<span id="L3350"><span class="lineNum">    3350</span>              : </span>
<span id="L3351"><span class="lineNum">    3351</span>              :         /**</span>
<span id="L3352"><span class="lineNum">    3352</span>              :          * set_frag - Set fragmentation threshold</span>
<span id="L3353"><span class="lineNum">    3353</span>              :          * @priv: Private driver interface data</span>
<span id="L3354"><span class="lineNum">    3354</span>              :          * @frag: Fragmentation threshold in octets</span>
<span id="L3355"><span class="lineNum">    3355</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3356"><span class="lineNum">    3356</span>              :          */</span>
<span id="L3357"><span class="lineNum">    3357</span>              :         int (*set_frag)(void *priv, int frag);</span>
<span id="L3358"><span class="lineNum">    3358</span>              : </span>
<span id="L3359"><span class="lineNum">    3359</span>              :         /**</span>
<span id="L3360"><span class="lineNum">    3360</span>              :          * sta_set_flags - Set station flags (AP only)</span>
<span id="L3361"><span class="lineNum">    3361</span>              :          * @priv: Private driver interface data</span>
<span id="L3362"><span class="lineNum">    3362</span>              :          * @addr: Station address</span>
<span id="L3363"><span class="lineNum">    3363</span>              :          * @total_flags: Bitmap of all WPA_STA_* flags currently set</span>
<span id="L3364"><span class="lineNum">    3364</span>              :          * @flags_or: Bitmap of WPA_STA_* flags to add</span>
<span id="L3365"><span class="lineNum">    3365</span>              :          * @flags_and: Bitmap of WPA_STA_* flags to us as a mask</span>
<span id="L3366"><span class="lineNum">    3366</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3367"><span class="lineNum">    3367</span>              :          */</span>
<span id="L3368"><span class="lineNum">    3368</span>              :         int (*sta_set_flags)(void *priv, const u8 *addr,</span>
<span id="L3369"><span class="lineNum">    3369</span>              :                              unsigned int total_flags, unsigned int flags_or,</span>
<span id="L3370"><span class="lineNum">    3370</span>              :                              unsigned int flags_and);</span>
<span id="L3371"><span class="lineNum">    3371</span>              : </span>
<span id="L3372"><span class="lineNum">    3372</span>              :         /**</span>
<span id="L3373"><span class="lineNum">    3373</span>              :          * sta_set_airtime_weight - Set station airtime weight (AP only)</span>
<span id="L3374"><span class="lineNum">    3374</span>              :          * @priv: Private driver interface data</span>
<span id="L3375"><span class="lineNum">    3375</span>              :          * @addr: Station address</span>
<span id="L3376"><span class="lineNum">    3376</span>              :          * @weight: New weight for station airtime assignment</span>
<span id="L3377"><span class="lineNum">    3377</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3378"><span class="lineNum">    3378</span>              :          */</span>
<span id="L3379"><span class="lineNum">    3379</span>              :         int (*sta_set_airtime_weight)(void *priv, const u8 *addr,</span>
<span id="L3380"><span class="lineNum">    3380</span>              :                                       unsigned int weight);</span>
<span id="L3381"><span class="lineNum">    3381</span>              : </span>
<span id="L3382"><span class="lineNum">    3382</span>              :         /**</span>
<span id="L3383"><span class="lineNum">    3383</span>              :          * set_tx_queue_params - Set TX queue parameters</span>
<span id="L3384"><span class="lineNum">    3384</span>              :          * @priv: Private driver interface data</span>
<span id="L3385"><span class="lineNum">    3385</span>              :          * @queue: Queue number (0 = VO, 1 = VI, 2 = BE, 3 = BK)</span>
<span id="L3386"><span class="lineNum">    3386</span>              :          * @aifs: AIFS</span>
<span id="L3387"><span class="lineNum">    3387</span>              :          * @cw_min: cwMin</span>
<span id="L3388"><span class="lineNum">    3388</span>              :          * @cw_max: cwMax</span>
<span id="L3389"><span class="lineNum">    3389</span>              :          * @burst_time: Maximum length for bursting in 0.1 msec units</span>
<span id="L3390"><span class="lineNum">    3390</span>              :          */</span>
<span id="L3391"><span class="lineNum">    3391</span>              :         int (*set_tx_queue_params)(void *priv, int queue, int aifs, int cw_min,</span>
<span id="L3392"><span class="lineNum">    3392</span>              :                                    int cw_max, int burst_time);</span>
<span id="L3393"><span class="lineNum">    3393</span>              : </span>
<span id="L3394"><span class="lineNum">    3394</span>              :         /**</span>
<span id="L3395"><span class="lineNum">    3395</span>              :          * if_add - Add a virtual interface</span>
<span id="L3396"><span class="lineNum">    3396</span>              :          * @priv: Private driver interface data</span>
<span id="L3397"><span class="lineNum">    3397</span>              :          * @type: Interface type</span>
<span id="L3398"><span class="lineNum">    3398</span>              :          * @ifname: Interface name for the new virtual interface</span>
<span id="L3399"><span class="lineNum">    3399</span>              :          * @addr: Local address to use for the interface or %NULL to use the</span>
<span id="L3400"><span class="lineNum">    3400</span>              :          *      parent interface address</span>
<span id="L3401"><span class="lineNum">    3401</span>              :          * @bss_ctx: BSS context for %WPA_IF_AP_BSS interfaces</span>
<span id="L3402"><span class="lineNum">    3402</span>              :          * @drv_priv: Pointer for overwriting the driver context or %NULL if</span>
<span id="L3403"><span class="lineNum">    3403</span>              :          *      not allowed (applies only to %WPA_IF_AP_BSS type)</span>
<span id="L3404"><span class="lineNum">    3404</span>              :          * @force_ifname: Buffer for returning an interface name that the</span>
<span id="L3405"><span class="lineNum">    3405</span>              :          *      driver ended up using if it differs from the requested ifname</span>
<span id="L3406"><span class="lineNum">    3406</span>              :          * @if_addr: Buffer for returning the allocated interface address</span>
<span id="L3407"><span class="lineNum">    3407</span>              :          *      (this may differ from the requested addr if the driver cannot</span>
<span id="L3408"><span class="lineNum">    3408</span>              :          *      change interface address)</span>
<span id="L3409"><span class="lineNum">    3409</span>              :          * @bridge: Bridge interface to use or %NULL if no bridge configured</span>
<span id="L3410"><span class="lineNum">    3410</span>              :          * @use_existing: Whether to allow existing interface to be used</span>
<span id="L3411"><span class="lineNum">    3411</span>              :          * @setup_ap: Whether to setup AP for %WPA_IF_AP_BSS interfaces</span>
<span id="L3412"><span class="lineNum">    3412</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3413"><span class="lineNum">    3413</span>              :          */</span>
<span id="L3414"><span class="lineNum">    3414</span>              :         int (*if_add)(void *priv, enum wpa_driver_if_type type,</span>
<span id="L3415"><span class="lineNum">    3415</span>              :                       const char *ifname, const u8 *addr, void *bss_ctx,</span>
<span id="L3416"><span class="lineNum">    3416</span>              :                       void **drv_priv, char *force_ifname, u8 *if_addr,</span>
<span id="L3417"><span class="lineNum">    3417</span>              :                       const char *bridge, int use_existing, int setup_ap);</span>
<span id="L3418"><span class="lineNum">    3418</span>              : </span>
<span id="L3419"><span class="lineNum">    3419</span>              :         /**</span>
<span id="L3420"><span class="lineNum">    3420</span>              :          * if_remove - Remove a virtual interface</span>
<span id="L3421"><span class="lineNum">    3421</span>              :          * @priv: Private driver interface data</span>
<span id="L3422"><span class="lineNum">    3422</span>              :          * @type: Interface type</span>
<span id="L3423"><span class="lineNum">    3423</span>              :          * @ifname: Interface name of the virtual interface to be removed</span>
<span id="L3424"><span class="lineNum">    3424</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3425"><span class="lineNum">    3425</span>              :          */</span>
<span id="L3426"><span class="lineNum">    3426</span>              :         int (*if_remove)(void *priv, enum wpa_driver_if_type type,</span>
<span id="L3427"><span class="lineNum">    3427</span>              :                          const char *ifname);</span>
<span id="L3428"><span class="lineNum">    3428</span>              : </span>
<span id="L3429"><span class="lineNum">    3429</span>              :         /**</span>
<span id="L3430"><span class="lineNum">    3430</span>              :          * set_sta_vlan - Bind a station into a specific interface (AP only)</span>
<span id="L3431"><span class="lineNum">    3431</span>              :          * @priv: Private driver interface data</span>
<span id="L3432"><span class="lineNum">    3432</span>              :          * @ifname: Interface (main or virtual BSS or VLAN)</span>
<span id="L3433"><span class="lineNum">    3433</span>              :          * @addr: MAC address of the associated station</span>
<span id="L3434"><span class="lineNum">    3434</span>              :          * @vlan_id: VLAN ID</span>
<span id="L3435"><span class="lineNum">    3435</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3436"><span class="lineNum">    3436</span>              :          *</span>
<span id="L3437"><span class="lineNum">    3437</span>              :          * This function is used to bind a station to a specific virtual</span>
<span id="L3438"><span class="lineNum">    3438</span>              :          * interface. It is only used if when virtual interfaces are supported,</span>
<span id="L3439"><span class="lineNum">    3439</span>              :          * e.g., to assign stations to different VLAN interfaces based on</span>
<span id="L3440"><span class="lineNum">    3440</span>              :          * information from a RADIUS server. This allows separate broadcast</span>
<span id="L3441"><span class="lineNum">    3441</span>              :          * domains to be used with a single BSS.</span>
<span id="L3442"><span class="lineNum">    3442</span>              :          */</span>
<span id="L3443"><span class="lineNum">    3443</span>              :         int (*set_sta_vlan)(void *priv, const u8 *addr, const char *ifname,</span>
<span id="L3444"><span class="lineNum">    3444</span>              :                             int vlan_id);</span>
<span id="L3445"><span class="lineNum">    3445</span>              : </span>
<span id="L3446"><span class="lineNum">    3446</span>              :         /**</span>
<span id="L3447"><span class="lineNum">    3447</span>              :          * commit - Optional commit changes handler (AP only)</span>
<span id="L3448"><span class="lineNum">    3448</span>              :          * @priv: driver private data</span>
<span id="L3449"><span class="lineNum">    3449</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3450"><span class="lineNum">    3450</span>              :          *</span>
<span id="L3451"><span class="lineNum">    3451</span>              :          * This optional handler function can be registered if the driver</span>
<span id="L3452"><span class="lineNum">    3452</span>              :          * interface implementation needs to commit changes (e.g., by setting</span>
<span id="L3453"><span class="lineNum">    3453</span>              :          * network interface up) at the end of initial configuration. If set,</span>
<span id="L3454"><span class="lineNum">    3454</span>              :          * this handler will be called after initial setup has been completed.</span>
<span id="L3455"><span class="lineNum">    3455</span>              :          */</span>
<span id="L3456"><span class="lineNum">    3456</span>              :         int (*commit)(void *priv);</span>
<span id="L3457"><span class="lineNum">    3457</span>              : </span>
<span id="L3458"><span class="lineNum">    3458</span>              :         /**</span>
<span id="L3459"><span class="lineNum">    3459</span>              :          * set_radius_acl_auth - Notification of RADIUS ACL change</span>
<span id="L3460"><span class="lineNum">    3460</span>              :          * @priv: Private driver interface data</span>
<span id="L3461"><span class="lineNum">    3461</span>              :          * @mac: MAC address of the station</span>
<span id="L3462"><span class="lineNum">    3462</span>              :          * @accepted: Whether the station was accepted</span>
<span id="L3463"><span class="lineNum">    3463</span>              :          * @session_timeout: Session timeout for the station</span>
<span id="L3464"><span class="lineNum">    3464</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3465"><span class="lineNum">    3465</span>              :          */</span>
<span id="L3466"><span class="lineNum">    3466</span>              :         int (*set_radius_acl_auth)(void *priv, const u8 *mac, int accepted,</span>
<span id="L3467"><span class="lineNum">    3467</span>              :                                    u32 session_timeout);</span>
<span id="L3468"><span class="lineNum">    3468</span>              : </span>
<span id="L3469"><span class="lineNum">    3469</span>              :         /**</span>
<span id="L3470"><span class="lineNum">    3470</span>              :          * set_radius_acl_expire - Notification of RADIUS ACL expiration</span>
<span id="L3471"><span class="lineNum">    3471</span>              :          * @priv: Private driver interface data</span>
<span id="L3472"><span class="lineNum">    3472</span>              :          * @mac: MAC address of the station</span>
<span id="L3473"><span class="lineNum">    3473</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3474"><span class="lineNum">    3474</span>              :          */</span>
<span id="L3475"><span class="lineNum">    3475</span>              :         int (*set_radius_acl_expire)(void *priv, const u8 *mac);</span>
<span id="L3476"><span class="lineNum">    3476</span>              : </span>
<span id="L3477"><span class="lineNum">    3477</span>              :         /**</span>
<span id="L3478"><span class="lineNum">    3478</span>              :          * set_ap_wps_ie - Add WPS IE(s) into Beacon/Probe Response frames (AP)</span>
<span id="L3479"><span class="lineNum">    3479</span>              :          * @priv: Private driver interface data</span>
<span id="L3480"><span class="lineNum">    3480</span>              :          * @beacon: WPS IE(s) for Beacon frames or %NULL to remove extra IE(s)</span>
<span id="L3481"><span class="lineNum">    3481</span>              :          * @proberesp: WPS IE(s) for Probe Response frames or %NULL to remove</span>
<span id="L3482"><span class="lineNum">    3482</span>              :          *      extra IE(s)</span>
<span id="L3483"><span class="lineNum">    3483</span>              :          * @assocresp: WPS IE(s) for (Re)Association Response frames or %NULL</span>
<span id="L3484"><span class="lineNum">    3484</span>              :          *      to remove extra IE(s)</span>
<span id="L3485"><span class="lineNum">    3485</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3486"><span class="lineNum">    3486</span>              :          *</span>
<span id="L3487"><span class="lineNum">    3487</span>              :          * This is an optional function to add WPS IE in the kernel driver for</span>
<span id="L3488"><span class="lineNum">    3488</span>              :          * Beacon and Probe Response frames. This can be left undefined (set</span>
<span id="L3489"><span class="lineNum">    3489</span>              :          * to %NULL) if the driver uses the Beacon template from set_ap()</span>
<span id="L3490"><span class="lineNum">    3490</span>              :          * and does not process Probe Request frames. If the driver takes care</span>
<span id="L3491"><span class="lineNum">    3491</span>              :          * of (Re)Association frame processing, the assocresp buffer includes</span>
<span id="L3492"><span class="lineNum">    3492</span>              :          * WPS IE(s) that need to be added to (Re)Association Response frames</span>
<span id="L3493"><span class="lineNum">    3493</span>              :          * whenever a (Re)Association Request frame indicated use of WPS.</span>
<span id="L3494"><span class="lineNum">    3494</span>              :          *</span>
<span id="L3495"><span class="lineNum">    3495</span>              :          * This will also be used to add P2P IE(s) into Beacon/Probe Response</span>
<span id="L3496"><span class="lineNum">    3496</span>              :          * frames when operating as a GO. The driver is responsible for adding</span>
<span id="L3497"><span class="lineNum">    3497</span>              :          * timing related attributes (e.g., NoA) in addition to the IEs</span>
<span id="L3498"><span class="lineNum">    3498</span>              :          * included here by appending them after these buffers. This call is</span>
<span id="L3499"><span class="lineNum">    3499</span>              :          * also used to provide Probe Response IEs for P2P Listen state</span>
<span id="L3500"><span class="lineNum">    3500</span>              :          * operations for drivers that generate the Probe Response frames</span>
<span id="L3501"><span class="lineNum">    3501</span>              :          * internally.</span>
<span id="L3502"><span class="lineNum">    3502</span>              :          *</span>
<span id="L3503"><span class="lineNum">    3503</span>              :          * DEPRECATED - use set_ap() instead</span>
<span id="L3504"><span class="lineNum">    3504</span>              :          */</span>
<span id="L3505"><span class="lineNum">    3505</span>              :         int (*set_ap_wps_ie)(void *priv, const struct wpabuf *beacon,</span>
<span id="L3506"><span class="lineNum">    3506</span>              :                              const struct wpabuf *proberesp,</span>
<span id="L3507"><span class="lineNum">    3507</span>              :                              const struct wpabuf *assocresp);</span>
<span id="L3508"><span class="lineNum">    3508</span>              : </span>
<span id="L3509"><span class="lineNum">    3509</span>              :         /**</span>
<span id="L3510"><span class="lineNum">    3510</span>              :          * set_supp_port - Set IEEE 802.1X Supplicant Port status</span>
<span id="L3511"><span class="lineNum">    3511</span>              :          * @priv: Private driver interface data</span>
<span id="L3512"><span class="lineNum">    3512</span>              :          * @authorized: Whether the port is authorized</span>
<span id="L3513"><span class="lineNum">    3513</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3514"><span class="lineNum">    3514</span>              :          */</span>
<span id="L3515"><span class="lineNum">    3515</span>              :         int (*set_supp_port)(void *priv, int authorized);</span>
<span id="L3516"><span class="lineNum">    3516</span>              : </span>
<span id="L3517"><span class="lineNum">    3517</span>              :         /**</span>
<span id="L3518"><span class="lineNum">    3518</span>              :          * set_wds_sta - Bind a station into a 4-address WDS (AP only)</span>
<span id="L3519"><span class="lineNum">    3519</span>              :          * @priv: Private driver interface data</span>
<span id="L3520"><span class="lineNum">    3520</span>              :          * @addr: MAC address of the associated station</span>
<span id="L3521"><span class="lineNum">    3521</span>              :          * @aid: Association ID</span>
<span id="L3522"><span class="lineNum">    3522</span>              :          * @val: 1 = bind to 4-address WDS; 0 = unbind</span>
<span id="L3523"><span class="lineNum">    3523</span>              :          * @bridge_ifname: Bridge interface to use for the WDS station or %NULL</span>
<span id="L3524"><span class="lineNum">    3524</span>              :          *      to indicate that bridge is not to be used</span>
<span id="L3525"><span class="lineNum">    3525</span>              :          * @ifname_wds: Buffer to return the interface name for the new WDS</span>
<span id="L3526"><span class="lineNum">    3526</span>              :          *      station or %NULL to indicate name is not returned.</span>
<span id="L3527"><span class="lineNum">    3527</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3528"><span class="lineNum">    3528</span>              :          */</span>
<span id="L3529"><span class="lineNum">    3529</span>              :         int (*set_wds_sta)(void *priv, const u8 *addr, int aid, int val,</span>
<span id="L3530"><span class="lineNum">    3530</span>              :                            const char *bridge_ifname, char *ifname_wds);</span>
<span id="L3531"><span class="lineNum">    3531</span>              : </span>
<span id="L3532"><span class="lineNum">    3532</span>              :         /**</span>
<span id="L3533"><span class="lineNum">    3533</span>              :          * send_action - Transmit an Action frame</span>
<span id="L3534"><span class="lineNum">    3534</span>              :          * @priv: Private driver interface data</span>
<span id="L3535"><span class="lineNum">    3535</span>              :          * @freq: Frequency (in MHz) of the channel</span>
<span id="L3536"><span class="lineNum">    3536</span>              :          * @wait: Time to wait off-channel for a response (in ms), or zero</span>
<span id="L3537"><span class="lineNum">    3537</span>              :          * @dst: Destination MAC address (Address 1)</span>
<span id="L3538"><span class="lineNum">    3538</span>              :          * @src: Source MAC address (Address 2)</span>
<span id="L3539"><span class="lineNum">    3539</span>              :          * @bssid: BSSID (Address 3)</span>
<span id="L3540"><span class="lineNum">    3540</span>              :          * @data: Frame body</span>
<span id="L3541"><span class="lineNum">    3541</span>              :          * @data_len: data length in octets</span>
<span id="L3542"><span class="lineNum">    3542</span>              :          @ @no_cck: Whether CCK rates must not be used to transmit this frame</span>
<span id="L3543"><span class="lineNum">    3543</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3544"><span class="lineNum">    3544</span>              :          *</span>
<span id="L3545"><span class="lineNum">    3545</span>              :          * This command can be used to request the driver to transmit an action</span>
<span id="L3546"><span class="lineNum">    3546</span>              :          * frame to the specified destination.</span>
<span id="L3547"><span class="lineNum">    3547</span>              :          *</span>
<span id="L3548"><span class="lineNum">    3548</span>              :          * If the %WPA_DRIVER_FLAGS_OFFCHANNEL_TX flag is set, the frame will</span>
<span id="L3549"><span class="lineNum">    3549</span>              :          * be transmitted on the given channel and the device will wait for a</span>
<span id="L3550"><span class="lineNum">    3550</span>              :          * response on that channel for the given wait time.</span>
<span id="L3551"><span class="lineNum">    3551</span>              :          *</span>
<span id="L3552"><span class="lineNum">    3552</span>              :          * If the flag is not set, the wait time will be ignored. In this case,</span>
<span id="L3553"><span class="lineNum">    3553</span>              :          * if a remain-on-channel duration is in progress, the frame must be</span>
<span id="L3554"><span class="lineNum">    3554</span>              :          * transmitted on that channel; alternatively the frame may be sent on</span>
<span id="L3555"><span class="lineNum">    3555</span>              :          * the current operational channel (if in associated state in station</span>
<span id="L3556"><span class="lineNum">    3556</span>              :          * mode or while operating as an AP.)</span>
<span id="L3557"><span class="lineNum">    3557</span>              :          *</span>
<span id="L3558"><span class="lineNum">    3558</span>              :          * If @src differs from the device MAC address, use of a random</span>
<span id="L3559"><span class="lineNum">    3559</span>              :          * transmitter address is requested for this message exchange.</span>
<span id="L3560"><span class="lineNum">    3560</span>              :          */</span>
<span id="L3561"><span class="lineNum">    3561</span>              :         int (*send_action)(void *priv, unsigned int freq, unsigned int wait,</span>
<span id="L3562"><span class="lineNum">    3562</span>              :                            const u8 *dst, const u8 *src, const u8 *bssid,</span>
<span id="L3563"><span class="lineNum">    3563</span>              :                            const u8 *data, size_t data_len, int no_cck);</span>
<span id="L3564"><span class="lineNum">    3564</span>              : </span>
<span id="L3565"><span class="lineNum">    3565</span>              :         /**</span>
<span id="L3566"><span class="lineNum">    3566</span>              :          * send_action_cancel_wait - Cancel action frame TX wait</span>
<span id="L3567"><span class="lineNum">    3567</span>              :          * @priv: Private driver interface data</span>
<span id="L3568"><span class="lineNum">    3568</span>              :          *</span>
<span id="L3569"><span class="lineNum">    3569</span>              :          * This command cancels the wait time associated with sending an action</span>
<span id="L3570"><span class="lineNum">    3570</span>              :          * frame. It is only available when %WPA_DRIVER_FLAGS_OFFCHANNEL_TX is</span>
<span id="L3571"><span class="lineNum">    3571</span>              :          * set in the driver flags.</span>
<span id="L3572"><span class="lineNum">    3572</span>              :          */</span>
<span id="L3573"><span class="lineNum">    3573</span>              :         void (*send_action_cancel_wait)(void *priv);</span>
<span id="L3574"><span class="lineNum">    3574</span>              : </span>
<span id="L3575"><span class="lineNum">    3575</span>              :         /**</span>
<span id="L3576"><span class="lineNum">    3576</span>              :          * remain_on_channel - Remain awake on a channel</span>
<span id="L3577"><span class="lineNum">    3577</span>              :          * @priv: Private driver interface data</span>
<span id="L3578"><span class="lineNum">    3578</span>              :          * @freq: Frequency (in MHz) of the channel</span>
<span id="L3579"><span class="lineNum">    3579</span>              :          * @duration: Duration in milliseconds</span>
<span id="L3580"><span class="lineNum">    3580</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3581"><span class="lineNum">    3581</span>              :          *</span>
<span id="L3582"><span class="lineNum">    3582</span>              :          * This command is used to request the driver to remain awake on the</span>
<span id="L3583"><span class="lineNum">    3583</span>              :          * specified channel for the specified duration and report received</span>
<span id="L3584"><span class="lineNum">    3584</span>              :          * Action frames with EVENT_RX_MGMT events. Optionally, received</span>
<span id="L3585"><span class="lineNum">    3585</span>              :          * Probe Request frames may also be requested to be reported by calling</span>
<span id="L3586"><span class="lineNum">    3586</span>              :          * probe_req_report(). These will be reported with EVENT_RX_PROBE_REQ.</span>
<span id="L3587"><span class="lineNum">    3587</span>              :          *</span>
<span id="L3588"><span class="lineNum">    3588</span>              :          * The driver may not be at the requested channel when this function</span>
<span id="L3589"><span class="lineNum">    3589</span>              :          * returns, i.e., the return code is only indicating whether the</span>
<span id="L3590"><span class="lineNum">    3590</span>              :          * request was accepted. The caller will need to wait until the</span>
<span id="L3591"><span class="lineNum">    3591</span>              :          * EVENT_REMAIN_ON_CHANNEL event indicates that the driver has</span>
<span id="L3592"><span class="lineNum">    3592</span>              :          * completed the channel change. This may take some time due to other</span>
<span id="L3593"><span class="lineNum">    3593</span>              :          * need for the radio and the caller should be prepared to timing out</span>
<span id="L3594"><span class="lineNum">    3594</span>              :          * its wait since there are no guarantees on when this request can be</span>
<span id="L3595"><span class="lineNum">    3595</span>              :          * executed.</span>
<span id="L3596"><span class="lineNum">    3596</span>              :          */</span>
<span id="L3597"><span class="lineNum">    3597</span>              :         int (*remain_on_channel)(void *priv, unsigned int freq,</span>
<span id="L3598"><span class="lineNum">    3598</span>              :                                  unsigned int duration);</span>
<span id="L3599"><span class="lineNum">    3599</span>              : </span>
<span id="L3600"><span class="lineNum">    3600</span>              :         /**</span>
<span id="L3601"><span class="lineNum">    3601</span>              :          * cancel_remain_on_channel - Cancel remain-on-channel operation</span>
<span id="L3602"><span class="lineNum">    3602</span>              :          * @priv: Private driver interface data</span>
<span id="L3603"><span class="lineNum">    3603</span>              :          *</span>
<span id="L3604"><span class="lineNum">    3604</span>              :          * This command can be used to cancel a remain-on-channel operation</span>
<span id="L3605"><span class="lineNum">    3605</span>              :          * before its originally requested duration has passed. This could be</span>
<span id="L3606"><span class="lineNum">    3606</span>              :          * used, e.g., when remain_on_channel() is used to request extra time</span>
<span id="L3607"><span class="lineNum">    3607</span>              :          * to receive a response to an Action frame and the response is</span>
<span id="L3608"><span class="lineNum">    3608</span>              :          * received when there is still unneeded time remaining on the</span>
<span id="L3609"><span class="lineNum">    3609</span>              :          * remain-on-channel operation.</span>
<span id="L3610"><span class="lineNum">    3610</span>              :          */</span>
<span id="L3611"><span class="lineNum">    3611</span>              :         int (*cancel_remain_on_channel)(void *priv);</span>
<span id="L3612"><span class="lineNum">    3612</span>              : </span>
<span id="L3613"><span class="lineNum">    3613</span>              :         /**</span>
<span id="L3614"><span class="lineNum">    3614</span>              :          * probe_req_report - Request Probe Request frames to be indicated</span>
<span id="L3615"><span class="lineNum">    3615</span>              :          * @priv: Private driver interface data</span>
<span id="L3616"><span class="lineNum">    3616</span>              :          * @report: Whether to report received Probe Request frames</span>
<span id="L3617"><span class="lineNum">    3617</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L3618"><span class="lineNum">    3618</span>              :          *</span>
<span id="L3619"><span class="lineNum">    3619</span>              :          * This command can be used to request the driver to indicate when</span>
<span id="L3620"><span class="lineNum">    3620</span>              :          * Probe Request frames are received with EVENT_RX_PROBE_REQ events.</span>
<span id="L3621"><span class="lineNum">    3621</span>              :          * Since this operation may require extra resources, e.g., due to less</span>
<span id="L3622"><span class="lineNum">    3622</span>              :          * optimal hardware/firmware RX filtering, many drivers may disable</span>
<span id="L3623"><span class="lineNum">    3623</span>              :          * Probe Request reporting at least in station mode. This command is</span>
<span id="L3624"><span class="lineNum">    3624</span>              :          * used to notify the driver when the Probe Request frames need to be</span>
<span id="L3625"><span class="lineNum">    3625</span>              :          * reported, e.g., during remain-on-channel operations.</span>
<span id="L3626"><span class="lineNum">    3626</span>              :          */</span>
<span id="L3627"><span class="lineNum">    3627</span>              :         int (*probe_req_report)(void *priv, int report);</span>
<span id="L3628"><span class="lineNum">    3628</span>              : </span>
<span id="L3629"><span class="lineNum">    3629</span>              :         /**</span>
<span id="L3630"><span class="lineNum">    3630</span>              :          * deinit_ap - Deinitialize AP mode</span>
<span id="L3631"><span class="lineNum">    3631</span>              :          * @priv: Private driver interface data</span>
<span id="L3632"><span class="lineNum">    3632</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L3633"><span class="lineNum">    3633</span>              :          *</span>
<span id="L3634"><span class="lineNum">    3634</span>              :          * This optional function can be used to disable AP mode related</span>
<span id="L3635"><span class="lineNum">    3635</span>              :          * configuration. If the interface was not dynamically added,</span>
<span id="L3636"><span class="lineNum">    3636</span>              :          * change the driver mode to station mode to allow normal station</span>
<span id="L3637"><span class="lineNum">    3637</span>              :          * operations like scanning to be completed.</span>
<span id="L3638"><span class="lineNum">    3638</span>              :          */</span>
<span id="L3639"><span class="lineNum">    3639</span>              :         int (*deinit_ap)(void *priv);</span>
<span id="L3640"><span class="lineNum">    3640</span>              : </span>
<span id="L3641"><span class="lineNum">    3641</span>              :         /**</span>
<span id="L3642"><span class="lineNum">    3642</span>              :          * deinit_p2p_cli - Deinitialize P2P client mode</span>
<span id="L3643"><span class="lineNum">    3643</span>              :          * @priv: Private driver interface data</span>
<span id="L3644"><span class="lineNum">    3644</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L3645"><span class="lineNum">    3645</span>              :          *</span>
<span id="L3646"><span class="lineNum">    3646</span>              :          * This optional function can be used to disable P2P client mode. If the</span>
<span id="L3647"><span class="lineNum">    3647</span>              :          * interface was not dynamically added, change the interface type back</span>
<span id="L3648"><span class="lineNum">    3648</span>              :          * to station mode.</span>
<span id="L3649"><span class="lineNum">    3649</span>              :          */</span>
<span id="L3650"><span class="lineNum">    3650</span>              :         int (*deinit_p2p_cli)(void *priv);</span>
<span id="L3651"><span class="lineNum">    3651</span>              : </span>
<span id="L3652"><span class="lineNum">    3652</span>              :         /**</span>
<span id="L3653"><span class="lineNum">    3653</span>              :          * suspend - Notification on system suspend/hibernate event</span>
<span id="L3654"><span class="lineNum">    3654</span>              :          * @priv: Private driver interface data</span>
<span id="L3655"><span class="lineNum">    3655</span>              :          */</span>
<span id="L3656"><span class="lineNum">    3656</span>              :         void (*suspend)(void *priv);</span>
<span id="L3657"><span class="lineNum">    3657</span>              : </span>
<span id="L3658"><span class="lineNum">    3658</span>              :         /**</span>
<span id="L3659"><span class="lineNum">    3659</span>              :          * resume - Notification on system resume/thaw event</span>
<span id="L3660"><span class="lineNum">    3660</span>              :          * @priv: Private driver interface data</span>
<span id="L3661"><span class="lineNum">    3661</span>              :          */</span>
<span id="L3662"><span class="lineNum">    3662</span>              :         void (*resume)(void *priv);</span>
<span id="L3663"><span class="lineNum">    3663</span>              : </span>
<span id="L3664"><span class="lineNum">    3664</span>              :         /**</span>
<span id="L3665"><span class="lineNum">    3665</span>              :          * signal_monitor - Set signal monitoring parameters</span>
<span id="L3666"><span class="lineNum">    3666</span>              :          * @priv: Private driver interface data</span>
<span id="L3667"><span class="lineNum">    3667</span>              :          * @threshold: Threshold value for signal change events; 0 = disabled</span>
<span id="L3668"><span class="lineNum">    3668</span>              :          * @hysteresis: Minimum change in signal strength before indicating a</span>
<span id="L3669"><span class="lineNum">    3669</span>              :          *      new event</span>
<span id="L3670"><span class="lineNum">    3670</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L3671"><span class="lineNum">    3671</span>              :          *</span>
<span id="L3672"><span class="lineNum">    3672</span>              :          * This function can be used to configure monitoring of signal strength</span>
<span id="L3673"><span class="lineNum">    3673</span>              :          * with the current AP. Whenever signal strength drops below the</span>
<span id="L3674"><span class="lineNum">    3674</span>              :          * %threshold value or increases above it, EVENT_SIGNAL_CHANGE event</span>
<span id="L3675"><span class="lineNum">    3675</span>              :          * should be generated assuming the signal strength has changed at</span>
<span id="L3676"><span class="lineNum">    3676</span>              :          * least %hysteresis from the previously indicated signal change event.</span>
<span id="L3677"><span class="lineNum">    3677</span>              :          */</span>
<span id="L3678"><span class="lineNum">    3678</span>              :         int (*signal_monitor)(void *priv, int threshold, int hysteresis);</span>
<span id="L3679"><span class="lineNum">    3679</span>              : </span>
<span id="L3680"><span class="lineNum">    3680</span>              :         /**</span>
<span id="L3681"><span class="lineNum">    3681</span>              :          * get_noa - Get current Notice of Absence attribute payload</span>
<span id="L3682"><span class="lineNum">    3682</span>              :          * @priv: Private driver interface data</span>
<span id="L3683"><span class="lineNum">    3683</span>              :          * @buf: Buffer for returning NoA</span>
<span id="L3684"><span class="lineNum">    3684</span>              :          * @buf_len: Buffer length in octets</span>
<span id="L3685"><span class="lineNum">    3685</span>              :          * Returns: Number of octets used in buf, 0 to indicate no NoA is being</span>
<span id="L3686"><span class="lineNum">    3686</span>              :          * advertized, or -1 on failure</span>
<span id="L3687"><span class="lineNum">    3687</span>              :          *</span>
<span id="L3688"><span class="lineNum">    3688</span>              :          * This function is used to fetch the current Notice of Absence</span>
<span id="L3689"><span class="lineNum">    3689</span>              :          * attribute value from GO.</span>
<span id="L3690"><span class="lineNum">    3690</span>              :          */</span>
<span id="L3691"><span class="lineNum">    3691</span>              :         int (*get_noa)(void *priv, u8 *buf, size_t buf_len);</span>
<span id="L3692"><span class="lineNum">    3692</span>              : </span>
<span id="L3693"><span class="lineNum">    3693</span>              :         /**</span>
<span id="L3694"><span class="lineNum">    3694</span>              :          * set_noa - Set Notice of Absence parameters for GO (testing)</span>
<span id="L3695"><span class="lineNum">    3695</span>              :          * @priv: Private driver interface data</span>
<span id="L3696"><span class="lineNum">    3696</span>              :          * @count: Count</span>
<span id="L3697"><span class="lineNum">    3697</span>              :          * @start: Start time in ms from next TBTT</span>
<span id="L3698"><span class="lineNum">    3698</span>              :          * @duration: Duration in ms</span>
<span id="L3699"><span class="lineNum">    3699</span>              :          * Returns: 0 on success or -1 on failure</span>
<span id="L3700"><span class="lineNum">    3700</span>              :          *</span>
<span id="L3701"><span class="lineNum">    3701</span>              :          * This function is used to set Notice of Absence parameters for GO. It</span>
<span id="L3702"><span class="lineNum">    3702</span>              :          * is used only for testing. To disable NoA, all parameters are set to</span>
<span id="L3703"><span class="lineNum">    3703</span>              :          * 0.</span>
<span id="L3704"><span class="lineNum">    3704</span>              :          */</span>
<span id="L3705"><span class="lineNum">    3705</span>              :         int (*set_noa)(void *priv, u8 count, int start, int duration);</span>
<span id="L3706"><span class="lineNum">    3706</span>              : </span>
<span id="L3707"><span class="lineNum">    3707</span>              :         /**</span>
<span id="L3708"><span class="lineNum">    3708</span>              :          * set_p2p_powersave - Set P2P power save options</span>
<span id="L3709"><span class="lineNum">    3709</span>              :          * @priv: Private driver interface data</span>
<span id="L3710"><span class="lineNum">    3710</span>              :          * @legacy_ps: 0 = disable, 1 = enable, 2 = maximum PS, -1 = no change</span>
<span id="L3711"><span class="lineNum">    3711</span>              :          * @opp_ps: 0 = disable, 1 = enable, -1 = no change</span>
<span id="L3712"><span class="lineNum">    3712</span>              :          * @ctwindow: 0.. = change (msec), -1 = no change</span>
<span id="L3713"><span class="lineNum">    3713</span>              :          * Returns: 0 on success or -1 on failure</span>
<span id="L3714"><span class="lineNum">    3714</span>              :          */</span>
<span id="L3715"><span class="lineNum">    3715</span>              :         int (*set_p2p_powersave)(void *priv, int legacy_ps, int opp_ps,</span>
<span id="L3716"><span class="lineNum">    3716</span>              :                                  int ctwindow);</span>
<span id="L3717"><span class="lineNum">    3717</span>              : </span>
<span id="L3718"><span class="lineNum">    3718</span>              :         /**</span>
<span id="L3719"><span class="lineNum">    3719</span>              :          * ampdu - Enable/disable aggregation</span>
<span id="L3720"><span class="lineNum">    3720</span>              :          * @priv: Private driver interface data</span>
<span id="L3721"><span class="lineNum">    3721</span>              :          * @ampdu: 1/0 = enable/disable A-MPDU aggregation</span>
<span id="L3722"><span class="lineNum">    3722</span>              :          * Returns: 0 on success or -1 on failure</span>
<span id="L3723"><span class="lineNum">    3723</span>              :          */</span>
<span id="L3724"><span class="lineNum">    3724</span>              :         int (*ampdu)(void *priv, int ampdu);</span>
<span id="L3725"><span class="lineNum">    3725</span>              : </span>
<span id="L3726"><span class="lineNum">    3726</span>              :         /**</span>
<span id="L3727"><span class="lineNum">    3727</span>              :          * get_radio_name - Get physical radio name for the device</span>
<span id="L3728"><span class="lineNum">    3728</span>              :          * @priv: Private driver interface data</span>
<span id="L3729"><span class="lineNum">    3729</span>              :          * Returns: Radio name or %NULL if not known</span>
<span id="L3730"><span class="lineNum">    3730</span>              :          *</span>
<span id="L3731"><span class="lineNum">    3731</span>              :          * The returned data must not be modified by the caller. It is assumed</span>
<span id="L3732"><span class="lineNum">    3732</span>              :          * that any interface that has the same radio name as another is</span>
<span id="L3733"><span class="lineNum">    3733</span>              :          * sharing the same physical radio. This information can be used to</span>
<span id="L3734"><span class="lineNum">    3734</span>              :          * share scan results etc. information between the virtual interfaces</span>
<span id="L3735"><span class="lineNum">    3735</span>              :          * to speed up various operations.</span>
<span id="L3736"><span class="lineNum">    3736</span>              :          */</span>
<span id="L3737"><span class="lineNum">    3737</span>              :         const char * (*get_radio_name)(void *priv);</span>
<span id="L3738"><span class="lineNum">    3738</span>              : </span>
<span id="L3739"><span class="lineNum">    3739</span>              :         /**</span>
<span id="L3740"><span class="lineNum">    3740</span>              :          * send_tdls_mgmt - for sending TDLS management packets</span>
<span id="L3741"><span class="lineNum">    3741</span>              :          * @priv: private driver interface data</span>
<span id="L3742"><span class="lineNum">    3742</span>              :          * @dst: Destination (peer) MAC address</span>
<span id="L3743"><span class="lineNum">    3743</span>              :          * @action_code: TDLS action code for the mssage</span>
<span id="L3744"><span class="lineNum">    3744</span>              :          * @dialog_token: Dialog Token to use in the message (if needed)</span>
<span id="L3745"><span class="lineNum">    3745</span>              :          * @status_code: Status Code or Reason Code to use (if needed)</span>
<span id="L3746"><span class="lineNum">    3746</span>              :          * @peer_capab: TDLS peer capability (TDLS_PEER_* bitfield)</span>
<span id="L3747"><span class="lineNum">    3747</span>              :          * @initiator: Is the current end the TDLS link initiator</span>
<span id="L3748"><span class="lineNum">    3748</span>              :          * @buf: TDLS IEs to add to the message</span>
<span id="L3749"><span class="lineNum">    3749</span>              :          * @len: Length of buf in octets</span>
<span id="L3750"><span class="lineNum">    3750</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3751"><span class="lineNum">    3751</span>              :          *</span>
<span id="L3752"><span class="lineNum">    3752</span>              :          * This optional function can be used to send packet to driver which is</span>
<span id="L3753"><span class="lineNum">    3753</span>              :          * responsible for receiving and sending all TDLS packets.</span>
<span id="L3754"><span class="lineNum">    3754</span>              :          */</span>
<span id="L3755"><span class="lineNum">    3755</span>              :         int (*send_tdls_mgmt)(void *priv, const u8 *dst, u8 action_code,</span>
<span id="L3756"><span class="lineNum">    3756</span>              :                               u8 dialog_token, u16 status_code, u32 peer_capab,</span>
<span id="L3757"><span class="lineNum">    3757</span>              :                               int initiator, const u8 *buf, size_t len);</span>
<span id="L3758"><span class="lineNum">    3758</span>              : </span>
<span id="L3759"><span class="lineNum">    3759</span>              :         /**</span>
<span id="L3760"><span class="lineNum">    3760</span>              :          * tdls_oper - Ask the driver to perform high-level TDLS operations</span>
<span id="L3761"><span class="lineNum">    3761</span>              :          * @priv: Private driver interface data</span>
<span id="L3762"><span class="lineNum">    3762</span>              :          * @oper: TDLS high-level operation. See %enum tdls_oper</span>
<span id="L3763"><span class="lineNum">    3763</span>              :          * @peer: Destination (peer) MAC address</span>
<span id="L3764"><span class="lineNum">    3764</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3765"><span class="lineNum">    3765</span>              :          *</span>
<span id="L3766"><span class="lineNum">    3766</span>              :          * This optional function can be used to send high-level TDLS commands</span>
<span id="L3767"><span class="lineNum">    3767</span>              :          * to the driver.</span>
<span id="L3768"><span class="lineNum">    3768</span>              :          */</span>
<span id="L3769"><span class="lineNum">    3769</span>              :         int (*tdls_oper)(void *priv, enum tdls_oper oper, const u8 *peer);</span>
<span id="L3770"><span class="lineNum">    3770</span>              : </span>
<span id="L3771"><span class="lineNum">    3771</span>              :         /**</span>
<span id="L3772"><span class="lineNum">    3772</span>              :          * wnm_oper - Notify driver of the WNM frame reception</span>
<span id="L3773"><span class="lineNum">    3773</span>              :          * @priv: Private driver interface data</span>
<span id="L3774"><span class="lineNum">    3774</span>              :          * @oper: WNM operation. See %enum wnm_oper</span>
<span id="L3775"><span class="lineNum">    3775</span>              :          * @peer: Destination (peer) MAC address</span>
<span id="L3776"><span class="lineNum">    3776</span>              :          * @buf: Buffer for the driver to fill in (for getting IE)</span>
<span id="L3777"><span class="lineNum">    3777</span>              :          * @buf_len: Return the len of buf</span>
<span id="L3778"><span class="lineNum">    3778</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3779"><span class="lineNum">    3779</span>              :          */</span>
<span id="L3780"><span class="lineNum">    3780</span>              :         int (*wnm_oper)(void *priv, enum wnm_oper oper, const u8 *peer,</span>
<span id="L3781"><span class="lineNum">    3781</span>              :                         u8 *buf, u16 *buf_len);</span>
<span id="L3782"><span class="lineNum">    3782</span>              : </span>
<span id="L3783"><span class="lineNum">    3783</span>              :         /**</span>
<span id="L3784"><span class="lineNum">    3784</span>              :          * set_qos_map - Set QoS Map</span>
<span id="L3785"><span class="lineNum">    3785</span>              :          * @priv: Private driver interface data</span>
<span id="L3786"><span class="lineNum">    3786</span>              :          * @qos_map_set: QoS Map</span>
<span id="L3787"><span class="lineNum">    3787</span>              :          * @qos_map_set_len: Length of QoS Map</span>
<span id="L3788"><span class="lineNum">    3788</span>              :          */</span>
<span id="L3789"><span class="lineNum">    3789</span>              :         int (*set_qos_map)(void *priv, const u8 *qos_map_set,</span>
<span id="L3790"><span class="lineNum">    3790</span>              :                            u8 qos_map_set_len);</span>
<span id="L3791"><span class="lineNum">    3791</span>              : </span>
<span id="L3792"><span class="lineNum">    3792</span>              :         /**</span>
<span id="L3793"><span class="lineNum">    3793</span>              :          * br_add_ip_neigh - Add a neigh to the bridge ip neigh table</span>
<span id="L3794"><span class="lineNum">    3794</span>              :          * @priv: Private driver interface data</span>
<span id="L3795"><span class="lineNum">    3795</span>              :          * @version: IP version of the IP address, 4 or 6</span>
<span id="L3796"><span class="lineNum">    3796</span>              :          * @ipaddr: IP address for the neigh entry</span>
<span id="L3797"><span class="lineNum">    3797</span>              :          * @prefixlen: IP address prefix length</span>
<span id="L3798"><span class="lineNum">    3798</span>              :          * @addr: Corresponding MAC address</span>
<span id="L3799"><span class="lineNum">    3799</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3800"><span class="lineNum">    3800</span>              :          */</span>
<span id="L3801"><span class="lineNum">    3801</span>              :         int (*br_add_ip_neigh)(void *priv, u8 version, const u8 *ipaddr,</span>
<span id="L3802"><span class="lineNum">    3802</span>              :                                int prefixlen, const u8 *addr);</span>
<span id="L3803"><span class="lineNum">    3803</span>              : </span>
<span id="L3804"><span class="lineNum">    3804</span>              :         /**</span>
<span id="L3805"><span class="lineNum">    3805</span>              :          * br_delete_ip_neigh - Remove a neigh from the bridge ip neigh table</span>
<span id="L3806"><span class="lineNum">    3806</span>              :          * @priv: Private driver interface data</span>
<span id="L3807"><span class="lineNum">    3807</span>              :          * @version: IP version of the IP address, 4 or 6</span>
<span id="L3808"><span class="lineNum">    3808</span>              :          * @ipaddr: IP address for the neigh entry</span>
<span id="L3809"><span class="lineNum">    3809</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3810"><span class="lineNum">    3810</span>              :          */</span>
<span id="L3811"><span class="lineNum">    3811</span>              :         int (*br_delete_ip_neigh)(void *priv, u8 version, const u8 *ipaddr);</span>
<span id="L3812"><span class="lineNum">    3812</span>              : </span>
<span id="L3813"><span class="lineNum">    3813</span>              :         /**</span>
<span id="L3814"><span class="lineNum">    3814</span>              :          * br_port_set_attr - Set a bridge port attribute</span>
<span id="L3815"><span class="lineNum">    3815</span>              :          * @attr: Bridge port attribute to set</span>
<span id="L3816"><span class="lineNum">    3816</span>              :          * @val: Value to be set</span>
<span id="L3817"><span class="lineNum">    3817</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3818"><span class="lineNum">    3818</span>              :          */</span>
<span id="L3819"><span class="lineNum">    3819</span>              :         int (*br_port_set_attr)(void *priv, enum drv_br_port_attr attr,</span>
<span id="L3820"><span class="lineNum">    3820</span>              :                                 unsigned int val);</span>
<span id="L3821"><span class="lineNum">    3821</span>              : </span>
<span id="L3822"><span class="lineNum">    3822</span>              :         /**</span>
<span id="L3823"><span class="lineNum">    3823</span>              :          * br_port_set_attr - Set a bridge network parameter</span>
<span id="L3824"><span class="lineNum">    3824</span>              :          * @param: Bridge parameter to set</span>
<span id="L3825"><span class="lineNum">    3825</span>              :          * @val: Value to be set</span>
<span id="L3826"><span class="lineNum">    3826</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3827"><span class="lineNum">    3827</span>              :          */</span>
<span id="L3828"><span class="lineNum">    3828</span>              :         int (*br_set_net_param)(void *priv, enum drv_br_net_param param,</span>
<span id="L3829"><span class="lineNum">    3829</span>              :                                 unsigned int val);</span>
<span id="L3830"><span class="lineNum">    3830</span>              : </span>
<span id="L3831"><span class="lineNum">    3831</span>              :         /**</span>
<span id="L3832"><span class="lineNum">    3832</span>              :          * get_wowlan - Get wake-on-wireless status</span>
<span id="L3833"><span class="lineNum">    3833</span>              :          * @priv: Private driver interface data</span>
<span id="L3834"><span class="lineNum">    3834</span>              :          */</span>
<span id="L3835"><span class="lineNum">    3835</span>              :         int (*get_wowlan)(void *priv);</span>
<span id="L3836"><span class="lineNum">    3836</span>              : </span>
<span id="L3837"><span class="lineNum">    3837</span>              :         /**</span>
<span id="L3838"><span class="lineNum">    3838</span>              :          * set_wowlan - Set wake-on-wireless triggers</span>
<span id="L3839"><span class="lineNum">    3839</span>              :          * @priv: Private driver interface data</span>
<span id="L3840"><span class="lineNum">    3840</span>              :          * @triggers: wowlan triggers</span>
<span id="L3841"><span class="lineNum">    3841</span>              :          */</span>
<span id="L3842"><span class="lineNum">    3842</span>              :         int (*set_wowlan)(void *priv, const struct wowlan_triggers *triggers);</span>
<span id="L3843"><span class="lineNum">    3843</span>              : </span>
<span id="L3844"><span class="lineNum">    3844</span>              :         /**</span>
<span id="L3845"><span class="lineNum">    3845</span>              :          * signal_poll - Get current connection information</span>
<span id="L3846"><span class="lineNum">    3846</span>              :          * @priv: Private driver interface data</span>
<span id="L3847"><span class="lineNum">    3847</span>              :          * @signal_info: Connection info structure</span>
<span id="L3848"><span class="lineNum">    3848</span>              :          */</span>
<span id="L3849"><span class="lineNum">    3849</span>              :         int (*signal_poll)(void *priv, struct wpa_signal_info *signal_info);</span>
<span id="L3850"><span class="lineNum">    3850</span>              : </span>
<span id="L3851"><span class="lineNum">    3851</span>              :         /**</span>
<span id="L3852"><span class="lineNum">    3852</span>              :          * channel_info - Get parameters of the current operating channel</span>
<span id="L3853"><span class="lineNum">    3853</span>              :          * @priv: Private driver interface data</span>
<span id="L3854"><span class="lineNum">    3854</span>              :          * @channel_info: Channel info structure</span>
<span id="L3855"><span class="lineNum">    3855</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3856"><span class="lineNum">    3856</span>              :          */</span>
<span id="L3857"><span class="lineNum">    3857</span>              :         int (*channel_info)(void *priv, struct wpa_channel_info *channel_info);</span>
<span id="L3858"><span class="lineNum">    3858</span>              : </span>
<span id="L3859"><span class="lineNum">    3859</span>              :         /**</span>
<span id="L3860"><span class="lineNum">    3860</span>              :          * set_authmode - Set authentication algorithm(s) for static WEP</span>
<span id="L3861"><span class="lineNum">    3861</span>              :          * @priv: Private driver interface data</span>
<span id="L3862"><span class="lineNum">    3862</span>              :          * @authmode: 1=Open System, 2=Shared Key, 3=both</span>
<span id="L3863"><span class="lineNum">    3863</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3864"><span class="lineNum">    3864</span>              :          *</span>
<span id="L3865"><span class="lineNum">    3865</span>              :          * This function can be used to set authentication algorithms for AP</span>
<span id="L3866"><span class="lineNum">    3866</span>              :          * mode when static WEP is used. If the driver uses user space MLME/SME</span>
<span id="L3867"><span class="lineNum">    3867</span>              :          * implementation, there is no need to implement this function.</span>
<span id="L3868"><span class="lineNum">    3868</span>              :          *</span>
<span id="L3869"><span class="lineNum">    3869</span>              :          * DEPRECATED - use set_ap() instead</span>
<span id="L3870"><span class="lineNum">    3870</span>              :          */</span>
<span id="L3871"><span class="lineNum">    3871</span>              :         int (*set_authmode)(void *priv, int authmode);</span>
<span id="L3872"><span class="lineNum">    3872</span>              : </span>
<span id="L3873"><span class="lineNum">    3873</span>              : #ifdef ANDROID</span>
<span id="L3874"><span class="lineNum">    3874</span>              :         /**</span>
<span id="L3875"><span class="lineNum">    3875</span>              :          * driver_cmd - Execute driver-specific command</span>
<span id="L3876"><span class="lineNum">    3876</span>              :          * @priv: Private driver interface data</span>
<span id="L3877"><span class="lineNum">    3877</span>              :          * @cmd: Command to execute</span>
<span id="L3878"><span class="lineNum">    3878</span>              :          * @buf: Return buffer</span>
<span id="L3879"><span class="lineNum">    3879</span>              :          * @buf_len: Buffer length</span>
<span id="L3880"><span class="lineNum">    3880</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3881"><span class="lineNum">    3881</span>              :          */</span>
<span id="L3882"><span class="lineNum">    3882</span>              :         int (*driver_cmd)(void *priv, char *cmd, char *buf, size_t buf_len);</span>
<span id="L3883"><span class="lineNum">    3883</span>              : #endif /* ANDROID */</span>
<span id="L3884"><span class="lineNum">    3884</span>              : </span>
<span id="L3885"><span class="lineNum">    3885</span>              :         /**</span>
<span id="L3886"><span class="lineNum">    3886</span>              :          * vendor_cmd - Execute vendor specific command</span>
<span id="L3887"><span class="lineNum">    3887</span>              :          * @priv: Private driver interface data</span>
<span id="L3888"><span class="lineNum">    3888</span>              :          * @vendor_id: Vendor id</span>
<span id="L3889"><span class="lineNum">    3889</span>              :          * @subcmd: Vendor command id</span>
<span id="L3890"><span class="lineNum">    3890</span>              :          * @nested_attr_flag: Specifies if vendor subcommand uses nested</span>
<span id="L3891"><span class="lineNum">    3891</span>              :          *      attributes or not</span>
<span id="L3892"><span class="lineNum">    3892</span>              :          * @data: Vendor command parameters (%NULL if no parameters)</span>
<span id="L3893"><span class="lineNum">    3893</span>              :          * @data_len: Data length</span>
<span id="L3894"><span class="lineNum">    3894</span>              :          * @buf: Return buffer (%NULL to ignore reply)</span>
<span id="L3895"><span class="lineNum">    3895</span>              :          * Returns: 0 on success, negative (&lt;0) on failure</span>
<span id="L3896"><span class="lineNum">    3896</span>              :          *</span>
<span id="L3897"><span class="lineNum">    3897</span>              :          * This function handles vendor specific commands that are passed to</span>
<span id="L3898"><span class="lineNum">    3898</span>              :          * the driver/device. The command is identified by vendor id and</span>
<span id="L3899"><span class="lineNum">    3899</span>              :          * command id. The nested_attr_flag specifies whether the subcommand</span>
<span id="L3900"><span class="lineNum">    3900</span>              :          * uses nested attributes or not. Parameters can be passed</span>
<span id="L3901"><span class="lineNum">    3901</span>              :          * as argument to the command in the data buffer. Reply (if any) will be</span>
<span id="L3902"><span class="lineNum">    3902</span>              :          * filled in the supplied return buffer.</span>
<span id="L3903"><span class="lineNum">    3903</span>              :          *</span>
<span id="L3904"><span class="lineNum">    3904</span>              :          * The exact driver behavior is driver interface and vendor specific. As</span>
<span id="L3905"><span class="lineNum">    3905</span>              :          * an example, this will be converted to a vendor specific cfg80211</span>
<span id="L3906"><span class="lineNum">    3906</span>              :          * command in case of the nl80211 driver interface.</span>
<span id="L3907"><span class="lineNum">    3907</span>              :          */</span>
<span id="L3908"><span class="lineNum">    3908</span>              :         int (*vendor_cmd)(void *priv, unsigned int vendor_id,</span>
<span id="L3909"><span class="lineNum">    3909</span>              :                           unsigned int subcmd, const u8 *data, size_t data_len,</span>
<span id="L3910"><span class="lineNum">    3910</span>              :                           enum nested_attr nested_attr_flag,</span>
<span id="L3911"><span class="lineNum">    3911</span>              :                           struct wpabuf *buf);</span>
<span id="L3912"><span class="lineNum">    3912</span>              : </span>
<span id="L3913"><span class="lineNum">    3913</span>              :         /**</span>
<span id="L3914"><span class="lineNum">    3914</span>              :          * set_rekey_info - Set rekey information</span>
<span id="L3915"><span class="lineNum">    3915</span>              :          * @priv: Private driver interface data</span>
<span id="L3916"><span class="lineNum">    3916</span>              :          * @kek: Current KEK</span>
<span id="L3917"><span class="lineNum">    3917</span>              :          * @kek_len: KEK length in octets</span>
<span id="L3918"><span class="lineNum">    3918</span>              :          * @kck: Current KCK</span>
<span id="L3919"><span class="lineNum">    3919</span>              :          * @kck_len: KCK length in octets</span>
<span id="L3920"><span class="lineNum">    3920</span>              :          * @replay_ctr: Current EAPOL-Key Replay Counter</span>
<span id="L3921"><span class="lineNum">    3921</span>              :          *</span>
<span id="L3922"><span class="lineNum">    3922</span>              :          * This optional function can be used to provide information for the</span>
<span id="L3923"><span class="lineNum">    3923</span>              :          * driver/firmware to process EAPOL-Key frames in Group Key Handshake</span>
<span id="L3924"><span class="lineNum">    3924</span>              :          * while the host (including wpa_supplicant) is sleeping.</span>
<span id="L3925"><span class="lineNum">    3925</span>              :          */</span>
<span id="L3926"><span class="lineNum">    3926</span>              :         void (*set_rekey_info)(void *priv, const u8 *kek, size_t kek_len,</span>
<span id="L3927"><span class="lineNum">    3927</span>              :                                const u8 *kck, size_t kck_len,</span>
<span id="L3928"><span class="lineNum">    3928</span>              :                                const u8 *replay_ctr);</span>
<span id="L3929"><span class="lineNum">    3929</span>              : </span>
<span id="L3930"><span class="lineNum">    3930</span>              :         /**</span>
<span id="L3931"><span class="lineNum">    3931</span>              :          * sta_assoc - Station association indication</span>
<span id="L3932"><span class="lineNum">    3932</span>              :          * @priv: Private driver interface data</span>
<span id="L3933"><span class="lineNum">    3933</span>              :          * @own_addr: Source address and BSSID for association frame</span>
<span id="L3934"><span class="lineNum">    3934</span>              :          * @addr: MAC address of the station to associate</span>
<span id="L3935"><span class="lineNum">    3935</span>              :          * @reassoc: flag to indicate re-association</span>
<span id="L3936"><span class="lineNum">    3936</span>              :          * @status: association response status code</span>
<span id="L3937"><span class="lineNum">    3937</span>              :          * @ie: assoc response ie buffer</span>
<span id="L3938"><span class="lineNum">    3938</span>              :          * @len: ie buffer length</span>
<span id="L3939"><span class="lineNum">    3939</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3940"><span class="lineNum">    3940</span>              :          *</span>
<span id="L3941"><span class="lineNum">    3941</span>              :          * This function indicates the driver to send (Re)Association</span>
<span id="L3942"><span class="lineNum">    3942</span>              :          * Response frame to the station.</span>
<span id="L3943"><span class="lineNum">    3943</span>              :          */</span>
<span id="L3944"><span class="lineNum">    3944</span>              :          int (*sta_assoc)(void *priv, const u8 *own_addr, const u8 *addr,</span>
<span id="L3945"><span class="lineNum">    3945</span>              :                           int reassoc, u16 status, const u8 *ie, size_t len);</span>
<span id="L3946"><span class="lineNum">    3946</span>              : </span>
<span id="L3947"><span class="lineNum">    3947</span>              :         /**</span>
<span id="L3948"><span class="lineNum">    3948</span>              :          * sta_auth - Station authentication indication</span>
<span id="L3949"><span class="lineNum">    3949</span>              :          * @priv: private driver interface data</span>
<span id="L3950"><span class="lineNum">    3950</span>              :          * @params: Station authentication parameters</span>
<span id="L3951"><span class="lineNum">    3951</span>              :          *</span>
<span id="L3952"><span class="lineNum">    3952</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3953"><span class="lineNum">    3953</span>              :          */</span>
<span id="L3954"><span class="lineNum">    3954</span>              :          int (*sta_auth)(void *priv,</span>
<span id="L3955"><span class="lineNum">    3955</span>              :                          struct wpa_driver_sta_auth_params *params);</span>
<span id="L3956"><span class="lineNum">    3956</span>              : </span>
<span id="L3957"><span class="lineNum">    3957</span>              :         /**</span>
<span id="L3958"><span class="lineNum">    3958</span>              :          * add_tspec - Add traffic stream</span>
<span id="L3959"><span class="lineNum">    3959</span>              :          * @priv: Private driver interface data</span>
<span id="L3960"><span class="lineNum">    3960</span>              :          * @addr: MAC address of the station to associate</span>
<span id="L3961"><span class="lineNum">    3961</span>              :          * @tspec_ie: tspec ie buffer</span>
<span id="L3962"><span class="lineNum">    3962</span>              :          * @tspec_ielen: tspec ie length</span>
<span id="L3963"><span class="lineNum">    3963</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3964"><span class="lineNum">    3964</span>              :          *</span>
<span id="L3965"><span class="lineNum">    3965</span>              :          * This function adds the traffic steam for the station</span>
<span id="L3966"><span class="lineNum">    3966</span>              :          * and fills the medium_time in tspec_ie.</span>
<span id="L3967"><span class="lineNum">    3967</span>              :          */</span>
<span id="L3968"><span class="lineNum">    3968</span>              :          int (*add_tspec)(void *priv, const u8 *addr, u8 *tspec_ie,</span>
<span id="L3969"><span class="lineNum">    3969</span>              :                           size_t tspec_ielen);</span>
<span id="L3970"><span class="lineNum">    3970</span>              : </span>
<span id="L3971"><span class="lineNum">    3971</span>              :         /**</span>
<span id="L3972"><span class="lineNum">    3972</span>              :          * add_sta_node - Add a station node in the driver</span>
<span id="L3973"><span class="lineNum">    3973</span>              :          * @priv: Private driver interface data</span>
<span id="L3974"><span class="lineNum">    3974</span>              :          * @addr: MAC address of the station to add</span>
<span id="L3975"><span class="lineNum">    3975</span>              :          * @auth_alg: authentication algorithm used by the station</span>
<span id="L3976"><span class="lineNum">    3976</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3977"><span class="lineNum">    3977</span>              :          *</span>
<span id="L3978"><span class="lineNum">    3978</span>              :          * This function adds the station node in the driver, when</span>
<span id="L3979"><span class="lineNum">    3979</span>              :          * the station gets added by FT-over-DS.</span>
<span id="L3980"><span class="lineNum">    3980</span>              :          */</span>
<span id="L3981"><span class="lineNum">    3981</span>              :         int (*add_sta_node)(void *priv, const u8 *addr, u16 auth_alg);</span>
<span id="L3982"><span class="lineNum">    3982</span>              : </span>
<span id="L3983"><span class="lineNum">    3983</span>              :         /**</span>
<span id="L3984"><span class="lineNum">    3984</span>              :          * sched_scan - Request the driver to initiate scheduled scan</span>
<span id="L3985"><span class="lineNum">    3985</span>              :          * @priv: Private driver interface data</span>
<span id="L3986"><span class="lineNum">    3986</span>              :          * @params: Scan parameters</span>
<span id="L3987"><span class="lineNum">    3987</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L3988"><span class="lineNum">    3988</span>              :          *</span>
<span id="L3989"><span class="lineNum">    3989</span>              :          * This operation should be used for scheduled scan offload to</span>
<span id="L3990"><span class="lineNum">    3990</span>              :          * the hardware. Every time scan results are available, the</span>
<span id="L3991"><span class="lineNum">    3991</span>              :          * driver should report scan results event for wpa_supplicant</span>
<span id="L3992"><span class="lineNum">    3992</span>              :          * which will eventually request the results with</span>
<span id="L3993"><span class="lineNum">    3993</span>              :          * wpa_driver_get_scan_results2(). This operation is optional</span>
<span id="L3994"><span class="lineNum">    3994</span>              :          * and if not provided or if it returns -1, we fall back to</span>
<span id="L3995"><span class="lineNum">    3995</span>              :          * normal host-scheduled scans.</span>
<span id="L3996"><span class="lineNum">    3996</span>              :          */</span>
<span id="L3997"><span class="lineNum">    3997</span>              :         int (*sched_scan)(void *priv, struct wpa_driver_scan_params *params);</span>
<span id="L3998"><span class="lineNum">    3998</span>              : </span>
<span id="L3999"><span class="lineNum">    3999</span>              :         /**</span>
<span id="L4000"><span class="lineNum">    4000</span>              :          * stop_sched_scan - Request the driver to stop a scheduled scan</span>
<span id="L4001"><span class="lineNum">    4001</span>              :          * @priv: Private driver interface data</span>
<span id="L4002"><span class="lineNum">    4002</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4003"><span class="lineNum">    4003</span>              :          *</span>
<span id="L4004"><span class="lineNum">    4004</span>              :          * This should cause the scheduled scan to be stopped and</span>
<span id="L4005"><span class="lineNum">    4005</span>              :          * results should stop being sent. Must be supported if</span>
<span id="L4006"><span class="lineNum">    4006</span>              :          * sched_scan is supported.</span>
<span id="L4007"><span class="lineNum">    4007</span>              :          */</span>
<span id="L4008"><span class="lineNum">    4008</span>              :         int (*stop_sched_scan)(void *priv);</span>
<span id="L4009"><span class="lineNum">    4009</span>              : </span>
<span id="L4010"><span class="lineNum">    4010</span>              :         /**</span>
<span id="L4011"><span class="lineNum">    4011</span>              :          * poll_client - Probe (null data or such) the given station</span>
<span id="L4012"><span class="lineNum">    4012</span>              :          * @priv: Private driver interface data</span>
<span id="L4013"><span class="lineNum">    4013</span>              :          * @own_addr: MAC address of sending interface</span>
<span id="L4014"><span class="lineNum">    4014</span>              :          * @addr: MAC address of the station to probe</span>
<span id="L4015"><span class="lineNum">    4015</span>              :          * @qos: Indicates whether station is QoS station</span>
<span id="L4016"><span class="lineNum">    4016</span>              :          *</span>
<span id="L4017"><span class="lineNum">    4017</span>              :          * This function is used to verify whether an associated station is</span>
<span id="L4018"><span class="lineNum">    4018</span>              :          * still present. This function does not need to be implemented if the</span>
<span id="L4019"><span class="lineNum">    4019</span>              :          * driver provides such inactivity polling mechanism.</span>
<span id="L4020"><span class="lineNum">    4020</span>              :          */</span>
<span id="L4021"><span class="lineNum">    4021</span>              :         void (*poll_client)(void *priv, const u8 *own_addr,</span>
<span id="L4022"><span class="lineNum">    4022</span>              :                             const u8 *addr, int qos);</span>
<span id="L4023"><span class="lineNum">    4023</span>              : </span>
<span id="L4024"><span class="lineNum">    4024</span>              :         /**</span>
<span id="L4025"><span class="lineNum">    4025</span>              :          * radio_disable - Disable/enable radio</span>
<span id="L4026"><span class="lineNum">    4026</span>              :          * @priv: Private driver interface data</span>
<span id="L4027"><span class="lineNum">    4027</span>              :          * @disabled: 1=disable 0=enable radio</span>
<span id="L4028"><span class="lineNum">    4028</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4029"><span class="lineNum">    4029</span>              :          *</span>
<span id="L4030"><span class="lineNum">    4030</span>              :          * This optional command is for testing purposes. It can be used to</span>
<span id="L4031"><span class="lineNum">    4031</span>              :          * disable the radio on a testbed device to simulate out-of-radio-range</span>
<span id="L4032"><span class="lineNum">    4032</span>              :          * conditions.</span>
<span id="L4033"><span class="lineNum">    4033</span>              :          */</span>
<span id="L4034"><span class="lineNum">    4034</span>              :         int (*radio_disable)(void *priv, int disabled);</span>
<span id="L4035"><span class="lineNum">    4035</span>              : </span>
<span id="L4036"><span class="lineNum">    4036</span>              :         /**</span>
<span id="L4037"><span class="lineNum">    4037</span>              :          * switch_channel - Announce channel switch and migrate the GO to the</span>
<span id="L4038"><span class="lineNum">    4038</span>              :          * given frequency</span>
<span id="L4039"><span class="lineNum">    4039</span>              :          * @priv: Private driver interface data</span>
<span id="L4040"><span class="lineNum">    4040</span>              :          * @settings: Settings for CSA period and new channel</span>
<span id="L4041"><span class="lineNum">    4041</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4042"><span class="lineNum">    4042</span>              :          *</span>
<span id="L4043"><span class="lineNum">    4043</span>              :          * This function is used to move the GO to the legacy STA channel to</span>
<span id="L4044"><span class="lineNum">    4044</span>              :          * avoid frequency conflict in single channel concurrency.</span>
<span id="L4045"><span class="lineNum">    4045</span>              :          */</span>
<span id="L4046"><span class="lineNum">    4046</span>              :         int (*switch_channel)(void *priv, struct csa_settings *settings);</span>
<span id="L4047"><span class="lineNum">    4047</span>              : </span>
<span id="L4048"><span class="lineNum">    4048</span>              :         /**</span>
<span id="L4049"><span class="lineNum">    4049</span>              :          * switch_color - Announce color switch and migrate the BSS to the</span>
<span id="L4050"><span class="lineNum">    4050</span>              :          * given color</span>
<span id="L4051"><span class="lineNum">    4051</span>              :          * @priv: Private driver interface data</span>
<span id="L4052"><span class="lineNum">    4052</span>              :          * @settings: Settings for CCA period and new color</span>
<span id="L4053"><span class="lineNum">    4053</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4054"><span class="lineNum">    4054</span>              :          *</span>
<span id="L4055"><span class="lineNum">    4055</span>              :          * This function is used to move the BSS to its new color.</span>
<span id="L4056"><span class="lineNum">    4056</span>              :          */</span>
<span id="L4057"><span class="lineNum">    4057</span>              :         int (*switch_color)(void *priv, struct cca_settings *settings);</span>
<span id="L4058"><span class="lineNum">    4058</span>              : </span>
<span id="L4059"><span class="lineNum">    4059</span>              :         /**</span>
<span id="L4060"><span class="lineNum">    4060</span>              :          * add_tx_ts - Add traffic stream</span>
<span id="L4061"><span class="lineNum">    4061</span>              :          * @priv: Private driver interface data</span>
<span id="L4062"><span class="lineNum">    4062</span>              :          * @tsid: Traffic stream ID</span>
<span id="L4063"><span class="lineNum">    4063</span>              :          * @addr: Receiver address</span>
<span id="L4064"><span class="lineNum">    4064</span>              :          * @user_prio: User priority of the traffic stream</span>
<span id="L4065"><span class="lineNum">    4065</span>              :          * @admitted_time: Admitted time for this TS in units of</span>
<span id="L4066"><span class="lineNum">    4066</span>              :          *      32 microsecond periods (per second).</span>
<span id="L4067"><span class="lineNum">    4067</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4068"><span class="lineNum">    4068</span>              :          */</span>
<span id="L4069"><span class="lineNum">    4069</span>              :         int (*add_tx_ts)(void *priv, u8 tsid, const u8 *addr, u8 user_prio,</span>
<span id="L4070"><span class="lineNum">    4070</span>              :                          u16 admitted_time);</span>
<span id="L4071"><span class="lineNum">    4071</span>              : </span>
<span id="L4072"><span class="lineNum">    4072</span>              :         /**</span>
<span id="L4073"><span class="lineNum">    4073</span>              :          * del_tx_ts - Delete traffic stream</span>
<span id="L4074"><span class="lineNum">    4074</span>              :          * @priv: Private driver interface data</span>
<span id="L4075"><span class="lineNum">    4075</span>              :          * @tsid: Traffic stream ID</span>
<span id="L4076"><span class="lineNum">    4076</span>              :          * @addr: Receiver address</span>
<span id="L4077"><span class="lineNum">    4077</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4078"><span class="lineNum">    4078</span>              :          */</span>
<span id="L4079"><span class="lineNum">    4079</span>              :         int (*del_tx_ts)(void *priv, u8 tsid, const u8 *addr);</span>
<span id="L4080"><span class="lineNum">    4080</span>              : </span>
<span id="L4081"><span class="lineNum">    4081</span>              :         /**</span>
<span id="L4082"><span class="lineNum">    4082</span>              :          * Enable channel-switching with TDLS peer</span>
<span id="L4083"><span class="lineNum">    4083</span>              :          * @priv: Private driver interface data</span>
<span id="L4084"><span class="lineNum">    4084</span>              :          * @addr: MAC address of the TDLS peer</span>
<span id="L4085"><span class="lineNum">    4085</span>              :          * @oper_class: Operating class of the switch channel</span>
<span id="L4086"><span class="lineNum">    4086</span>              :          * @params: Channel specification</span>
<span id="L4087"><span class="lineNum">    4087</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4088"><span class="lineNum">    4088</span>              :          *</span>
<span id="L4089"><span class="lineNum">    4089</span>              :          * The function indicates to driver that it can start switching to a</span>
<span id="L4090"><span class="lineNum">    4090</span>              :          * different channel with a specified TDLS peer. The switching is</span>
<span id="L4091"><span class="lineNum">    4091</span>              :          * assumed on until canceled with tdls_disable_channel_switch().</span>
<span id="L4092"><span class="lineNum">    4092</span>              :          */</span>
<span id="L4093"><span class="lineNum">    4093</span>              :         int (*tdls_enable_channel_switch)(</span>
<span id="L4094"><span class="lineNum">    4094</span>              :                 void *priv, const u8 *addr, u8 oper_class,</span>
<span id="L4095"><span class="lineNum">    4095</span>              :                 const struct hostapd_freq_params *params);</span>
<span id="L4096"><span class="lineNum">    4096</span>              : </span>
<span id="L4097"><span class="lineNum">    4097</span>              :         /**</span>
<span id="L4098"><span class="lineNum">    4098</span>              :          * Disable channel switching with TDLS peer</span>
<span id="L4099"><span class="lineNum">    4099</span>              :          * @priv: Private driver interface data</span>
<span id="L4100"><span class="lineNum">    4100</span>              :          * @addr: MAC address of the TDLS peer</span>
<span id="L4101"><span class="lineNum">    4101</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4102"><span class="lineNum">    4102</span>              :          *</span>
<span id="L4103"><span class="lineNum">    4103</span>              :          * This function indicates to the driver that it should stop switching</span>
<span id="L4104"><span class="lineNum">    4104</span>              :          * with a given TDLS peer.</span>
<span id="L4105"><span class="lineNum">    4105</span>              :          */</span>
<span id="L4106"><span class="lineNum">    4106</span>              :         int (*tdls_disable_channel_switch)(void *priv, const u8 *addr);</span>
<span id="L4107"><span class="lineNum">    4107</span>              : </span>
<span id="L4108"><span class="lineNum">    4108</span>              :         /**</span>
<span id="L4109"><span class="lineNum">    4109</span>              :          * start_dfs_cac - Listen for radar interference on the channel</span>
<span id="L4110"><span class="lineNum">    4110</span>              :          * @priv: Private driver interface data</span>
<span id="L4111"><span class="lineNum">    4111</span>              :          * @freq: Channel parameters</span>
<span id="L4112"><span class="lineNum">    4112</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4113"><span class="lineNum">    4113</span>              :          */</span>
<span id="L4114"><span class="lineNum">    4114</span>              :         int (*start_dfs_cac)(void *priv, struct hostapd_freq_params *freq);</span>
<span id="L4115"><span class="lineNum">    4115</span>              : </span>
<span id="L4116"><span class="lineNum">    4116</span>              :         /**</span>
<span id="L4117"><span class="lineNum">    4117</span>              :          * stop_ap - Removes beacon from AP</span>
<span id="L4118"><span class="lineNum">    4118</span>              :          * @priv: Private driver interface data</span>
<span id="L4119"><span class="lineNum">    4119</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4120"><span class="lineNum">    4120</span>              :          *</span>
<span id="L4121"><span class="lineNum">    4121</span>              :          * This optional function can be used to disable AP mode related</span>
<span id="L4122"><span class="lineNum">    4122</span>              :          * configuration. Unlike deinit_ap, it does not change to station</span>
<span id="L4123"><span class="lineNum">    4123</span>              :          * mode.</span>
<span id="L4124"><span class="lineNum">    4124</span>              :          */</span>
<span id="L4125"><span class="lineNum">    4125</span>              :         int (*stop_ap)(void *priv);</span>
<span id="L4126"><span class="lineNum">    4126</span>              : </span>
<span id="L4127"><span class="lineNum">    4127</span>              :         /**</span>
<span id="L4128"><span class="lineNum">    4128</span>              :          * get_survey - Retrieve survey data</span>
<span id="L4129"><span class="lineNum">    4129</span>              :          * @priv: Private driver interface data</span>
<span id="L4130"><span class="lineNum">    4130</span>              :          * @freq: If set, survey data for the specified frequency is only</span>
<span id="L4131"><span class="lineNum">    4131</span>              :          *      being requested. If not set, all survey data is requested.</span>
<span id="L4132"><span class="lineNum">    4132</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4133"><span class="lineNum">    4133</span>              :          *</span>
<span id="L4134"><span class="lineNum">    4134</span>              :          * Use this to retrieve:</span>
<span id="L4135"><span class="lineNum">    4135</span>              :          *</span>
<span id="L4136"><span class="lineNum">    4136</span>              :          * - the observed channel noise floor</span>
<span id="L4137"><span class="lineNum">    4137</span>              :          * - the amount of time we have spent on the channel</span>
<span id="L4138"><span class="lineNum">    4138</span>              :          * - the amount of time during which we have spent on the channel that</span>
<span id="L4139"><span class="lineNum">    4139</span>              :          *   the radio has determined the medium is busy and we cannot</span>
<span id="L4140"><span class="lineNum">    4140</span>              :          *   transmit</span>
<span id="L4141"><span class="lineNum">    4141</span>              :          * - the amount of time we have spent receiving data</span>
<span id="L4142"><span class="lineNum">    4142</span>              :          * - the amount of time we have spent transmitting data</span>
<span id="L4143"><span class="lineNum">    4143</span>              :          *</span>
<span id="L4144"><span class="lineNum">    4144</span>              :          * This data can be used for spectrum heuristics. One example is</span>
<span id="L4145"><span class="lineNum">    4145</span>              :          * Automatic Channel Selection (ACS). The channel survey data is</span>
<span id="L4146"><span class="lineNum">    4146</span>              :          * kept on a linked list on the channel data, one entry is added</span>
<span id="L4147"><span class="lineNum">    4147</span>              :          * for each survey. The min_nf of the channel is updated for each</span>
<span id="L4148"><span class="lineNum">    4148</span>              :          * survey.</span>
<span id="L4149"><span class="lineNum">    4149</span>              :          */</span>
<span id="L4150"><span class="lineNum">    4150</span>              :         int (*get_survey)(void *priv, unsigned int freq);</span>
<span id="L4151"><span class="lineNum">    4151</span>              : </span>
<span id="L4152"><span class="lineNum">    4152</span>              :         /**</span>
<span id="L4153"><span class="lineNum">    4153</span>              :          * status - Get driver interface status information</span>
<span id="L4154"><span class="lineNum">    4154</span>              :          * @priv: Private driver interface data</span>
<span id="L4155"><span class="lineNum">    4155</span>              :          * @buf: Buffer for printing the status information</span>
<span id="L4156"><span class="lineNum">    4156</span>              :          * @buflen: Maximum length of the buffer</span>
<span id="L4157"><span class="lineNum">    4157</span>              :          * Returns: Length of written status information or -1 on failure</span>
<span id="L4158"><span class="lineNum">    4158</span>              :          */</span>
<span id="L4159"><span class="lineNum">    4159</span>              :         int (*status)(void *priv, char *buf, size_t buflen);</span>
<span id="L4160"><span class="lineNum">    4160</span>              : </span>
<span id="L4161"><span class="lineNum">    4161</span>              :         /**</span>
<span id="L4162"><span class="lineNum">    4162</span>              :          * roaming - Set roaming policy for driver-based BSS selection</span>
<span id="L4163"><span class="lineNum">    4163</span>              :          * @priv: Private driver interface data</span>
<span id="L4164"><span class="lineNum">    4164</span>              :          * @allowed: Whether roaming within ESS is allowed</span>
<span id="L4165"><span class="lineNum">    4165</span>              :          * @bssid: Forced BSSID if roaming is disabled or %NULL if not set</span>
<span id="L4166"><span class="lineNum">    4166</span>              :          * Returns: Length of written status information or -1 on failure</span>
<span id="L4167"><span class="lineNum">    4167</span>              :          *</span>
<span id="L4168"><span class="lineNum">    4168</span>              :          * This optional callback can be used to update roaming policy from the</span>
<span id="L4169"><span class="lineNum">    4169</span>              :          * associate() command (bssid being set there indicates that the driver</span>
<span id="L4170"><span class="lineNum">    4170</span>              :          * should not roam before getting this roaming() call to allow roaming.</span>
<span id="L4171"><span class="lineNum">    4171</span>              :          * If the driver does not indicate WPA_DRIVER_FLAGS_BSS_SELECTION</span>
<span id="L4172"><span class="lineNum">    4172</span>              :          * capability, roaming policy is handled within wpa_supplicant and there</span>
<span id="L4173"><span class="lineNum">    4173</span>              :          * is no need to implement or react to this callback.</span>
<span id="L4174"><span class="lineNum">    4174</span>              :          */</span>
<span id="L4175"><span class="lineNum">    4175</span>              :         int (*roaming)(void *priv, int allowed, const u8 *bssid);</span>
<span id="L4176"><span class="lineNum">    4176</span>              : </span>
<span id="L4177"><span class="lineNum">    4177</span>              :         /**</span>
<span id="L4178"><span class="lineNum">    4178</span>              :          * disable_fils - Enable/disable FILS feature</span>
<span id="L4179"><span class="lineNum">    4179</span>              :          * @priv: Private driver interface data</span>
<span id="L4180"><span class="lineNum">    4180</span>              :          * @disable: 0-enable and 1-disable FILS feature</span>
<span id="L4181"><span class="lineNum">    4181</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4182"><span class="lineNum">    4182</span>              :          *</span>
<span id="L4183"><span class="lineNum">    4183</span>              :          * This callback can be used to configure driver and below layers to</span>
<span id="L4184"><span class="lineNum">    4184</span>              :          * enable/disable all FILS features.</span>
<span id="L4185"><span class="lineNum">    4185</span>              :          */</span>
<span id="L4186"><span class="lineNum">    4186</span>              :         int (*disable_fils)(void *priv, int disable);</span>
<span id="L4187"><span class="lineNum">    4187</span>              : </span>
<span id="L4188"><span class="lineNum">    4188</span>              :         /**</span>
<span id="L4189"><span class="lineNum">    4189</span>              :          * set_mac_addr - Set MAC address</span>
<span id="L4190"><span class="lineNum">    4190</span>              :          * @priv: Private driver interface data</span>
<span id="L4191"><span class="lineNum">    4191</span>              :          * @addr: MAC address to use or %NULL for setting back to permanent</span>
<span id="L4192"><span class="lineNum">    4192</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4193"><span class="lineNum">    4193</span>              :          */</span>
<span id="L4194"><span class="lineNum">    4194</span>              :         int (*set_mac_addr)(void *priv, const u8 *addr);</span>
<span id="L4195"><span class="lineNum">    4195</span>              : </span>
<span id="L4196"><span class="lineNum">    4196</span>              : #ifdef CONFIG_MACSEC</span>
<span id="L4197"><span class="lineNum">    4197</span>              :         int (*macsec_init)(void *priv, struct macsec_init_params *params);</span>
<span id="L4198"><span class="lineNum">    4198</span>              : </span>
<span id="L4199"><span class="lineNum">    4199</span>              :         int (*macsec_deinit)(void *priv);</span>
<span id="L4200"><span class="lineNum">    4200</span>              : </span>
<span id="L4201"><span class="lineNum">    4201</span>              :         /**</span>
<span id="L4202"><span class="lineNum">    4202</span>              :          * macsec_get_capability - Inform MKA of this driver's capability</span>
<span id="L4203"><span class="lineNum">    4203</span>              :          * @priv: Private driver interface data</span>
<span id="L4204"><span class="lineNum">    4204</span>              :          * @cap: Driver's capability</span>
<span id="L4205"><span class="lineNum">    4205</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4206"><span class="lineNum">    4206</span>              :          */</span>
<span id="L4207"><span class="lineNum">    4207</span>              :         int (*macsec_get_capability)(void *priv, enum macsec_cap *cap);</span>
<span id="L4208"><span class="lineNum">    4208</span>              : </span>
<span id="L4209"><span class="lineNum">    4209</span>              :         /**</span>
<span id="L4210"><span class="lineNum">    4210</span>              :          * enable_protect_frames - Set protect frames status</span>
<span id="L4211"><span class="lineNum">    4211</span>              :          * @priv: Private driver interface data</span>
<span id="L4212"><span class="lineNum">    4212</span>              :          * @enabled: true = protect frames enabled</span>
<span id="L4213"><span class="lineNum">    4213</span>              :          *           false = protect frames disabled</span>
<span id="L4214"><span class="lineNum">    4214</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4215"><span class="lineNum">    4215</span>              :          */</span>
<span id="L4216"><span class="lineNum">    4216</span>              :         int (*enable_protect_frames)(void *priv, bool enabled);</span>
<span id="L4217"><span class="lineNum">    4217</span>              : </span>
<span id="L4218"><span class="lineNum">    4218</span>              :         /**</span>
<span id="L4219"><span class="lineNum">    4219</span>              :          * enable_encrypt - Set encryption status</span>
<span id="L4220"><span class="lineNum">    4220</span>              :          * @priv: Private driver interface data</span>
<span id="L4221"><span class="lineNum">    4221</span>              :          * @enabled: true = encrypt outgoing traffic</span>
<span id="L4222"><span class="lineNum">    4222</span>              :          *           false = integrity-only protection on outgoing traffic</span>
<span id="L4223"><span class="lineNum">    4223</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4224"><span class="lineNum">    4224</span>              :          */</span>
<span id="L4225"><span class="lineNum">    4225</span>              :         int (*enable_encrypt)(void *priv, bool enabled);</span>
<span id="L4226"><span class="lineNum">    4226</span>              : </span>
<span id="L4227"><span class="lineNum">    4227</span>              :         /**</span>
<span id="L4228"><span class="lineNum">    4228</span>              :          * set_replay_protect - Set replay protect status and window size</span>
<span id="L4229"><span class="lineNum">    4229</span>              :          * @priv: Private driver interface data</span>
<span id="L4230"><span class="lineNum">    4230</span>              :          * @enabled: true = replay protect enabled</span>
<span id="L4231"><span class="lineNum">    4231</span>              :          *           false = replay protect disabled</span>
<span id="L4232"><span class="lineNum">    4232</span>              :          * @window: replay window size, valid only when replay protect enabled</span>
<span id="L4233"><span class="lineNum">    4233</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4234"><span class="lineNum">    4234</span>              :          */</span>
<span id="L4235"><span class="lineNum">    4235</span>              :         int (*set_replay_protect)(void *priv, bool enabled, u32 window);</span>
<span id="L4236"><span class="lineNum">    4236</span>              : </span>
<span id="L4237"><span class="lineNum">    4237</span>              :         /**</span>
<span id="L4238"><span class="lineNum">    4238</span>              :          * set_current_cipher_suite - Set current cipher suite</span>
<span id="L4239"><span class="lineNum">    4239</span>              :          * @priv: Private driver interface data</span>
<span id="L4240"><span class="lineNum">    4240</span>              :          * @cs: EUI64 identifier</span>
<span id="L4241"><span class="lineNum">    4241</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4242"><span class="lineNum">    4242</span>              :          */</span>
<span id="L4243"><span class="lineNum">    4243</span>              :         int (*set_current_cipher_suite)(void *priv, u64 cs);</span>
<span id="L4244"><span class="lineNum">    4244</span>              : </span>
<span id="L4245"><span class="lineNum">    4245</span>              :         /**</span>
<span id="L4246"><span class="lineNum">    4246</span>              :          * enable_controlled_port - Set controlled port status</span>
<span id="L4247"><span class="lineNum">    4247</span>              :          * @priv: Private driver interface data</span>
<span id="L4248"><span class="lineNum">    4248</span>              :          * @enabled: true = controlled port enabled</span>
<span id="L4249"><span class="lineNum">    4249</span>              :          *           false = controlled port disabled</span>
<span id="L4250"><span class="lineNum">    4250</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4251"><span class="lineNum">    4251</span>              :          */</span>
<span id="L4252"><span class="lineNum">    4252</span>              :         int (*enable_controlled_port)(void *priv, bool enabled);</span>
<span id="L4253"><span class="lineNum">    4253</span>              : </span>
<span id="L4254"><span class="lineNum">    4254</span>              :         /**</span>
<span id="L4255"><span class="lineNum">    4255</span>              :          * get_receive_lowest_pn - Get receive lowest pn</span>
<span id="L4256"><span class="lineNum">    4256</span>              :          * @priv: Private driver interface data</span>
<span id="L4257"><span class="lineNum">    4257</span>              :          * @sa: secure association</span>
<span id="L4258"><span class="lineNum">    4258</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4259"><span class="lineNum">    4259</span>              :          */</span>
<span id="L4260"><span class="lineNum">    4260</span>              :         int (*get_receive_lowest_pn)(void *priv, struct receive_sa *sa);</span>
<span id="L4261"><span class="lineNum">    4261</span>              : </span>
<span id="L4262"><span class="lineNum">    4262</span>              :         /**</span>
<span id="L4263"><span class="lineNum">    4263</span>              :          * get_transmit_next_pn - Get transmit next pn</span>
<span id="L4264"><span class="lineNum">    4264</span>              :          * @priv: Private driver interface data</span>
<span id="L4265"><span class="lineNum">    4265</span>              :          * @sa: secure association</span>
<span id="L4266"><span class="lineNum">    4266</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4267"><span class="lineNum">    4267</span>              :          */</span>
<span id="L4268"><span class="lineNum">    4268</span>              :         int (*get_transmit_next_pn)(void *priv, struct transmit_sa *sa);</span>
<span id="L4269"><span class="lineNum">    4269</span>              : </span>
<span id="L4270"><span class="lineNum">    4270</span>              :         /**</span>
<span id="L4271"><span class="lineNum">    4271</span>              :          * set_transmit_next_pn - Set transmit next pn</span>
<span id="L4272"><span class="lineNum">    4272</span>              :          * @priv: Private driver interface data</span>
<span id="L4273"><span class="lineNum">    4273</span>              :          * @sa: secure association</span>
<span id="L4274"><span class="lineNum">    4274</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4275"><span class="lineNum">    4275</span>              :          */</span>
<span id="L4276"><span class="lineNum">    4276</span>              :         int (*set_transmit_next_pn)(void *priv, struct transmit_sa *sa);</span>
<span id="L4277"><span class="lineNum">    4277</span>              : </span>
<span id="L4278"><span class="lineNum">    4278</span>              :         /**</span>
<span id="L4279"><span class="lineNum">    4279</span>              :          * set_receive_lowest_pn - Set receive lowest PN</span>
<span id="L4280"><span class="lineNum">    4280</span>              :          * @priv: Private driver interface data</span>
<span id="L4281"><span class="lineNum">    4281</span>              :          * @sa: secure association</span>
<span id="L4282"><span class="lineNum">    4282</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4283"><span class="lineNum">    4283</span>              :          */</span>
<span id="L4284"><span class="lineNum">    4284</span>              :         int (*set_receive_lowest_pn)(void *priv, struct receive_sa *sa);</span>
<span id="L4285"><span class="lineNum">    4285</span>              : </span>
<span id="L4286"><span class="lineNum">    4286</span>              :         /**</span>
<span id="L4287"><span class="lineNum">    4287</span>              :          * create_receive_sc - create secure channel for receiving</span>
<span id="L4288"><span class="lineNum">    4288</span>              :          * @priv: Private driver interface data</span>
<span id="L4289"><span class="lineNum">    4289</span>              :          * @sc: secure channel</span>
<span id="L4290"><span class="lineNum">    4290</span>              :          * @conf_offset: confidentiality offset (0, 30, or 50)</span>
<span id="L4291"><span class="lineNum">    4291</span>              :          * @validation: frame validation policy (0 = Disabled, 1 = Checked,</span>
<span id="L4292"><span class="lineNum">    4292</span>              :          *      2 = Strict)</span>
<span id="L4293"><span class="lineNum">    4293</span>              :          * Returns: 0 on success, -1 on failure (or if not supported)</span>
<span id="L4294"><span class="lineNum">    4294</span>              :          */</span>
<span id="L4295"><span class="lineNum">    4295</span>              :         int (*create_receive_sc)(void *priv, struct receive_sc *sc,</span>
<span id="L4296"><span class="lineNum">    4296</span>              :                                  unsigned int conf_offset,</span>
<span id="L4297"><span class="lineNum">    4297</span>              :                                  int validation);</span>
<span id="L4298"><span class="lineNum">    4298</span>              : </span>
<span id="L4299"><span class="lineNum">    4299</span>              :         /**</span>
<span id="L4300"><span class="lineNum">    4300</span>              :          * delete_receive_sc - delete secure connection for receiving</span>
<span id="L4301"><span class="lineNum">    4301</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4302"><span class="lineNum">    4302</span>              :          * @sc: secure channel</span>
<span id="L4303"><span class="lineNum">    4303</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4304"><span class="lineNum">    4304</span>              :          */</span>
<span id="L4305"><span class="lineNum">    4305</span>              :         int (*delete_receive_sc)(void *priv, struct receive_sc *sc);</span>
<span id="L4306"><span class="lineNum">    4306</span>              : </span>
<span id="L4307"><span class="lineNum">    4307</span>              :         /**</span>
<span id="L4308"><span class="lineNum">    4308</span>              :          * create_receive_sa - create secure association for receive</span>
<span id="L4309"><span class="lineNum">    4309</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4310"><span class="lineNum">    4310</span>              :          * @sa: secure association</span>
<span id="L4311"><span class="lineNum">    4311</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4312"><span class="lineNum">    4312</span>              :          */</span>
<span id="L4313"><span class="lineNum">    4313</span>              :         int (*create_receive_sa)(void *priv, struct receive_sa *sa);</span>
<span id="L4314"><span class="lineNum">    4314</span>              : </span>
<span id="L4315"><span class="lineNum">    4315</span>              :         /**</span>
<span id="L4316"><span class="lineNum">    4316</span>              :          * delete_receive_sa - Delete secure association for receive</span>
<span id="L4317"><span class="lineNum">    4317</span>              :          * @priv: Private driver interface data from init()</span>
<span id="L4318"><span class="lineNum">    4318</span>              :          * @sa: Secure association</span>
<span id="L4319"><span class="lineNum">    4319</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4320"><span class="lineNum">    4320</span>              :          */</span>
<span id="L4321"><span class="lineNum">    4321</span>              :         int (*delete_receive_sa)(void *priv, struct receive_sa *sa);</span>
<span id="L4322"><span class="lineNum">    4322</span>              : </span>
<span id="L4323"><span class="lineNum">    4323</span>              :         /**</span>
<span id="L4324"><span class="lineNum">    4324</span>              :          * enable_receive_sa - enable the SA for receive</span>
<span id="L4325"><span class="lineNum">    4325</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4326"><span class="lineNum">    4326</span>              :          * @sa: secure association</span>
<span id="L4327"><span class="lineNum">    4327</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4328"><span class="lineNum">    4328</span>              :          */</span>
<span id="L4329"><span class="lineNum">    4329</span>              :         int (*enable_receive_sa)(void *priv, struct receive_sa *sa);</span>
<span id="L4330"><span class="lineNum">    4330</span>              : </span>
<span id="L4331"><span class="lineNum">    4331</span>              :         /**</span>
<span id="L4332"><span class="lineNum">    4332</span>              :          * disable_receive_sa - disable SA for receive</span>
<span id="L4333"><span class="lineNum">    4333</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4334"><span class="lineNum">    4334</span>              :          * @sa: secure association</span>
<span id="L4335"><span class="lineNum">    4335</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4336"><span class="lineNum">    4336</span>              :          */</span>
<span id="L4337"><span class="lineNum">    4337</span>              :         int (*disable_receive_sa)(void *priv, struct receive_sa *sa);</span>
<span id="L4338"><span class="lineNum">    4338</span>              : </span>
<span id="L4339"><span class="lineNum">    4339</span>              :         /**</span>
<span id="L4340"><span class="lineNum">    4340</span>              :          * create_transmit_sc - create secure connection for transmit</span>
<span id="L4341"><span class="lineNum">    4341</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4342"><span class="lineNum">    4342</span>              :          * @sc: secure channel</span>
<span id="L4343"><span class="lineNum">    4343</span>              :          * @conf_offset: confidentiality offset (0, 30, or 50)</span>
<span id="L4344"><span class="lineNum">    4344</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4345"><span class="lineNum">    4345</span>              :          */</span>
<span id="L4346"><span class="lineNum">    4346</span>              :         int (*create_transmit_sc)(void *priv, struct transmit_sc *sc,</span>
<span id="L4347"><span class="lineNum">    4347</span>              :                                   unsigned int conf_offset);</span>
<span id="L4348"><span class="lineNum">    4348</span>              : </span>
<span id="L4349"><span class="lineNum">    4349</span>              :         /**</span>
<span id="L4350"><span class="lineNum">    4350</span>              :          * delete_transmit_sc - delete secure connection for transmit</span>
<span id="L4351"><span class="lineNum">    4351</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4352"><span class="lineNum">    4352</span>              :          * @sc: secure channel</span>
<span id="L4353"><span class="lineNum">    4353</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4354"><span class="lineNum">    4354</span>              :          */</span>
<span id="L4355"><span class="lineNum">    4355</span>              :         int (*delete_transmit_sc)(void *priv, struct transmit_sc *sc);</span>
<span id="L4356"><span class="lineNum">    4356</span>              : </span>
<span id="L4357"><span class="lineNum">    4357</span>              :         /**</span>
<span id="L4358"><span class="lineNum">    4358</span>              :          * create_transmit_sa - create secure association for transmit</span>
<span id="L4359"><span class="lineNum">    4359</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4360"><span class="lineNum">    4360</span>              :          * @sa: secure association</span>
<span id="L4361"><span class="lineNum">    4361</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4362"><span class="lineNum">    4362</span>              :          */</span>
<span id="L4363"><span class="lineNum">    4363</span>              :         int (*create_transmit_sa)(void *priv, struct transmit_sa *sa);</span>
<span id="L4364"><span class="lineNum">    4364</span>              : </span>
<span id="L4365"><span class="lineNum">    4365</span>              :         /**</span>
<span id="L4366"><span class="lineNum">    4366</span>              :          * delete_transmit_sa - Delete secure association for transmit</span>
<span id="L4367"><span class="lineNum">    4367</span>              :          * @priv: Private driver interface data from init()</span>
<span id="L4368"><span class="lineNum">    4368</span>              :          * @sa: Secure association</span>
<span id="L4369"><span class="lineNum">    4369</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4370"><span class="lineNum">    4370</span>              :          */</span>
<span id="L4371"><span class="lineNum">    4371</span>              :         int (*delete_transmit_sa)(void *priv, struct transmit_sa *sa);</span>
<span id="L4372"><span class="lineNum">    4372</span>              : </span>
<span id="L4373"><span class="lineNum">    4373</span>              :         /**</span>
<span id="L4374"><span class="lineNum">    4374</span>              :          * enable_transmit_sa - enable SA for transmit</span>
<span id="L4375"><span class="lineNum">    4375</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4376"><span class="lineNum">    4376</span>              :          * @sa: secure association</span>
<span id="L4377"><span class="lineNum">    4377</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4378"><span class="lineNum">    4378</span>              :          */</span>
<span id="L4379"><span class="lineNum">    4379</span>              :         int (*enable_transmit_sa)(void *priv, struct transmit_sa *sa);</span>
<span id="L4380"><span class="lineNum">    4380</span>              : </span>
<span id="L4381"><span class="lineNum">    4381</span>              :         /**</span>
<span id="L4382"><span class="lineNum">    4382</span>              :          * disable_transmit_sa - disable SA for transmit</span>
<span id="L4383"><span class="lineNum">    4383</span>              :          * @priv: private driver interface data from init()</span>
<span id="L4384"><span class="lineNum">    4384</span>              :          * @sa: secure association</span>
<span id="L4385"><span class="lineNum">    4385</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4386"><span class="lineNum">    4386</span>              :          */</span>
<span id="L4387"><span class="lineNum">    4387</span>              :         int (*disable_transmit_sa)(void *priv, struct transmit_sa *sa);</span>
<span id="L4388"><span class="lineNum">    4388</span>              : #endif /* CONFIG_MACSEC */</span>
<span id="L4389"><span class="lineNum">    4389</span>              : </span>
<span id="L4390"><span class="lineNum">    4390</span>              :         /**</span>
<span id="L4391"><span class="lineNum">    4391</span>              :          * init_mesh - Driver specific initialization for mesh</span>
<span id="L4392"><span class="lineNum">    4392</span>              :          * @priv: Private driver interface data</span>
<span id="L4393"><span class="lineNum">    4393</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4394"><span class="lineNum">    4394</span>              :          */</span>
<span id="L4395"><span class="lineNum">    4395</span>              :         int (*init_mesh)(void *priv);</span>
<span id="L4396"><span class="lineNum">    4396</span>              : </span>
<span id="L4397"><span class="lineNum">    4397</span>              :         /**</span>
<span id="L4398"><span class="lineNum">    4398</span>              :          * join_mesh - Join a mesh network</span>
<span id="L4399"><span class="lineNum">    4399</span>              :          * @priv: Private driver interface data</span>
<span id="L4400"><span class="lineNum">    4400</span>              :          * @params: Mesh configuration parameters</span>
<span id="L4401"><span class="lineNum">    4401</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4402"><span class="lineNum">    4402</span>              :          */</span>
<span id="L4403"><span class="lineNum">    4403</span>              :         int (*join_mesh)(void *priv,</span>
<span id="L4404"><span class="lineNum">    4404</span>              :                          struct wpa_driver_mesh_join_params *params);</span>
<span id="L4405"><span class="lineNum">    4405</span>              : </span>
<span id="L4406"><span class="lineNum">    4406</span>              :         /**</span>
<span id="L4407"><span class="lineNum">    4407</span>              :          * leave_mesh - Leave a mesh network</span>
<span id="L4408"><span class="lineNum">    4408</span>              :          * @priv: Private driver interface data</span>
<span id="L4409"><span class="lineNum">    4409</span>              :          * Returns 0 on success, -1 on failure</span>
<span id="L4410"><span class="lineNum">    4410</span>              :          */</span>
<span id="L4411"><span class="lineNum">    4411</span>              :         int (*leave_mesh)(void *priv);</span>
<span id="L4412"><span class="lineNum">    4412</span>              : </span>
<span id="L4413"><span class="lineNum">    4413</span>              :         /**</span>
<span id="L4414"><span class="lineNum">    4414</span>              :          * probe_mesh_link - Inject a frame over direct mesh link to a given</span>
<span id="L4415"><span class="lineNum">    4415</span>              :          *      peer skipping the next_hop lookup from mpath table.</span>
<span id="L4416"><span class="lineNum">    4416</span>              :          * @priv: Private driver interface data</span>
<span id="L4417"><span class="lineNum">    4417</span>              :          * @addr: Peer MAC address</span>
<span id="L4418"><span class="lineNum">    4418</span>              :          * @eth: Ethernet frame to be sent</span>
<span id="L4419"><span class="lineNum">    4419</span>              :          * @len: Ethernet frame lengtn in bytes</span>
<span id="L4420"><span class="lineNum">    4420</span>              :          * Returns 0 on success, -1 on failure</span>
<span id="L4421"><span class="lineNum">    4421</span>              :          */</span>
<span id="L4422"><span class="lineNum">    4422</span>              :         int (*probe_mesh_link)(void *priv, const u8 *addr, const u8 *eth,</span>
<span id="L4423"><span class="lineNum">    4423</span>              :                                size_t len);</span>
<span id="L4424"><span class="lineNum">    4424</span>              : </span>
<span id="L4425"><span class="lineNum">    4425</span>              :         /**</span>
<span id="L4426"><span class="lineNum">    4426</span>              :          * do_acs - Automatically select channel</span>
<span id="L4427"><span class="lineNum">    4427</span>              :          * @priv: Private driver interface data</span>
<span id="L4428"><span class="lineNum">    4428</span>              :          * @params: Parameters for ACS</span>
<span id="L4429"><span class="lineNum">    4429</span>              :          * Returns 0 on success, -1 on failure</span>
<span id="L4430"><span class="lineNum">    4430</span>              :          *</span>
<span id="L4431"><span class="lineNum">    4431</span>              :          * This command can be used to offload ACS to the driver if the driver</span>
<span id="L4432"><span class="lineNum">    4432</span>              :          * indicates support for such offloading (WPA_DRIVER_FLAGS_ACS_OFFLOAD).</span>
<span id="L4433"><span class="lineNum">    4433</span>              :          */</span>
<span id="L4434"><span class="lineNum">    4434</span>              :         int (*do_acs)(void *priv, struct drv_acs_params *params);</span>
<span id="L4435"><span class="lineNum">    4435</span>              : </span>
<span id="L4436"><span class="lineNum">    4436</span>              :         /**</span>
<span id="L4437"><span class="lineNum">    4437</span>              :          * set_band - Notify driver of band(s) selection</span>
<span id="L4438"><span class="lineNum">    4438</span>              :          * @priv: Private driver interface data</span>
<span id="L4439"><span class="lineNum">    4439</span>              :          * @band_mask: The selected band(s) bit mask (from enum set_band)</span>
<span id="L4440"><span class="lineNum">    4440</span>              :          * Returns 0 on success, -1 on failure</span>
<span id="L4441"><span class="lineNum">    4441</span>              :          */</span>
<span id="L4442"><span class="lineNum">    4442</span>              :         int (*set_band)(void *priv, u32 band_mask);</span>
<span id="L4443"><span class="lineNum">    4443</span>              : </span>
<span id="L4444"><span class="lineNum">    4444</span>              :         /**</span>
<span id="L4445"><span class="lineNum">    4445</span>              :          * get_pref_freq_list - Get preferred frequency list for an interface</span>
<span id="L4446"><span class="lineNum">    4446</span>              :          * @priv: Private driver interface data</span>
<span id="L4447"><span class="lineNum">    4447</span>              :          * @if_type: Interface type</span>
<span id="L4448"><span class="lineNum">    4448</span>              :          * @num: Number of channels</span>
<span id="L4449"><span class="lineNum">    4449</span>              :          * @freq_list: Preferred channel frequency list encoded in MHz values</span>
<span id="L4450"><span class="lineNum">    4450</span>              :          * Returns 0 on success, -1 on failure</span>
<span id="L4451"><span class="lineNum">    4451</span>              :          *</span>
<span id="L4452"><span class="lineNum">    4452</span>              :          * This command can be used to query the preferred frequency list from</span>
<span id="L4453"><span class="lineNum">    4453</span>              :          * the driver specific to a particular interface type.</span>
<span id="L4454"><span class="lineNum">    4454</span>              :          */</span>
<span id="L4455"><span class="lineNum">    4455</span>              :         int (*get_pref_freq_list)(void *priv, enum wpa_driver_if_type if_type,</span>
<span id="L4456"><span class="lineNum">    4456</span>              :                                   unsigned int *num, unsigned int *freq_list);</span>
<span id="L4457"><span class="lineNum">    4457</span>              : </span>
<span id="L4458"><span class="lineNum">    4458</span>              :         /**</span>
<span id="L4459"><span class="lineNum">    4459</span>              :          * set_prob_oper_freq - Indicate probable P2P operating channel</span>
<span id="L4460"><span class="lineNum">    4460</span>              :          * @priv: Private driver interface data</span>
<span id="L4461"><span class="lineNum">    4461</span>              :          * @freq: Channel frequency in MHz</span>
<span id="L4462"><span class="lineNum">    4462</span>              :          * Returns 0 on success, -1 on failure</span>
<span id="L4463"><span class="lineNum">    4463</span>              :          *</span>
<span id="L4464"><span class="lineNum">    4464</span>              :          * This command can be used to inform the driver of the operating</span>
<span id="L4465"><span class="lineNum">    4465</span>              :          * frequency that an ongoing P2P group formation is likely to come up</span>
<span id="L4466"><span class="lineNum">    4466</span>              :          * on. Local device is assuming P2P Client role.</span>
<span id="L4467"><span class="lineNum">    4467</span>              :          */</span>
<span id="L4468"><span class="lineNum">    4468</span>              :         int (*set_prob_oper_freq)(void *priv, unsigned int freq);</span>
<span id="L4469"><span class="lineNum">    4469</span>              : </span>
<span id="L4470"><span class="lineNum">    4470</span>              :         /**</span>
<span id="L4471"><span class="lineNum">    4471</span>              :          * abort_scan - Request the driver to abort an ongoing scan</span>
<span id="L4472"><span class="lineNum">    4472</span>              :          * @priv: Private driver interface data</span>
<span id="L4473"><span class="lineNum">    4473</span>              :          * @scan_cookie: Cookie identifying the scan request. This is used only</span>
<span id="L4474"><span class="lineNum">    4474</span>              :          *      when the vendor interface QCA_NL80211_VENDOR_SUBCMD_TRIGGER_SCAN</span>
<span id="L4475"><span class="lineNum">    4475</span>              :          *      was used to trigger scan. Otherwise, 0 is used.</span>
<span id="L4476"><span class="lineNum">    4476</span>              :          * Returns 0 on success, -1 on failure</span>
<span id="L4477"><span class="lineNum">    4477</span>              :          */</span>
<span id="L4478"><span class="lineNum">    4478</span>              :         int (*abort_scan)(void *priv, u64 scan_cookie);</span>
<span id="L4479"><span class="lineNum">    4479</span>              : </span>
<span id="L4480"><span class="lineNum">    4480</span>              :         /**</span>
<span id="L4481"><span class="lineNum">    4481</span>              :          * configure_data_frame_filters - Request to configure frame filters</span>
<span id="L4482"><span class="lineNum">    4482</span>              :          * @priv: Private driver interface data</span>
<span id="L4483"><span class="lineNum">    4483</span>              :          * @filter_flags: The type of frames to filter (bitfield of</span>
<span id="L4484"><span class="lineNum">    4484</span>              :          * WPA_DATA_FRAME_FILTER_FLAG_*)</span>
<span id="L4485"><span class="lineNum">    4485</span>              :          * Returns: 0 on success or -1 on failure</span>
<span id="L4486"><span class="lineNum">    4486</span>              :          */</span>
<span id="L4487"><span class="lineNum">    4487</span>              :         int (*configure_data_frame_filters)(void *priv, u32 filter_flags);</span>
<span id="L4488"><span class="lineNum">    4488</span>              : </span>
<span id="L4489"><span class="lineNum">    4489</span>              :         /**</span>
<span id="L4490"><span class="lineNum">    4490</span>              :          * get_ext_capab - Get extended capabilities for the specified interface</span>
<span id="L4491"><span class="lineNum">    4491</span>              :          * @priv: Private driver interface data</span>
<span id="L4492"><span class="lineNum">    4492</span>              :          * @type: Interface type for which to get extended capabilities</span>
<span id="L4493"><span class="lineNum">    4493</span>              :          * @ext_capab: Extended capabilities fetched</span>
<span id="L4494"><span class="lineNum">    4494</span>              :          * @ext_capab_mask: Extended capabilities mask</span>
<span id="L4495"><span class="lineNum">    4495</span>              :          * @ext_capab_len: Length of the extended capabilities</span>
<span id="L4496"><span class="lineNum">    4496</span>              :          * Returns: 0 on success or -1 on failure</span>
<span id="L4497"><span class="lineNum">    4497</span>              :          */</span>
<span id="L4498"><span class="lineNum">    4498</span>              :         int (*get_ext_capab)(void *priv, enum wpa_driver_if_type type,</span>
<span id="L4499"><span class="lineNum">    4499</span>              :                              const u8 **ext_capab, const u8 **ext_capab_mask,</span>
<span id="L4500"><span class="lineNum">    4500</span>              :                              unsigned int *ext_capab_len);</span>
<span id="L4501"><span class="lineNum">    4501</span>              : </span>
<span id="L4502"><span class="lineNum">    4502</span>              :         /**</span>
<span id="L4503"><span class="lineNum">    4503</span>              :          * p2p_lo_start - Start offloading P2P listen to device</span>
<span id="L4504"><span class="lineNum">    4504</span>              :          * @priv: Private driver interface data</span>
<span id="L4505"><span class="lineNum">    4505</span>              :          * @freq: Listening frequency (MHz) for P2P listen</span>
<span id="L4506"><span class="lineNum">    4506</span>              :          * @period: Length of the listen operation in milliseconds</span>
<span id="L4507"><span class="lineNum">    4507</span>              :          * @interval: Interval for running the listen operation in milliseconds</span>
<span id="L4508"><span class="lineNum">    4508</span>              :          * @count: Number of times to run the listen operation</span>
<span id="L4509"><span class="lineNum">    4509</span>              :          * @device_types: Device primary and secondary types</span>
<span id="L4510"><span class="lineNum">    4510</span>              :          * @dev_types_len: Number of bytes for device_types</span>
<span id="L4511"><span class="lineNum">    4511</span>              :          * @ies: P2P IE and WSC IE for Probe Response frames</span>
<span id="L4512"><span class="lineNum">    4512</span>              :          * @ies_len: Length of ies in bytes</span>
<span id="L4513"><span class="lineNum">    4513</span>              :          * Returns: 0 on success or -1 on failure</span>
<span id="L4514"><span class="lineNum">    4514</span>              :          */</span>
<span id="L4515"><span class="lineNum">    4515</span>              :         int (*p2p_lo_start)(void *priv, unsigned int freq,</span>
<span id="L4516"><span class="lineNum">    4516</span>              :                             unsigned int period, unsigned int interval,</span>
<span id="L4517"><span class="lineNum">    4517</span>              :                             unsigned int count,</span>
<span id="L4518"><span class="lineNum">    4518</span>              :                             const u8 *device_types, size_t dev_types_len,</span>
<span id="L4519"><span class="lineNum">    4519</span>              :                             const u8 *ies, size_t ies_len);</span>
<span id="L4520"><span class="lineNum">    4520</span>              : </span>
<span id="L4521"><span class="lineNum">    4521</span>              :         /**</span>
<span id="L4522"><span class="lineNum">    4522</span>              :          * p2p_lo_stop - Stop P2P listen offload</span>
<span id="L4523"><span class="lineNum">    4523</span>              :          * @priv: Private driver interface data</span>
<span id="L4524"><span class="lineNum">    4524</span>              :          * Returns: 0 on success or -1 on failure</span>
<span id="L4525"><span class="lineNum">    4525</span>              :          */</span>
<span id="L4526"><span class="lineNum">    4526</span>              :         int (*p2p_lo_stop)(void *priv);</span>
<span id="L4527"><span class="lineNum">    4527</span>              : </span>
<span id="L4528"><span class="lineNum">    4528</span>              :         /**</span>
<span id="L4529"><span class="lineNum">    4529</span>              :          * set_default_scan_ies - Set default scan IEs</span>
<span id="L4530"><span class="lineNum">    4530</span>              :          * @priv: Private driver interface data</span>
<span id="L4531"><span class="lineNum">    4531</span>              :          * @ies: Scan default IEs buffer</span>
<span id="L4532"><span class="lineNum">    4532</span>              :          * @ies_len: Length of IEs in bytes</span>
<span id="L4533"><span class="lineNum">    4533</span>              :          * Returns: 0 on success or -1 on failure</span>
<span id="L4534"><span class="lineNum">    4534</span>              :          *</span>
<span id="L4535"><span class="lineNum">    4535</span>              :          * The driver can use these by default when there are no scan IEs coming</span>
<span id="L4536"><span class="lineNum">    4536</span>              :          * in the subsequent scan requests. Also in case of one or more of IEs</span>
<span id="L4537"><span class="lineNum">    4537</span>              :          * given in set_default_scan_ies() are missing in the subsequent scan</span>
<span id="L4538"><span class="lineNum">    4538</span>              :          * request, the driver should merge the missing scan IEs in the scan</span>
<span id="L4539"><span class="lineNum">    4539</span>              :          * request from the IEs set by set_default_scan_ies() in the Probe</span>
<span id="L4540"><span class="lineNum">    4540</span>              :          * Request frames sent.</span>
<span id="L4541"><span class="lineNum">    4541</span>              :          */</span>
<span id="L4542"><span class="lineNum">    4542</span>              :         int (*set_default_scan_ies)(void *priv, const u8 *ies, size_t ies_len);</span>
<span id="L4543"><span class="lineNum">    4543</span>              : </span>
<span id="L4544"><span class="lineNum">    4544</span>              :         /**</span>
<span id="L4545"><span class="lineNum">    4545</span>              :          * set_tdls_mode - Set TDLS trigger mode to the host driver</span>
<span id="L4546"><span class="lineNum">    4546</span>              :          * @priv: Private driver interface data</span>
<span id="L4547"><span class="lineNum">    4547</span>              :          * @tdls_external_control: Represents if TDLS external trigger control</span>
<span id="L4548"><span class="lineNum">    4548</span>              :          *  mode is enabled/disabled.</span>
<span id="L4549"><span class="lineNum">    4549</span>              :          *</span>
<span id="L4550"><span class="lineNum">    4550</span>              :          * This optional callback can be used to configure the TDLS external</span>
<span id="L4551"><span class="lineNum">    4551</span>              :          * trigger control mode to the host driver.</span>
<span id="L4552"><span class="lineNum">    4552</span>              :          */</span>
<span id="L4553"><span class="lineNum">    4553</span>              :         int (*set_tdls_mode)(void *priv, int tdls_external_control);</span>
<span id="L4554"><span class="lineNum">    4554</span>              : </span>
<span id="L4555"><span class="lineNum">    4555</span>              :         /**</span>
<span id="L4556"><span class="lineNum">    4556</span>              :          * get_bss_transition_status - Get candidate BSS's transition status</span>
<span id="L4557"><span class="lineNum">    4557</span>              :          * @priv: Private driver interface data</span>
<span id="L4558"><span class="lineNum">    4558</span>              :          * @params: Candidate BSS list</span>
<span id="L4559"><span class="lineNum">    4559</span>              :          *</span>
<span id="L4560"><span class="lineNum">    4560</span>              :          * Get the accept or reject reason code for a list of BSS transition</span>
<span id="L4561"><span class="lineNum">    4561</span>              :          * candidates.</span>
<span id="L4562"><span class="lineNum">    4562</span>              :          */</span>
<span id="L4563"><span class="lineNum">    4563</span>              :         struct wpa_bss_candidate_info *</span>
<span id="L4564"><span class="lineNum">    4564</span>              :         (*get_bss_transition_status)(void *priv,</span>
<span id="L4565"><span class="lineNum">    4565</span>              :                                      struct wpa_bss_trans_info *params);</span>
<span id="L4566"><span class="lineNum">    4566</span>              :         /**</span>
<span id="L4567"><span class="lineNum">    4567</span>              :          * ignore_assoc_disallow - Configure driver to ignore assoc_disallow</span>
<span id="L4568"><span class="lineNum">    4568</span>              :          * @priv: Private driver interface data</span>
<span id="L4569"><span class="lineNum">    4569</span>              :          * @ignore_disallow: 0 to not ignore, 1 to ignore</span>
<span id="L4570"><span class="lineNum">    4570</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4571"><span class="lineNum">    4571</span>              :          */</span>
<span id="L4572"><span class="lineNum">    4572</span>              :         int (*ignore_assoc_disallow)(void *priv, int ignore_disallow);</span>
<span id="L4573"><span class="lineNum">    4573</span>              : </span>
<span id="L4574"><span class="lineNum">    4574</span>              :         /**</span>
<span id="L4575"><span class="lineNum">    4575</span>              :          * set_bssid_tmp_disallow - Set disallowed BSSIDs to the driver</span>
<span id="L4576"><span class="lineNum">    4576</span>              :          * @priv: Private driver interface data</span>
<span id="L4577"><span class="lineNum">    4577</span>              :          * @num_bssid: Number of temporarily disallowed BSSIDs</span>
<span id="L4578"><span class="lineNum">    4578</span>              :          * @bssids: List of temporarily disallowed BSSIDs</span>
<span id="L4579"><span class="lineNum">    4579</span>              :          */</span>
<span id="L4580"><span class="lineNum">    4580</span>              :         int (*set_bssid_tmp_disallow)(void *priv, unsigned int num_bssid,</span>
<span id="L4581"><span class="lineNum">    4581</span>              :                                       const u8 *bssid);</span>
<span id="L4582"><span class="lineNum">    4582</span>              : </span>
<span id="L4583"><span class="lineNum">    4583</span>              :         /**</span>
<span id="L4584"><span class="lineNum">    4584</span>              :          * update_connect_params - Update the connection parameters</span>
<span id="L4585"><span class="lineNum">    4585</span>              :          * @priv: Private driver interface data</span>
<span id="L4586"><span class="lineNum">    4586</span>              :          * @params: Association parameters</span>
<span id="L4587"><span class="lineNum">    4587</span>              :          * @mask: Bit mask indicating which parameters in @params have to be</span>
<span id="L4588"><span class="lineNum">    4588</span>              :          *      updated</span>
<span id="L4589"><span class="lineNum">    4589</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4590"><span class="lineNum">    4590</span>              :          *</span>
<span id="L4591"><span class="lineNum">    4591</span>              :          * Update the connection parameters when in connected state so that the</span>
<span id="L4592"><span class="lineNum">    4592</span>              :          * driver uses the updated parameters for subsequent roaming. This is</span>
<span id="L4593"><span class="lineNum">    4593</span>              :          * used only with drivers that implement internal BSS selection and</span>
<span id="L4594"><span class="lineNum">    4594</span>              :          * roaming.</span>
<span id="L4595"><span class="lineNum">    4595</span>              :          */</span>
<span id="L4596"><span class="lineNum">    4596</span>              :         int (*update_connect_params)(</span>
<span id="L4597"><span class="lineNum">    4597</span>              :                 void *priv, struct wpa_driver_associate_params *params,</span>
<span id="L4598"><span class="lineNum">    4598</span>              :                 enum wpa_drv_update_connect_params_mask mask);</span>
<span id="L4599"><span class="lineNum">    4599</span>              : </span>
<span id="L4600"><span class="lineNum">    4600</span>              :         /**</span>
<span id="L4601"><span class="lineNum">    4601</span>              :          * send_external_auth_status - Indicate the status of external</span>
<span id="L4602"><span class="lineNum">    4602</span>              :          * authentication processing to the host driver.</span>
<span id="L4603"><span class="lineNum">    4603</span>              :          * @priv: Private driver interface data</span>
<span id="L4604"><span class="lineNum">    4604</span>              :          * @params: Status of authentication processing.</span>
<span id="L4605"><span class="lineNum">    4605</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4606"><span class="lineNum">    4606</span>              :          */</span>
<span id="L4607"><span class="lineNum">    4607</span>              :         int (*send_external_auth_status)(void *priv,</span>
<span id="L4608"><span class="lineNum">    4608</span>              :                                          struct external_auth *params);</span>
<span id="L4609"><span class="lineNum">    4609</span>              : </span>
<span id="L4610"><span class="lineNum">    4610</span>              :         /**</span>
<span id="L4611"><span class="lineNum">    4611</span>              :          * set_4addr_mode - Set 4-address mode</span>
<span id="L4612"><span class="lineNum">    4612</span>              :          * @priv: Private driver interface data</span>
<span id="L4613"><span class="lineNum">    4613</span>              :          * @bridge_ifname: Bridge interface name</span>
<span id="L4614"><span class="lineNum">    4614</span>              :          * @val: 0 - disable 4addr mode, 1 - enable 4addr mode</span>
<span id="L4615"><span class="lineNum">    4615</span>              :          * Returns: 0 on success, &lt; 0 on failure</span>
<span id="L4616"><span class="lineNum">    4616</span>              :          */</span>
<span id="L4617"><span class="lineNum">    4617</span>              :         int (*set_4addr_mode)(void *priv, const char *bridge_ifname, int val);</span>
<span id="L4618"><span class="lineNum">    4618</span>              : </span>
<span id="L4619"><span class="lineNum">    4619</span>              :         /**</span>
<span id="L4620"><span class="lineNum">    4620</span>              :          * update_dh_ie - Update DH IE</span>
<span id="L4621"><span class="lineNum">    4621</span>              :          * @priv: Private driver interface data</span>
<span id="L4622"><span class="lineNum">    4622</span>              :          * @peer_mac: Peer MAC address</span>
<span id="L4623"><span class="lineNum">    4623</span>              :          * @reason_code: Reacon code</span>
<span id="L4624"><span class="lineNum">    4624</span>              :          * @ie: DH IE</span>
<span id="L4625"><span class="lineNum">    4625</span>              :          * @ie_len: DH IE length in bytes</span>
<span id="L4626"><span class="lineNum">    4626</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4627"><span class="lineNum">    4627</span>              :          *</span>
<span id="L4628"><span class="lineNum">    4628</span>              :          * This callback is used to let the driver know the DH processing result</span>
<span id="L4629"><span class="lineNum">    4629</span>              :          * and DH IE for a pending association.</span>
<span id="L4630"><span class="lineNum">    4630</span>              :          */</span>
<span id="L4631"><span class="lineNum">    4631</span>              :         int (*update_dh_ie)(void *priv, const u8 *peer_mac, u16 reason_code,</span>
<span id="L4632"><span class="lineNum">    4632</span>              :                             const u8 *ie, size_t ie_len);</span>
<span id="L4633"><span class="lineNum">    4633</span>              : </span>
<span id="L4634"><span class="lineNum">    4634</span>              :         /**</span>
<span id="L4635"><span class="lineNum">    4635</span>              :          * dpp_listen - Notify driver about start/stop of DPP listen</span>
<span id="L4636"><span class="lineNum">    4636</span>              :          * @priv: Private driver interface data</span>
<span id="L4637"><span class="lineNum">    4637</span>              :          * @enable: Whether listen state is enabled (or disabled)</span>
<span id="L4638"><span class="lineNum">    4638</span>              :          * Returns: 0 on success, -1 on failure</span>
<span id="L4639"><span class="lineNum">    4639</span>              :          *</span>
<span id="L4640"><span class="lineNum">    4640</span>              :          * This optional callback can be used to update RX frame filtering to</span>
<span id="L4641"><span class="lineNum">    4641</span>              :          * explicitly allow reception of broadcast Public Action frames.</span>
<span id="L4642"><span class="lineNum">    4642</span>              :          */</span>
<span id="L4643"><span class="lineNum">    4643</span>              :         int (*dpp_listen)(void *priv, bool enable);</span>
<span id="L4644"><span class="lineNum">    4644</span>              : </span>
<span id="L4645"><span class="lineNum">    4645</span>              : #ifdef CONFIG_TESTING_OPTIONS</span>
<span id="L4646"><span class="lineNum">    4646</span>              :         int (*register_frame)(void *priv, u16 type,</span>
<span id="L4647"><span class="lineNum">    4647</span>              :                               const u8 *match, size_t match_len,</span>
<span id="L4648"><span class="lineNum">    4648</span>              :                               bool multicast);</span>
<span id="L4649"><span class="lineNum">    4649</span>              : #endif /* CONFIG_TESTING_OPTIONS */</span>
<span id="L4650"><span class="lineNum">    4650</span>              : };</span>
<span id="L4651"><span class="lineNum">    4651</span>              : </span>
<span id="L4652"><span class="lineNum">    4652</span>              : /**</span>
<span id="L4653"><span class="lineNum">    4653</span>              :  * enum wpa_event_type - Event type for wpa_supplicant_event() calls</span>
<span id="L4654"><span class="lineNum">    4654</span>              :  */</span>
<span id="L4655"><span class="lineNum">    4655</span>              : enum wpa_event_type {</span>
<span id="L4656"><span class="lineNum">    4656</span>              :         /**</span>
<span id="L4657"><span class="lineNum">    4657</span>              :          * EVENT_ASSOC - Association completed</span>
<span id="L4658"><span class="lineNum">    4658</span>              :          *</span>
<span id="L4659"><span class="lineNum">    4659</span>              :          * This event needs to be delivered when the driver completes IEEE</span>
<span id="L4660"><span class="lineNum">    4660</span>              :          * 802.11 association or reassociation successfully.</span>
<span id="L4661"><span class="lineNum">    4661</span>              :          * wpa_driver_ops::get_bssid() is expected to provide the current BSSID</span>
<span id="L4662"><span class="lineNum">    4662</span>              :          * after this event has been generated. In addition, optional</span>
<span id="L4663"><span class="lineNum">    4663</span>              :          * EVENT_ASSOCINFO may be generated just before EVENT_ASSOC to provide</span>
<span id="L4664"><span class="lineNum">    4664</span>              :          * more information about the association. If the driver interface gets</span>
<span id="L4665"><span class="lineNum">    4665</span>              :          * both of these events at the same time, it can also include the</span>
<span id="L4666"><span class="lineNum">    4666</span>              :          * assoc_info data in EVENT_ASSOC call.</span>
<span id="L4667"><span class="lineNum">    4667</span>              :          */</span>
<span id="L4668"><span class="lineNum">    4668</span>              :         EVENT_ASSOC,</span>
<span id="L4669"><span class="lineNum">    4669</span>              : </span>
<span id="L4670"><span class="lineNum">    4670</span>              :         /**</span>
<span id="L4671"><span class="lineNum">    4671</span>              :          * EVENT_DISASSOC - Association lost</span>
<span id="L4672"><span class="lineNum">    4672</span>              :          *</span>
<span id="L4673"><span class="lineNum">    4673</span>              :          * This event should be called when association is lost either due to</span>
<span id="L4674"><span class="lineNum">    4674</span>              :          * receiving deauthenticate or disassociate frame from the AP or when</span>
<span id="L4675"><span class="lineNum">    4675</span>              :          * sending either of these frames to the current AP. If the driver</span>
<span id="L4676"><span class="lineNum">    4676</span>              :          * supports separate deauthentication event, EVENT_DISASSOC should only</span>
<span id="L4677"><span class="lineNum">    4677</span>              :          * be used for disassociation and EVENT_DEAUTH for deauthentication.</span>
<span id="L4678"><span class="lineNum">    4678</span>              :          * In AP mode, union wpa_event_data::disassoc_info is required.</span>
<span id="L4679"><span class="lineNum">    4679</span>              :          */</span>
<span id="L4680"><span class="lineNum">    4680</span>              :         EVENT_DISASSOC,</span>
<span id="L4681"><span class="lineNum">    4681</span>              : </span>
<span id="L4682"><span class="lineNum">    4682</span>              :         /**</span>
<span id="L4683"><span class="lineNum">    4683</span>              :          * EVENT_MICHAEL_MIC_FAILURE - Michael MIC (TKIP) detected</span>
<span id="L4684"><span class="lineNum">    4684</span>              :          *</span>
<span id="L4685"><span class="lineNum">    4685</span>              :          * This event must be delivered when a Michael MIC error is detected by</span>
<span id="L4686"><span class="lineNum">    4686</span>              :          * the local driver. Additional data for event processing is</span>
<span id="L4687"><span class="lineNum">    4687</span>              :          * provided with union wpa_event_data::michael_mic_failure. This</span>
<span id="L4688"><span class="lineNum">    4688</span>              :          * information is used to request new encryption key and to initiate</span>
<span id="L4689"><span class="lineNum">    4689</span>              :          * TKIP countermeasures if needed.</span>
<span id="L4690"><span class="lineNum">    4690</span>              :          */</span>
<span id="L4691"><span class="lineNum">    4691</span>              :         EVENT_MICHAEL_MIC_FAILURE,</span>
<span id="L4692"><span class="lineNum">    4692</span>              : </span>
<span id="L4693"><span class="lineNum">    4693</span>              :         /**</span>
<span id="L4694"><span class="lineNum">    4694</span>              :          * EVENT_SCAN_RESULTS - Scan results available</span>
<span id="L4695"><span class="lineNum">    4695</span>              :          *</span>
<span id="L4696"><span class="lineNum">    4696</span>              :          * This event must be called whenever scan results are available to be</span>
<span id="L4697"><span class="lineNum">    4697</span>              :          * fetched with struct wpa_driver_ops::get_scan_results(). This event</span>
<span id="L4698"><span class="lineNum">    4698</span>              :          * is expected to be used some time after struct wpa_driver_ops::scan()</span>
<span id="L4699"><span class="lineNum">    4699</span>              :          * is called. If the driver provides an unsolicited event when the scan</span>
<span id="L4700"><span class="lineNum">    4700</span>              :          * has been completed, this event can be used to trigger</span>
<span id="L4701"><span class="lineNum">    4701</span>              :          * EVENT_SCAN_RESULTS call. If such event is not available from the</span>
<span id="L4702"><span class="lineNum">    4702</span>              :          * driver, the driver wrapper code is expected to use a registered</span>
<span id="L4703"><span class="lineNum">    4703</span>              :          * timeout to generate EVENT_SCAN_RESULTS call after the time that the</span>
<span id="L4704"><span class="lineNum">    4704</span>              :          * scan is expected to be completed. Optional information about</span>
<span id="L4705"><span class="lineNum">    4705</span>              :          * completed scan can be provided with union wpa_event_data::scan_info.</span>
<span id="L4706"><span class="lineNum">    4706</span>              :          */</span>
<span id="L4707"><span class="lineNum">    4707</span>              :         EVENT_SCAN_RESULTS,</span>
<span id="L4708"><span class="lineNum">    4708</span>              : </span>
<span id="L4709"><span class="lineNum">    4709</span>              :         /**</span>
<span id="L4710"><span class="lineNum">    4710</span>              :          * EVENT_ASSOCINFO - Report optional extra information for association</span>
<span id="L4711"><span class="lineNum">    4711</span>              :          *</span>
<span id="L4712"><span class="lineNum">    4712</span>              :          * This event can be used to report extra association information for</span>
<span id="L4713"><span class="lineNum">    4713</span>              :          * EVENT_ASSOC processing. This extra information includes IEs from</span>
<span id="L4714"><span class="lineNum">    4714</span>              :          * association frames and Beacon/Probe Response frames in union</span>
<span id="L4715"><span class="lineNum">    4715</span>              :          * wpa_event_data::assoc_info. EVENT_ASSOCINFO must be send just before</span>
<span id="L4716"><span class="lineNum">    4716</span>              :          * EVENT_ASSOC. Alternatively, the driver interface can include</span>
<span id="L4717"><span class="lineNum">    4717</span>              :          * assoc_info data in the EVENT_ASSOC call if it has all the</span>
<span id="L4718"><span class="lineNum">    4718</span>              :          * information available at the same point.</span>
<span id="L4719"><span class="lineNum">    4719</span>              :          */</span>
<span id="L4720"><span class="lineNum">    4720</span>              :         EVENT_ASSOCINFO,</span>
<span id="L4721"><span class="lineNum">    4721</span>              : </span>
<span id="L4722"><span class="lineNum">    4722</span>              :         /**</span>
<span id="L4723"><span class="lineNum">    4723</span>              :          * EVENT_INTERFACE_STATUS - Report interface status changes</span>
<span id="L4724"><span class="lineNum">    4724</span>              :          *</span>
<span id="L4725"><span class="lineNum">    4725</span>              :          * This optional event can be used to report changes in interface</span>
<span id="L4726"><span class="lineNum">    4726</span>              :          * status (interface added/removed) using union</span>
<span id="L4727"><span class="lineNum">    4727</span>              :          * wpa_event_data::interface_status. This can be used to trigger</span>
<span id="L4728"><span class="lineNum">    4728</span>              :          * wpa_supplicant to stop and re-start processing for the interface,</span>
<span id="L4729"><span class="lineNum">    4729</span>              :          * e.g., when a cardbus card is ejected/inserted.</span>
<span id="L4730"><span class="lineNum">    4730</span>              :          */</span>
<span id="L4731"><span class="lineNum">    4731</span>              :         EVENT_INTERFACE_STATUS,</span>
<span id="L4732"><span class="lineNum">    4732</span>              : </span>
<span id="L4733"><span class="lineNum">    4733</span>              :         /**</span>
<span id="L4734"><span class="lineNum">    4734</span>              :          * EVENT_PMKID_CANDIDATE - Report a candidate AP for pre-authentication</span>
<span id="L4735"><span class="lineNum">    4735</span>              :          *</span>
<span id="L4736"><span class="lineNum">    4736</span>              :          * This event can be used to inform wpa_supplicant about candidates for</span>
<span id="L4737"><span class="lineNum">    4737</span>              :          * RSN (WPA2) pre-authentication. If wpa_supplicant is not responsible</span>
<span id="L4738"><span class="lineNum">    4738</span>              :          * for scan request (ap_scan=2 mode), this event is required for</span>
<span id="L4739"><span class="lineNum">    4739</span>              :          * pre-authentication. If wpa_supplicant is performing scan request</span>
<span id="L4740"><span class="lineNum">    4740</span>              :          * (ap_scan=1), this event is optional since scan results can be used</span>
<span id="L4741"><span class="lineNum">    4741</span>              :          * to add pre-authentication candidates. union</span>
<span id="L4742"><span class="lineNum">    4742</span>              :          * wpa_event_data::pmkid_candidate is used to report the BSSID of the</span>
<span id="L4743"><span class="lineNum">    4743</span>              :          * candidate and priority of the candidate, e.g., based on the signal</span>
<span id="L4744"><span class="lineNum">    4744</span>              :          * strength, in order to try to pre-authenticate first with candidates</span>
<span id="L4745"><span class="lineNum">    4745</span>              :          * that are most likely targets for re-association.</span>
<span id="L4746"><span class="lineNum">    4746</span>              :          *</span>
<span id="L4747"><span class="lineNum">    4747</span>              :          * EVENT_PMKID_CANDIDATE can be called whenever the driver has updates</span>
<span id="L4748"><span class="lineNum">    4748</span>              :          * on the candidate list. In addition, it can be called for the current</span>
<span id="L4749"><span class="lineNum">    4749</span>              :          * AP and APs that have existing PMKSA cache entries. wpa_supplicant</span>
<span id="L4750"><span class="lineNum">    4750</span>              :          * will automatically skip pre-authentication in cases where a valid</span>
<span id="L4751"><span class="lineNum">    4751</span>              :          * PMKSA exists. When more than one candidate exists, this event should</span>
<span id="L4752"><span class="lineNum">    4752</span>              :          * be generated once for each candidate.</span>
<span id="L4753"><span class="lineNum">    4753</span>              :          *</span>
<span id="L4754"><span class="lineNum">    4754</span>              :          * Driver will be notified about successful pre-authentication with</span>
<span id="L4755"><span class="lineNum">    4755</span>              :          * struct wpa_driver_ops::add_pmkid() calls.</span>
<span id="L4756"><span class="lineNum">    4756</span>              :          */</span>
<span id="L4757"><span class="lineNum">    4757</span>              :         EVENT_PMKID_CANDIDATE,</span>
<span id="L4758"><span class="lineNum">    4758</span>              : </span>
<span id="L4759"><span class="lineNum">    4759</span>              :         /**</span>
<span id="L4760"><span class="lineNum">    4760</span>              :          * EVENT_TDLS - Request TDLS operation</span>
<span id="L4761"><span class="lineNum">    4761</span>              :          *</span>
<span id="L4762"><span class="lineNum">    4762</span>              :          * This event can be used to request a TDLS operation to be performed.</span>
<span id="L4763"><span class="lineNum">    4763</span>              :          */</span>
<span id="L4764"><span class="lineNum">    4764</span>              :         EVENT_TDLS,</span>
<span id="L4765"><span class="lineNum">    4765</span>              : </span>
<span id="L4766"><span class="lineNum">    4766</span>              :         /**</span>
<span id="L4767"><span class="lineNum">    4767</span>              :          * EVENT_FT_RESPONSE - Report FT (IEEE 802.11r) response IEs</span>
<span id="L4768"><span class="lineNum">    4768</span>              :          *</span>
<span id="L4769"><span class="lineNum">    4769</span>              :          * The driver is expected to report the received FT IEs from</span>
<span id="L4770"><span class="lineNum">    4770</span>              :          * FT authentication sequence from the AP. The FT IEs are included in</span>
<span id="L4771"><span class="lineNum">    4771</span>              :          * the extra information in union wpa_event_data::ft_ies.</span>
<span id="L4772"><span class="lineNum">    4772</span>              :          */</span>
<span id="L4773"><span class="lineNum">    4773</span>              :         EVENT_FT_RESPONSE,</span>
<span id="L4774"><span class="lineNum">    4774</span>              : </span>
<span id="L4775"><span class="lineNum">    4775</span>              :         /**</span>
<span id="L4776"><span class="lineNum">    4776</span>              :          * EVENT_IBSS_RSN_START - Request RSN authentication in IBSS</span>
<span id="L4777"><span class="lineNum">    4777</span>              :          *</span>
<span id="L4778"><span class="lineNum">    4778</span>              :          * The driver can use this event to inform wpa_supplicant about a STA</span>
<span id="L4779"><span class="lineNum">    4779</span>              :          * in an IBSS with which protected frames could be exchanged. This</span>
<span id="L4780"><span class="lineNum">    4780</span>              :          * event starts RSN authentication with the other STA to authenticate</span>
<span id="L4781"><span class="lineNum">    4781</span>              :          * the STA and set up encryption keys with it.</span>
<span id="L4782"><span class="lineNum">    4782</span>              :          */</span>
<span id="L4783"><span class="lineNum">    4783</span>              :         EVENT_IBSS_RSN_START,</span>
<span id="L4784"><span class="lineNum">    4784</span>              : </span>
<span id="L4785"><span class="lineNum">    4785</span>              :         /**</span>
<span id="L4786"><span class="lineNum">    4786</span>              :          * EVENT_AUTH - Authentication result</span>
<span id="L4787"><span class="lineNum">    4787</span>              :          *</span>
<span id="L4788"><span class="lineNum">    4788</span>              :          * This event should be called when authentication attempt has been</span>
<span id="L4789"><span class="lineNum">    4789</span>              :          * completed. This is only used if the driver supports separate</span>
<span id="L4790"><span class="lineNum">    4790</span>              :          * authentication step (struct wpa_driver_ops::authenticate).</span>
<span id="L4791"><span class="lineNum">    4791</span>              :          * Information about authentication result is included in</span>
<span id="L4792"><span class="lineNum">    4792</span>              :          * union wpa_event_data::auth.</span>
<span id="L4793"><span class="lineNum">    4793</span>              :          */</span>
<span id="L4794"><span class="lineNum">    4794</span>              :         EVENT_AUTH,</span>
<span id="L4795"><span class="lineNum">    4795</span>              : </span>
<span id="L4796"><span class="lineNum">    4796</span>              :         /**</span>
<span id="L4797"><span class="lineNum">    4797</span>              :          * EVENT_DEAUTH - Authentication lost</span>
<span id="L4798"><span class="lineNum">    4798</span>              :          *</span>
<span id="L4799"><span class="lineNum">    4799</span>              :          * This event should be called when authentication is lost either due</span>
<span id="L4800"><span class="lineNum">    4800</span>              :          * to receiving deauthenticate frame from the AP or when sending that</span>
<span id="L4801"><span class="lineNum">    4801</span>              :          * frame to the current AP.</span>
<span id="L4802"><span class="lineNum">    4802</span>              :          * In AP mode, union wpa_event_data::deauth_info is required.</span>
<span id="L4803"><span class="lineNum">    4803</span>              :          */</span>
<span id="L4804"><span class="lineNum">    4804</span>              :         EVENT_DEAUTH,</span>
<span id="L4805"><span class="lineNum">    4805</span>              : </span>
<span id="L4806"><span class="lineNum">    4806</span>              :         /**</span>
<span id="L4807"><span class="lineNum">    4807</span>              :          * EVENT_ASSOC_REJECT - Association rejected</span>
<span id="L4808"><span class="lineNum">    4808</span>              :          *</span>
<span id="L4809"><span class="lineNum">    4809</span>              :          * This event should be called when (re)association attempt has been</span>
<span id="L4810"><span class="lineNum">    4810</span>              :          * rejected by the AP. Information about the association response is</span>
<span id="L4811"><span class="lineNum">    4811</span>              :          * included in union wpa_event_data::assoc_reject.</span>
<span id="L4812"><span class="lineNum">    4812</span>              :          */</span>
<span id="L4813"><span class="lineNum">    4813</span>              :         EVENT_ASSOC_REJECT,</span>
<span id="L4814"><span class="lineNum">    4814</span>              : </span>
<span id="L4815"><span class="lineNum">    4815</span>              :         /**</span>
<span id="L4816"><span class="lineNum">    4816</span>              :          * EVENT_AUTH_TIMED_OUT - Authentication timed out</span>
<span id="L4817"><span class="lineNum">    4817</span>              :          */</span>
<span id="L4818"><span class="lineNum">    4818</span>              :         EVENT_AUTH_TIMED_OUT,</span>
<span id="L4819"><span class="lineNum">    4819</span>              : </span>
<span id="L4820"><span class="lineNum">    4820</span>              :         /**</span>
<span id="L4821"><span class="lineNum">    4821</span>              :          * EVENT_ASSOC_TIMED_OUT - Association timed out</span>
<span id="L4822"><span class="lineNum">    4822</span>              :          */</span>
<span id="L4823"><span class="lineNum">    4823</span>              :         EVENT_ASSOC_TIMED_OUT,</span>
<span id="L4824"><span class="lineNum">    4824</span>              : </span>
<span id="L4825"><span class="lineNum">    4825</span>              :         /**</span>
<span id="L4826"><span class="lineNum">    4826</span>              :          * EVENT_WPS_BUTTON_PUSHED - Report hardware push button press for WPS</span>
<span id="L4827"><span class="lineNum">    4827</span>              :          */</span>
<span id="L4828"><span class="lineNum">    4828</span>              :         EVENT_WPS_BUTTON_PUSHED,</span>
<span id="L4829"><span class="lineNum">    4829</span>              : </span>
<span id="L4830"><span class="lineNum">    4830</span>              :         /**</span>
<span id="L4831"><span class="lineNum">    4831</span>              :          * EVENT_TX_STATUS - Report TX status</span>
<span id="L4832"><span class="lineNum">    4832</span>              :          */</span>
<span id="L4833"><span class="lineNum">    4833</span>              :         EVENT_TX_STATUS,</span>
<span id="L4834"><span class="lineNum">    4834</span>              : </span>
<span id="L4835"><span class="lineNum">    4835</span>              :         /**</span>
<span id="L4836"><span class="lineNum">    4836</span>              :          * EVENT_RX_FROM_UNKNOWN - Report RX from unknown STA</span>
<span id="L4837"><span class="lineNum">    4837</span>              :          */</span>
<span id="L4838"><span class="lineNum">    4838</span>              :         EVENT_RX_FROM_UNKNOWN,</span>
<span id="L4839"><span class="lineNum">    4839</span>              : </span>
<span id="L4840"><span class="lineNum">    4840</span>              :         /**</span>
<span id="L4841"><span class="lineNum">    4841</span>              :          * EVENT_RX_MGMT - Report RX of a management frame</span>
<span id="L4842"><span class="lineNum">    4842</span>              :          */</span>
<span id="L4843"><span class="lineNum">    4843</span>              :         EVENT_RX_MGMT,</span>
<span id="L4844"><span class="lineNum">    4844</span>              : </span>
<span id="L4845"><span class="lineNum">    4845</span>              :         /**</span>
<span id="L4846"><span class="lineNum">    4846</span>              :          * EVENT_REMAIN_ON_CHANNEL - Remain-on-channel duration started</span>
<span id="L4847"><span class="lineNum">    4847</span>              :          *</span>
<span id="L4848"><span class="lineNum">    4848</span>              :          * This event is used to indicate when the driver has started the</span>
<span id="L4849"><span class="lineNum">    4849</span>              :          * requested remain-on-channel duration. Information about the</span>
<span id="L4850"><span class="lineNum">    4850</span>              :          * operation is included in union wpa_event_data::remain_on_channel.</span>
<span id="L4851"><span class="lineNum">    4851</span>              :          */</span>
<span id="L4852"><span class="lineNum">    4852</span>              :         EVENT_REMAIN_ON_CHANNEL,</span>
<span id="L4853"><span class="lineNum">    4853</span>              : </span>
<span id="L4854"><span class="lineNum">    4854</span>              :         /**</span>
<span id="L4855"><span class="lineNum">    4855</span>              :          * EVENT_CANCEL_REMAIN_ON_CHANNEL - Remain-on-channel timed out</span>
<span id="L4856"><span class="lineNum">    4856</span>              :          *</span>
<span id="L4857"><span class="lineNum">    4857</span>              :          * This event is used to indicate when the driver has completed</span>
<span id="L4858"><span class="lineNum">    4858</span>              :          * remain-on-channel duration, i.e., may noot be available on the</span>
<span id="L4859"><span class="lineNum">    4859</span>              :          * requested channel anymore. Information about the</span>
<span id="L4860"><span class="lineNum">    4860</span>              :          * operation is included in union wpa_event_data::remain_on_channel.</span>
<span id="L4861"><span class="lineNum">    4861</span>              :          */</span>
<span id="L4862"><span class="lineNum">    4862</span>              :         EVENT_CANCEL_REMAIN_ON_CHANNEL,</span>
<span id="L4863"><span class="lineNum">    4863</span>              : </span>
<span id="L4864"><span class="lineNum">    4864</span>              :         /**</span>
<span id="L4865"><span class="lineNum">    4865</span>              :          * EVENT_RX_PROBE_REQ - Indicate received Probe Request frame</span>
<span id="L4866"><span class="lineNum">    4866</span>              :          *</span>
<span id="L4867"><span class="lineNum">    4867</span>              :          * This event is used to indicate when a Probe Request frame has been</span>
<span id="L4868"><span class="lineNum">    4868</span>              :          * received. Information about the received frame is included in</span>
<span id="L4869"><span class="lineNum">    4869</span>              :          * union wpa_event_data::rx_probe_req. The driver is required to report</span>
<span id="L4870"><span class="lineNum">    4870</span>              :          * these events only after successfully completed probe_req_report()</span>
<span id="L4871"><span class="lineNum">    4871</span>              :          * commands to request the events (i.e., report parameter is non-zero)</span>
<span id="L4872"><span class="lineNum">    4872</span>              :          * in station mode. In AP mode, Probe Request frames should always be</span>
<span id="L4873"><span class="lineNum">    4873</span>              :          * reported.</span>
<span id="L4874"><span class="lineNum">    4874</span>              :          */</span>
<span id="L4875"><span class="lineNum">    4875</span>              :         EVENT_RX_PROBE_REQ,</span>
<span id="L4876"><span class="lineNum">    4876</span>              : </span>
<span id="L4877"><span class="lineNum">    4877</span>              :         /**</span>
<span id="L4878"><span class="lineNum">    4878</span>              :          * EVENT_NEW_STA - New wired device noticed</span>
<span id="L4879"><span class="lineNum">    4879</span>              :          *</span>
<span id="L4880"><span class="lineNum">    4880</span>              :          * This event is used to indicate that a new device has been detected</span>
<span id="L4881"><span class="lineNum">    4881</span>              :          * in a network that does not use association-like functionality (i.e.,</span>
<span id="L4882"><span class="lineNum">    4882</span>              :          * mainly wired Ethernet). This can be used to start EAPOL</span>
<span id="L4883"><span class="lineNum">    4883</span>              :          * authenticator when receiving a frame from a device. The address of</span>
<span id="L4884"><span class="lineNum">    4884</span>              :          * the device is included in union wpa_event_data::new_sta.</span>
<span id="L4885"><span class="lineNum">    4885</span>              :          */</span>
<span id="L4886"><span class="lineNum">    4886</span>              :         EVENT_NEW_STA,</span>
<span id="L4887"><span class="lineNum">    4887</span>              : </span>
<span id="L4888"><span class="lineNum">    4888</span>              :         /**</span>
<span id="L4889"><span class="lineNum">    4889</span>              :          * EVENT_EAPOL_RX - Report received EAPOL frame</span>
<span id="L4890"><span class="lineNum">    4890</span>              :          *</span>
<span id="L4891"><span class="lineNum">    4891</span>              :          * When in AP mode with hostapd, this event is required to be used to</span>
<span id="L4892"><span class="lineNum">    4892</span>              :          * deliver the receive EAPOL frames from the driver.</span>
<span id="L4893"><span class="lineNum">    4893</span>              :          */</span>
<span id="L4894"><span class="lineNum">    4894</span>              :         EVENT_EAPOL_RX,</span>
<span id="L4895"><span class="lineNum">    4895</span>              : </span>
<span id="L4896"><span class="lineNum">    4896</span>              :         /**</span>
<span id="L4897"><span class="lineNum">    4897</span>              :          * EVENT_SIGNAL_CHANGE - Indicate change in signal strength</span>
<span id="L4898"><span class="lineNum">    4898</span>              :          *</span>
<span id="L4899"><span class="lineNum">    4899</span>              :          * This event is used to indicate changes in the signal strength</span>
<span id="L4900"><span class="lineNum">    4900</span>              :          * observed in frames received from the current AP if signal strength</span>
<span id="L4901"><span class="lineNum">    4901</span>              :          * monitoring has been enabled with signal_monitor().</span>
<span id="L4902"><span class="lineNum">    4902</span>              :          */</span>
<span id="L4903"><span class="lineNum">    4903</span>              :         EVENT_SIGNAL_CHANGE,</span>
<span id="L4904"><span class="lineNum">    4904</span>              : </span>
<span id="L4905"><span class="lineNum">    4905</span>              :         /**</span>
<span id="L4906"><span class="lineNum">    4906</span>              :          * EVENT_INTERFACE_ENABLED - Notify that interface was enabled</span>
<span id="L4907"><span class="lineNum">    4907</span>              :          *</span>
<span id="L4908"><span class="lineNum">    4908</span>              :          * This event is used to indicate that the interface was enabled after</span>
<span id="L4909"><span class="lineNum">    4909</span>              :          * having been previously disabled, e.g., due to rfkill.</span>
<span id="L4910"><span class="lineNum">    4910</span>              :          */</span>
<span id="L4911"><span class="lineNum">    4911</span>              :         EVENT_INTERFACE_ENABLED,</span>
<span id="L4912"><span class="lineNum">    4912</span>              : </span>
<span id="L4913"><span class="lineNum">    4913</span>              :         /**</span>
<span id="L4914"><span class="lineNum">    4914</span>              :          * EVENT_INTERFACE_DISABLED - Notify that interface was disabled</span>
<span id="L4915"><span class="lineNum">    4915</span>              :          *</span>
<span id="L4916"><span class="lineNum">    4916</span>              :          * This event is used to indicate that the interface was disabled,</span>
<span id="L4917"><span class="lineNum">    4917</span>              :          * e.g., due to rfkill.</span>
<span id="L4918"><span class="lineNum">    4918</span>              :          */</span>
<span id="L4919"><span class="lineNum">    4919</span>              :         EVENT_INTERFACE_DISABLED,</span>
<span id="L4920"><span class="lineNum">    4920</span>              : </span>
<span id="L4921"><span class="lineNum">    4921</span>              :         /**</span>
<span id="L4922"><span class="lineNum">    4922</span>              :          * EVENT_CHANNEL_LIST_CHANGED - Channel list changed</span>
<span id="L4923"><span class="lineNum">    4923</span>              :          *</span>
<span id="L4924"><span class="lineNum">    4924</span>              :          * This event is used to indicate that the channel list has changed,</span>
<span id="L4925"><span class="lineNum">    4925</span>              :          * e.g., because of a regulatory domain change triggered by scan</span>
<span id="L4926"><span class="lineNum">    4926</span>              :          * results including an AP advertising a country code.</span>
<span id="L4927"><span class="lineNum">    4927</span>              :          */</span>
<span id="L4928"><span class="lineNum">    4928</span>              :         EVENT_CHANNEL_LIST_CHANGED,</span>
<span id="L4929"><span class="lineNum">    4929</span>              : </span>
<span id="L4930"><span class="lineNum">    4930</span>              :         /**</span>
<span id="L4931"><span class="lineNum">    4931</span>              :          * EVENT_INTERFACE_UNAVAILABLE - Notify that interface is unavailable</span>
<span id="L4932"><span class="lineNum">    4932</span>              :          *</span>
<span id="L4933"><span class="lineNum">    4933</span>              :          * This event is used to indicate that the driver cannot maintain this</span>
<span id="L4934"><span class="lineNum">    4934</span>              :          * interface in its operation mode anymore. The most likely use for</span>
<span id="L4935"><span class="lineNum">    4935</span>              :          * this is to indicate that AP mode operation is not available due to</span>
<span id="L4936"><span class="lineNum">    4936</span>              :          * operating channel would need to be changed to a DFS channel when</span>
<span id="L4937"><span class="lineNum">    4937</span>              :          * the driver does not support radar detection and another virtual</span>
<span id="L4938"><span class="lineNum">    4938</span>              :          * interfaces caused the operating channel to change. Other similar</span>
<span id="L4939"><span class="lineNum">    4939</span>              :          * resource conflicts could also trigger this for station mode</span>
<span id="L4940"><span class="lineNum">    4940</span>              :          * interfaces. This event can be propagated when channel switching</span>
<span id="L4941"><span class="lineNum">    4941</span>              :          * fails.</span>
<span id="L4942"><span class="lineNum">    4942</span>              :          */</span>
<span id="L4943"><span class="lineNum">    4943</span>              :         EVENT_INTERFACE_UNAVAILABLE,</span>
<span id="L4944"><span class="lineNum">    4944</span>              : </span>
<span id="L4945"><span class="lineNum">    4945</span>              :         /**</span>
<span id="L4946"><span class="lineNum">    4946</span>              :          * EVENT_BEST_CHANNEL</span>
<span id="L4947"><span class="lineNum">    4947</span>              :          *</span>
<span id="L4948"><span class="lineNum">    4948</span>              :          * Driver generates this event whenever it detects a better channel</span>
<span id="L4949"><span class="lineNum">    4949</span>              :          * (e.g., based on RSSI or channel use). This information can be used</span>
<span id="L4950"><span class="lineNum">    4950</span>              :          * to improve channel selection for a new AP/P2P group.</span>
<span id="L4951"><span class="lineNum">    4951</span>              :          */</span>
<span id="L4952"><span class="lineNum">    4952</span>              :         EVENT_BEST_CHANNEL,</span>
<span id="L4953"><span class="lineNum">    4953</span>              : </span>
<span id="L4954"><span class="lineNum">    4954</span>              :         /**</span>
<span id="L4955"><span class="lineNum">    4955</span>              :          * EVENT_UNPROT_DEAUTH - Unprotected Deauthentication frame received</span>
<span id="L4956"><span class="lineNum">    4956</span>              :          *</span>
<span id="L4957"><span class="lineNum">    4957</span>              :          * This event should be called when a Deauthentication frame is dropped</span>
<span id="L4958"><span class="lineNum">    4958</span>              :          * due to it not being protected (MFP/IEEE 802.11w).</span>
<span id="L4959"><span class="lineNum">    4959</span>              :          * union wpa_event_data::unprot_deauth is required to provide more</span>
<span id="L4960"><span class="lineNum">    4960</span>              :          * details of the frame.</span>
<span id="L4961"><span class="lineNum">    4961</span>              :          */</span>
<span id="L4962"><span class="lineNum">    4962</span>              :         EVENT_UNPROT_DEAUTH,</span>
<span id="L4963"><span class="lineNum">    4963</span>              : </span>
<span id="L4964"><span class="lineNum">    4964</span>              :         /**</span>
<span id="L4965"><span class="lineNum">    4965</span>              :          * EVENT_UNPROT_DISASSOC - Unprotected Disassociation frame received</span>
<span id="L4966"><span class="lineNum">    4966</span>              :          *</span>
<span id="L4967"><span class="lineNum">    4967</span>              :          * This event should be called when a Disassociation frame is dropped</span>
<span id="L4968"><span class="lineNum">    4968</span>              :          * due to it not being protected (MFP/IEEE 802.11w).</span>
<span id="L4969"><span class="lineNum">    4969</span>              :          * union wpa_event_data::unprot_disassoc is required to provide more</span>
<span id="L4970"><span class="lineNum">    4970</span>              :          * details of the frame.</span>
<span id="L4971"><span class="lineNum">    4971</span>              :          */</span>
<span id="L4972"><span class="lineNum">    4972</span>              :         EVENT_UNPROT_DISASSOC,</span>
<span id="L4973"><span class="lineNum">    4973</span>              : </span>
<span id="L4974"><span class="lineNum">    4974</span>              :         /**</span>
<span id="L4975"><span class="lineNum">    4975</span>              :          * EVENT_STATION_LOW_ACK</span>
<span id="L4976"><span class="lineNum">    4976</span>              :          *</span>
<span id="L4977"><span class="lineNum">    4977</span>              :          * Driver generates this event whenever it detected that a particular</span>
<span id="L4978"><span class="lineNum">    4978</span>              :          * station was lost. Detection can be through massive transmission</span>
<span id="L4979"><span class="lineNum">    4979</span>              :          * failures for example.</span>
<span id="L4980"><span class="lineNum">    4980</span>              :          */</span>
<span id="L4981"><span class="lineNum">    4981</span>              :         EVENT_STATION_LOW_ACK,</span>
<span id="L4982"><span class="lineNum">    4982</span>              : </span>
<span id="L4983"><span class="lineNum">    4983</span>              :         /**</span>
<span id="L4984"><span class="lineNum">    4984</span>              :          * EVENT_IBSS_PEER_LOST - IBSS peer not reachable anymore</span>
<span id="L4985"><span class="lineNum">    4985</span>              :          */</span>
<span id="L4986"><span class="lineNum">    4986</span>              :         EVENT_IBSS_PEER_LOST,</span>
<span id="L4987"><span class="lineNum">    4987</span>              : </span>
<span id="L4988"><span class="lineNum">    4988</span>              :         /**</span>
<span id="L4989"><span class="lineNum">    4989</span>              :          * EVENT_DRIVER_GTK_REKEY - Device/driver did GTK rekey</span>
<span id="L4990"><span class="lineNum">    4990</span>              :          *</span>
<span id="L4991"><span class="lineNum">    4991</span>              :          * This event carries the new replay counter to notify wpa_supplicant</span>
<span id="L4992"><span class="lineNum">    4992</span>              :          * of the current EAPOL-Key Replay Counter in case the driver/firmware</span>
<span id="L4993"><span class="lineNum">    4993</span>              :          * completed Group Key Handshake while the host (including</span>
<span id="L4994"><span class="lineNum">    4994</span>              :          * wpa_supplicant was sleeping).</span>
<span id="L4995"><span class="lineNum">    4995</span>              :          */</span>
<span id="L4996"><span class="lineNum">    4996</span>              :         EVENT_DRIVER_GTK_REKEY,</span>
<span id="L4997"><span class="lineNum">    4997</span>              : </span>
<span id="L4998"><span class="lineNum">    4998</span>              :         /**</span>
<span id="L4999"><span class="lineNum">    4999</span>              :          * EVENT_SCHED_SCAN_STOPPED - Scheduled scan was stopped</span>
<span id="L5000"><span class="lineNum">    5000</span>              :          */</span>
<span id="L5001"><span class="lineNum">    5001</span>              :         EVENT_SCHED_SCAN_STOPPED,</span>
<span id="L5002"><span class="lineNum">    5002</span>              : </span>
<span id="L5003"><span class="lineNum">    5003</span>              :         /**</span>
<span id="L5004"><span class="lineNum">    5004</span>              :          * EVENT_DRIVER_CLIENT_POLL_OK - Station responded to poll</span>
<span id="L5005"><span class="lineNum">    5005</span>              :          *</span>
<span id="L5006"><span class="lineNum">    5006</span>              :          * This event indicates that the station responded to the poll</span>
<span id="L5007"><span class="lineNum">    5007</span>              :          * initiated with @poll_client.</span>
<span id="L5008"><span class="lineNum">    5008</span>              :          */</span>
<span id="L5009"><span class="lineNum">    5009</span>              :         EVENT_DRIVER_CLIENT_POLL_OK,</span>
<span id="L5010"><span class="lineNum">    5010</span>              : </span>
<span id="L5011"><span class="lineNum">    5011</span>              :         /**</span>
<span id="L5012"><span class="lineNum">    5012</span>              :          * EVENT_EAPOL_TX_STATUS - notify of EAPOL TX status</span>
<span id="L5013"><span class="lineNum">    5013</span>              :          */</span>
<span id="L5014"><span class="lineNum">    5014</span>              :         EVENT_EAPOL_TX_STATUS,</span>
<span id="L5015"><span class="lineNum">    5015</span>              : </span>
<span id="L5016"><span class="lineNum">    5016</span>              :         /**</span>
<span id="L5017"><span class="lineNum">    5017</span>              :          * EVENT_CH_SWITCH - AP or GO decided to switch channels</span>
<span id="L5018"><span class="lineNum">    5018</span>              :          *</span>
<span id="L5019"><span class="lineNum">    5019</span>              :          * Described in wpa_event_data.ch_switch</span>
<span id="L5020"><span class="lineNum">    5020</span>              :          * */</span>
<span id="L5021"><span class="lineNum">    5021</span>              :         EVENT_CH_SWITCH,</span>
<span id="L5022"><span class="lineNum">    5022</span>              : </span>
<span id="L5023"><span class="lineNum">    5023</span>              :         /**</span>
<span id="L5024"><span class="lineNum">    5024</span>              :          * EVENT_CH_SWITCH_STARTED - AP or GO started to switch channels</span>
<span id="L5025"><span class="lineNum">    5025</span>              :          *</span>
<span id="L5026"><span class="lineNum">    5026</span>              :          * This is a pre-switch event indicating the shortly following switch</span>
<span id="L5027"><span class="lineNum">    5027</span>              :          * of operating channels.</span>
<span id="L5028"><span class="lineNum">    5028</span>              :          *</span>
<span id="L5029"><span class="lineNum">    5029</span>              :          * Described in wpa_event_data.ch_switch</span>
<span id="L5030"><span class="lineNum">    5030</span>              :          */</span>
<span id="L5031"><span class="lineNum">    5031</span>              :         EVENT_CH_SWITCH_STARTED,</span>
<span id="L5032"><span class="lineNum">    5032</span>              :         /**</span>
<span id="L5033"><span class="lineNum">    5033</span>              :          * EVENT_WNM - Request WNM operation</span>
<span id="L5034"><span class="lineNum">    5034</span>              :          *</span>
<span id="L5035"><span class="lineNum">    5035</span>              :          * This event can be used to request a WNM operation to be performed.</span>
<span id="L5036"><span class="lineNum">    5036</span>              :          */</span>
<span id="L5037"><span class="lineNum">    5037</span>              :         EVENT_WNM,</span>
<span id="L5038"><span class="lineNum">    5038</span>              : </span>
<span id="L5039"><span class="lineNum">    5039</span>              :         /**</span>
<span id="L5040"><span class="lineNum">    5040</span>              :          * EVENT_CONNECT_FAILED_REASON - Connection failure reason in AP mode</span>
<span id="L5041"><span class="lineNum">    5041</span>              :          *</span>
<span id="L5042"><span class="lineNum">    5042</span>              :          * This event indicates that the driver reported a connection failure</span>
<span id="L5043"><span class="lineNum">    5043</span>              :          * with the specified client (for example, max client reached, etc.) in</span>
<span id="L5044"><span class="lineNum">    5044</span>              :          * AP mode.</span>
<span id="L5045"><span class="lineNum">    5045</span>              :          */</span>
<span id="L5046"><span class="lineNum">    5046</span>              :         EVENT_CONNECT_FAILED_REASON,</span>
<span id="L5047"><span class="lineNum">    5047</span>              : </span>
<span id="L5048"><span class="lineNum">    5048</span>              :         /**</span>
<span id="L5049"><span class="lineNum">    5049</span>              :          * EVENT_DFS_RADAR_DETECTED - Notify of radar detection</span>
<span id="L5050"><span class="lineNum">    5050</span>              :          *</span>
<span id="L5051"><span class="lineNum">    5051</span>              :          * A radar has been detected on the supplied frequency, hostapd should</span>
<span id="L5052"><span class="lineNum">    5052</span>              :          * react accordingly (e.g., change channel).</span>
<span id="L5053"><span class="lineNum">    5053</span>              :          */</span>
<span id="L5054"><span class="lineNum">    5054</span>              :         EVENT_DFS_RADAR_DETECTED,</span>
<span id="L5055"><span class="lineNum">    5055</span>              : </span>
<span id="L5056"><span class="lineNum">    5056</span>              :         /**</span>
<span id="L5057"><span class="lineNum">    5057</span>              :          * EVENT_DFS_CAC_FINISHED - Notify that channel availability check has been completed</span>
<span id="L5058"><span class="lineNum">    5058</span>              :          *</span>
<span id="L5059"><span class="lineNum">    5059</span>              :          * After a successful CAC, the channel can be marked clear and used.</span>
<span id="L5060"><span class="lineNum">    5060</span>              :          */</span>
<span id="L5061"><span class="lineNum">    5061</span>              :         EVENT_DFS_CAC_FINISHED,</span>
<span id="L5062"><span class="lineNum">    5062</span>              : </span>
<span id="L5063"><span class="lineNum">    5063</span>              :         /**</span>
<span id="L5064"><span class="lineNum">    5064</span>              :          * EVENT_DFS_CAC_ABORTED - Notify that channel availability check has been aborted</span>
<span id="L5065"><span class="lineNum">    5065</span>              :          *</span>
<span id="L5066"><span class="lineNum">    5066</span>              :          * The CAC was not successful, and the channel remains in the previous</span>
<span id="L5067"><span class="lineNum">    5067</span>              :          * state. This may happen due to a radar being detected or other</span>
<span id="L5068"><span class="lineNum">    5068</span>              :          * external influences.</span>
<span id="L5069"><span class="lineNum">    5069</span>              :          */</span>
<span id="L5070"><span class="lineNum">    5070</span>              :         EVENT_DFS_CAC_ABORTED,</span>
<span id="L5071"><span class="lineNum">    5071</span>              : </span>
<span id="L5072"><span class="lineNum">    5072</span>              :         /**</span>
<span id="L5073"><span class="lineNum">    5073</span>              :          * EVENT_DFS_NOP_FINISHED - Notify that non-occupancy period is over</span>
<span id="L5074"><span class="lineNum">    5074</span>              :          *</span>
<span id="L5075"><span class="lineNum">    5075</span>              :          * The channel which was previously unavailable is now available again.</span>
<span id="L5076"><span class="lineNum">    5076</span>              :          */</span>
<span id="L5077"><span class="lineNum">    5077</span>              :         EVENT_DFS_NOP_FINISHED,</span>
<span id="L5078"><span class="lineNum">    5078</span>              : </span>
<span id="L5079"><span class="lineNum">    5079</span>              :         /**</span>
<span id="L5080"><span class="lineNum">    5080</span>              :          * EVENT_SURVEY - Received survey data</span>
<span id="L5081"><span class="lineNum">    5081</span>              :          *</span>
<span id="L5082"><span class="lineNum">    5082</span>              :          * This event gets triggered when a driver query is issued for survey</span>
<span id="L5083"><span class="lineNum">    5083</span>              :          * data and the requested data becomes available. The returned data is</span>
<span id="L5084"><span class="lineNum">    5084</span>              :          * stored in struct survey_results. The results provide at most one</span>
<span id="L5085"><span class="lineNum">    5085</span>              :          * survey entry for each frequency and at minimum will provide one</span>
<span id="L5086"><span class="lineNum">    5086</span>              :          * survey entry for one frequency. The survey data can be os_malloc()'d</span>
<span id="L5087"><span class="lineNum">    5087</span>              :          * and then os_free()'d, so the event callback must only copy data.</span>
<span id="L5088"><span class="lineNum">    5088</span>              :          */</span>
<span id="L5089"><span class="lineNum">    5089</span>              :         EVENT_SURVEY,</span>
<span id="L5090"><span class="lineNum">    5090</span>              : </span>
<span id="L5091"><span class="lineNum">    5091</span>              :         /**</span>
<span id="L5092"><span class="lineNum">    5092</span>              :          * EVENT_SCAN_STARTED - Scan started</span>
<span id="L5093"><span class="lineNum">    5093</span>              :          *</span>
<span id="L5094"><span class="lineNum">    5094</span>              :          * This indicates that driver has started a scan operation either based</span>
<span id="L5095"><span class="lineNum">    5095</span>              :          * on a request from wpa_supplicant/hostapd or from another application.</span>
<span id="L5096"><span class="lineNum">    5096</span>              :          * EVENT_SCAN_RESULTS is used to indicate when the scan has been</span>
<span id="L5097"><span class="lineNum">    5097</span>              :          * completed (either successfully or by getting cancelled).</span>
<span id="L5098"><span class="lineNum">    5098</span>              :          */</span>
<span id="L5099"><span class="lineNum">    5099</span>              :         EVENT_SCAN_STARTED,</span>
<span id="L5100"><span class="lineNum">    5100</span>              : </span>
<span id="L5101"><span class="lineNum">    5101</span>              :         /**</span>
<span id="L5102"><span class="lineNum">    5102</span>              :          * EVENT_AVOID_FREQUENCIES - Received avoid frequency range</span>
<span id="L5103"><span class="lineNum">    5103</span>              :          *</span>
<span id="L5104"><span class="lineNum">    5104</span>              :          * This event indicates a set of frequency ranges that should be avoided</span>
<span id="L5105"><span class="lineNum">    5105</span>              :          * to reduce issues due to interference or internal co-existence</span>
<span id="L5106"><span class="lineNum">    5106</span>              :          * information in the driver.</span>
<span id="L5107"><span class="lineNum">    5107</span>              :          */</span>
<span id="L5108"><span class="lineNum">    5108</span>              :         EVENT_AVOID_FREQUENCIES,</span>
<span id="L5109"><span class="lineNum">    5109</span>              : </span>
<span id="L5110"><span class="lineNum">    5110</span>              :         /**</span>
<span id="L5111"><span class="lineNum">    5111</span>              :          * EVENT_NEW_PEER_CANDIDATE - new (unknown) mesh peer notification</span>
<span id="L5112"><span class="lineNum">    5112</span>              :          */</span>
<span id="L5113"><span class="lineNum">    5113</span>              :         EVENT_NEW_PEER_CANDIDATE,</span>
<span id="L5114"><span class="lineNum">    5114</span>              : </span>
<span id="L5115"><span class="lineNum">    5115</span>              :         /**</span>
<span id="L5116"><span class="lineNum">    5116</span>              :          * EVENT_ACS_CHANNEL_SELECTED - Received selected channels by ACS</span>
<span id="L5117"><span class="lineNum">    5117</span>              :          *</span>
<span id="L5118"><span class="lineNum">    5118</span>              :          * Indicates a pair of primary and secondary channels chosen by ACS</span>
<span id="L5119"><span class="lineNum">    5119</span>              :          * in device.</span>
<span id="L5120"><span class="lineNum">    5120</span>              :          */</span>
<span id="L5121"><span class="lineNum">    5121</span>              :         EVENT_ACS_CHANNEL_SELECTED,</span>
<span id="L5122"><span class="lineNum">    5122</span>              : </span>
<span id="L5123"><span class="lineNum">    5123</span>              :         /**</span>
<span id="L5124"><span class="lineNum">    5124</span>              :          * EVENT_DFS_CAC_STARTED - Notify that channel availability check has</span>
<span id="L5125"><span class="lineNum">    5125</span>              :          * been started.</span>
<span id="L5126"><span class="lineNum">    5126</span>              :          *</span>
<span id="L5127"><span class="lineNum">    5127</span>              :          * This event indicates that channel availability check has been started</span>
<span id="L5128"><span class="lineNum">    5128</span>              :          * on a DFS frequency by a driver that supports DFS Offload.</span>
<span id="L5129"><span class="lineNum">    5129</span>              :          */</span>
<span id="L5130"><span class="lineNum">    5130</span>              :         EVENT_DFS_CAC_STARTED,</span>
<span id="L5131"><span class="lineNum">    5131</span>              : </span>
<span id="L5132"><span class="lineNum">    5132</span>              :         /**</span>
<span id="L5133"><span class="lineNum">    5133</span>              :          * EVENT_P2P_LO_STOP - Notify that P2P listen offload is stopped</span>
<span id="L5134"><span class="lineNum">    5134</span>              :          */</span>
<span id="L5135"><span class="lineNum">    5135</span>              :         EVENT_P2P_LO_STOP,</span>
<span id="L5136"><span class="lineNum">    5136</span>              : </span>
<span id="L5137"><span class="lineNum">    5137</span>              :         /**</span>
<span id="L5138"><span class="lineNum">    5138</span>              :          * EVENT_BEACON_LOSS - Beacon loss detected</span>
<span id="L5139"><span class="lineNum">    5139</span>              :          *</span>
<span id="L5140"><span class="lineNum">    5140</span>              :          * This event indicates that no Beacon frames has been received from</span>
<span id="L5141"><span class="lineNum">    5141</span>              :          * the current AP. This may indicate that the AP is not anymore in</span>
<span id="L5142"><span class="lineNum">    5142</span>              :          * range.</span>
<span id="L5143"><span class="lineNum">    5143</span>              :          */</span>
<span id="L5144"><span class="lineNum">    5144</span>              :         EVENT_BEACON_LOSS,</span>
<span id="L5145"><span class="lineNum">    5145</span>              : </span>
<span id="L5146"><span class="lineNum">    5146</span>              :         /**</span>
<span id="L5147"><span class="lineNum">    5147</span>              :          * EVENT_DFS_PRE_CAC_EXPIRED - Notify that channel availability check</span>
<span id="L5148"><span class="lineNum">    5148</span>              :          * done previously (Pre-CAC) on the channel has expired. This would</span>
<span id="L5149"><span class="lineNum">    5149</span>              :          * normally be on a non-ETSI DFS regulatory domain. DFS state of the</span>
<span id="L5150"><span class="lineNum">    5150</span>              :          * channel will be moved from available to usable. A new CAC has to be</span>
<span id="L5151"><span class="lineNum">    5151</span>              :          * performed before start operating on this channel.</span>
<span id="L5152"><span class="lineNum">    5152</span>              :          */</span>
<span id="L5153"><span class="lineNum">    5153</span>              :         EVENT_DFS_PRE_CAC_EXPIRED,</span>
<span id="L5154"><span class="lineNum">    5154</span>              : </span>
<span id="L5155"><span class="lineNum">    5155</span>              :         /**</span>
<span id="L5156"><span class="lineNum">    5156</span>              :          * EVENT_EXTERNAL_AUTH - This event interface is used by host drivers</span>
<span id="L5157"><span class="lineNum">    5157</span>              :          * that do not define separate commands for authentication and</span>
<span id="L5158"><span class="lineNum">    5158</span>              :          * association (~WPA_DRIVER_FLAGS_SME) but offload the 802.11</span>
<span id="L5159"><span class="lineNum">    5159</span>              :          * authentication to wpa_supplicant. This event carries all the</span>
<span id="L5160"><span class="lineNum">    5160</span>              :          * necessary information from the host driver for the authentication to</span>
<span id="L5161"><span class="lineNum">    5161</span>              :          * happen.</span>
<span id="L5162"><span class="lineNum">    5162</span>              :          */</span>
<span id="L5163"><span class="lineNum">    5163</span>              :         EVENT_EXTERNAL_AUTH,</span>
<span id="L5164"><span class="lineNum">    5164</span>              : </span>
<span id="L5165"><span class="lineNum">    5165</span>              :         /**</span>
<span id="L5166"><span class="lineNum">    5166</span>              :          * EVENT_PORT_AUTHORIZED - Notification that a connection is authorized</span>
<span id="L5167"><span class="lineNum">    5167</span>              :          *</span>
<span id="L5168"><span class="lineNum">    5168</span>              :          * This event should be indicated when the driver completes the 4-way</span>
<span id="L5169"><span class="lineNum">    5169</span>              :          * handshake. This event should be preceded by an EVENT_ASSOC that</span>
<span id="L5170"><span class="lineNum">    5170</span>              :          * indicates the completion of IEEE 802.11 association.</span>
<span id="L5171"><span class="lineNum">    5171</span>              :          */</span>
<span id="L5172"><span class="lineNum">    5172</span>              :         EVENT_PORT_AUTHORIZED,</span>
<span id="L5173"><span class="lineNum">    5173</span>              : </span>
<span id="L5174"><span class="lineNum">    5174</span>              :         /**</span>
<span id="L5175"><span class="lineNum">    5175</span>              :          * EVENT_STATION_OPMODE_CHANGED - Notify STA's HT/VHT operation mode</span>
<span id="L5176"><span class="lineNum">    5176</span>              :          * change event.</span>
<span id="L5177"><span class="lineNum">    5177</span>              :          */</span>
<span id="L5178"><span class="lineNum">    5178</span>              :         EVENT_STATION_OPMODE_CHANGED,</span>
<span id="L5179"><span class="lineNum">    5179</span>              : </span>
<span id="L5180"><span class="lineNum">    5180</span>              :         /**</span>
<span id="L5181"><span class="lineNum">    5181</span>              :          * EVENT_INTERFACE_MAC_CHANGED - Notify that interface MAC changed</span>
<span id="L5182"><span class="lineNum">    5182</span>              :          *</span>
<span id="L5183"><span class="lineNum">    5183</span>              :          * This event is emitted when the MAC changes while the interface is</span>
<span id="L5184"><span class="lineNum">    5184</span>              :          * enabled. When an interface was disabled and becomes enabled, it</span>
<span id="L5185"><span class="lineNum">    5185</span>              :          * must be always assumed that the MAC possibly changed.</span>
<span id="L5186"><span class="lineNum">    5186</span>              :          */</span>
<span id="L5187"><span class="lineNum">    5187</span>              :         EVENT_INTERFACE_MAC_CHANGED,</span>
<span id="L5188"><span class="lineNum">    5188</span>              : </span>
<span id="L5189"><span class="lineNum">    5189</span>              :         /**</span>
<span id="L5190"><span class="lineNum">    5190</span>              :          * EVENT_WDS_STA_INTERFACE_STATUS - Notify WDS STA interface status</span>
<span id="L5191"><span class="lineNum">    5191</span>              :          *</span>
<span id="L5192"><span class="lineNum">    5192</span>              :          * This event is emitted when an interface is added/removed for WDS STA.</span>
<span id="L5193"><span class="lineNum">    5193</span>              :          */</span>
<span id="L5194"><span class="lineNum">    5194</span>              :         EVENT_WDS_STA_INTERFACE_STATUS,</span>
<span id="L5195"><span class="lineNum">    5195</span>              : </span>
<span id="L5196"><span class="lineNum">    5196</span>              :         /**</span>
<span id="L5197"><span class="lineNum">    5197</span>              :           * EVENT_UPDATE_DH - Notification of updated DH information</span>
<span id="L5198"><span class="lineNum">    5198</span>              :           */</span>
<span id="L5199"><span class="lineNum">    5199</span>              :         EVENT_UPDATE_DH,</span>
<span id="L5200"><span class="lineNum">    5200</span>              : </span>
<span id="L5201"><span class="lineNum">    5201</span>              :         /**</span>
<span id="L5202"><span class="lineNum">    5202</span>              :          * EVENT_UNPROT_BEACON - Unprotected Beacon frame received</span>
<span id="L5203"><span class="lineNum">    5203</span>              :          *</span>
<span id="L5204"><span class="lineNum">    5204</span>              :          * This event should be called when a Beacon frame is dropped due to it</span>
<span id="L5205"><span class="lineNum">    5205</span>              :          * not being protected correctly. union wpa_event_data::unprot_beacon</span>
<span id="L5206"><span class="lineNum">    5206</span>              :          * is required to provide more details of the frame.</span>
<span id="L5207"><span class="lineNum">    5207</span>              :          */</span>
<span id="L5208"><span class="lineNum">    5208</span>              :         EVENT_UNPROT_BEACON,</span>
<span id="L5209"><span class="lineNum">    5209</span>              : </span>
<span id="L5210"><span class="lineNum">    5210</span>              :         /**</span>
<span id="L5211"><span class="lineNum">    5211</span>              :          * EVENT_TX_WAIT_EXPIRE - TX wait timed out</span>
<span id="L5212"><span class="lineNum">    5212</span>              :          *</span>
<span id="L5213"><span class="lineNum">    5213</span>              :          * This event is used to indicate when the driver has completed</span>
<span id="L5214"><span class="lineNum">    5214</span>              :          * wait for a response frame based on a TX request that specified a</span>
<span id="L5215"><span class="lineNum">    5215</span>              :          * non-zero wait time and that has not been explicitly cancelled.</span>
<span id="L5216"><span class="lineNum">    5216</span>              :          */</span>
<span id="L5217"><span class="lineNum">    5217</span>              :         EVENT_TX_WAIT_EXPIRE,</span>
<span id="L5218"><span class="lineNum">    5218</span>              : </span>
<span id="L5219"><span class="lineNum">    5219</span>              :         /**</span>
<span id="L5220"><span class="lineNum">    5220</span>              :           * EVENT_BSS_COLOR_COLLISION - Notification of a BSS color collision</span>
<span id="L5221"><span class="lineNum">    5221</span>              :           */</span>
<span id="L5222"><span class="lineNum">    5222</span>              :         EVENT_BSS_COLOR_COLLISION,</span>
<span id="L5223"><span class="lineNum">    5223</span>              : </span>
<span id="L5224"><span class="lineNum">    5224</span>              :         /**</span>
<span id="L5225"><span class="lineNum">    5225</span>              :          * EVENT_CCA_STARTED_NOTIFY - Notification that CCA has started</span>
<span id="L5226"><span class="lineNum">    5226</span>              :          */</span>
<span id="L5227"><span class="lineNum">    5227</span>              :         EVENT_CCA_STARTED_NOTIFY,</span>
<span id="L5228"><span class="lineNum">    5228</span>              : </span>
<span id="L5229"><span class="lineNum">    5229</span>              :         /**</span>
<span id="L5230"><span class="lineNum">    5230</span>              :          * EVENT_CCA_ABORTED_NOTIFY - Notification that CCA has aborted</span>
<span id="L5231"><span class="lineNum">    5231</span>              :          */</span>
<span id="L5232"><span class="lineNum">    5232</span>              :         EVENT_CCA_ABORTED_NOTIFY,</span>
<span id="L5233"><span class="lineNum">    5233</span>              : </span>
<span id="L5234"><span class="lineNum">    5234</span>              :         /**</span>
<span id="L5235"><span class="lineNum">    5235</span>              :          * EVENT_CCA_NOTIFY - Notification that CCA has completed</span>
<span id="L5236"><span class="lineNum">    5236</span>              :          */</span>
<span id="L5237"><span class="lineNum">    5237</span>              :         EVENT_CCA_NOTIFY,</span>
<span id="L5238"><span class="lineNum">    5238</span>              : };</span>
<span id="L5239"><span class="lineNum">    5239</span>              : </span>
<span id="L5240"><span class="lineNum">    5240</span>              : </span>
<span id="L5241"><span class="lineNum">    5241</span>              : /**</span>
<span id="L5242"><span class="lineNum">    5242</span>              :  * struct freq_survey - Channel survey info</span>
<span id="L5243"><span class="lineNum">    5243</span>              :  *</span>
<span id="L5244"><span class="lineNum">    5244</span>              :  * @ifidx: Interface index in which this survey was observed</span>
<span id="L5245"><span class="lineNum">    5245</span>              :  * @freq: Center of frequency of the surveyed channel</span>
<span id="L5246"><span class="lineNum">    5246</span>              :  * @nf: Channel noise floor in dBm</span>
<span id="L5247"><span class="lineNum">    5247</span>              :  * @channel_time: Amount of time in ms the radio spent on the channel</span>
<span id="L5248"><span class="lineNum">    5248</span>              :  * @channel_time_busy: Amount of time in ms the radio detected some signal</span>
<span id="L5249"><span class="lineNum">    5249</span>              :  *     that indicated to the radio the channel was not clear</span>
<span id="L5250"><span class="lineNum">    5250</span>              :  * @channel_time_rx: Amount of time the radio spent receiving data</span>
<span id="L5251"><span class="lineNum">    5251</span>              :  * @channel_time_tx: Amount of time the radio spent transmitting data</span>
<span id="L5252"><span class="lineNum">    5252</span>              :  * @filled: bitmask indicating which fields have been reported, see</span>
<span id="L5253"><span class="lineNum">    5253</span>              :  *     SURVEY_HAS_* defines.</span>
<span id="L5254"><span class="lineNum">    5254</span>              :  * @list: Internal list pointers</span>
<span id="L5255"><span class="lineNum">    5255</span>              :  */</span>
<span id="L5256"><span class="lineNum">    5256</span>              : struct freq_survey {</span>
<span id="L5257"><span class="lineNum">    5257</span>              :         u32 ifidx;</span>
<span id="L5258"><span class="lineNum">    5258</span>              :         unsigned int freq;</span>
<span id="L5259"><span class="lineNum">    5259</span>              :         s8 nf;</span>
<span id="L5260"><span class="lineNum">    5260</span>              :         u64 channel_time;</span>
<span id="L5261"><span class="lineNum">    5261</span>              :         u64 channel_time_busy;</span>
<span id="L5262"><span class="lineNum">    5262</span>              :         u64 channel_time_rx;</span>
<span id="L5263"><span class="lineNum">    5263</span>              :         u64 channel_time_tx;</span>
<span id="L5264"><span class="lineNum">    5264</span>              :         unsigned int filled;</span>
<span id="L5265"><span class="lineNum">    5265</span>              :         struct dl_list list;</span>
<span id="L5266"><span class="lineNum">    5266</span>              : };</span>
<span id="L5267"><span class="lineNum">    5267</span>              : </span>
<span id="L5268"><span class="lineNum">    5268</span>              : #define SURVEY_HAS_NF BIT(0)</span>
<span id="L5269"><span class="lineNum">    5269</span>              : #define SURVEY_HAS_CHAN_TIME BIT(1)</span>
<span id="L5270"><span class="lineNum">    5270</span>              : #define SURVEY_HAS_CHAN_TIME_BUSY BIT(2)</span>
<span id="L5271"><span class="lineNum">    5271</span>              : #define SURVEY_HAS_CHAN_TIME_RX BIT(3)</span>
<span id="L5272"><span class="lineNum">    5272</span>              : #define SURVEY_HAS_CHAN_TIME_TX BIT(4)</span>
<span id="L5273"><span class="lineNum">    5273</span>              : </span>
<span id="L5274"><span class="lineNum">    5274</span>              : /**</span>
<span id="L5275"><span class="lineNum">    5275</span>              :  * enum sta_connect_fail_reason_codes - STA connect failure reason code values</span>
<span id="L5276"><span class="lineNum">    5276</span>              :  * @STA_CONNECT_FAIL_REASON_UNSPECIFIED: No reason code specified for</span>
<span id="L5277"><span class="lineNum">    5277</span>              :  *      connection failure.</span>
<span id="L5278"><span class="lineNum">    5278</span>              :  * @STA_CONNECT_FAIL_REASON_NO_BSS_FOUND: No Probe Response frame received</span>
<span id="L5279"><span class="lineNum">    5279</span>              :  *      for unicast Probe Request frame.</span>
<span id="L5280"><span class="lineNum">    5280</span>              :  * @STA_CONNECT_FAIL_REASON_AUTH_TX_FAIL: STA failed to send auth request.</span>
<span id="L5281"><span class="lineNum">    5281</span>              :  * @STA_CONNECT_FAIL_REASON_AUTH_NO_ACK_RECEIVED: AP didn't send ACK for</span>
<span id="L5282"><span class="lineNum">    5282</span>              :  *      auth request.</span>
<span id="L5283"><span class="lineNum">    5283</span>              :  * @STA_CONNECT_FAIL_REASON_AUTH_NO_RESP_RECEIVED: Auth response is not</span>
<span id="L5284"><span class="lineNum">    5284</span>              :  *      received from AP.</span>
<span id="L5285"><span class="lineNum">    5285</span>              :  * @STA_CONNECT_FAIL_REASON_ASSOC_REQ_TX_FAIL: STA failed to send</span>
<span id="L5286"><span class="lineNum">    5286</span>              :  *      Association Request frame.</span>
<span id="L5287"><span class="lineNum">    5287</span>              :  * @STA_CONNECT_FAIL_REASON_ASSOC_NO_ACK_RECEIVED: AP didn't send ACK for</span>
<span id="L5288"><span class="lineNum">    5288</span>              :  *      Association Request frame.</span>
<span id="L5289"><span class="lineNum">    5289</span>              :  * @STA_CONNECT_FAIL_REASON_ASSOC_NO_RESP_RECEIVED: Association Response</span>
<span id="L5290"><span class="lineNum">    5290</span>              :  *      frame is not received from AP.</span>
<span id="L5291"><span class="lineNum">    5291</span>              :  */</span>
<span id="L5292"><span class="lineNum">    5292</span>              : enum sta_connect_fail_reason_codes {</span>
<span id="L5293"><span class="lineNum">    5293</span>              :         STA_CONNECT_FAIL_REASON_UNSPECIFIED = 0,</span>
<span id="L5294"><span class="lineNum">    5294</span>              :         STA_CONNECT_FAIL_REASON_NO_BSS_FOUND = 1,</span>
<span id="L5295"><span class="lineNum">    5295</span>              :         STA_CONNECT_FAIL_REASON_AUTH_TX_FAIL = 2,</span>
<span id="L5296"><span class="lineNum">    5296</span>              :         STA_CONNECT_FAIL_REASON_AUTH_NO_ACK_RECEIVED = 3,</span>
<span id="L5297"><span class="lineNum">    5297</span>              :         STA_CONNECT_FAIL_REASON_AUTH_NO_RESP_RECEIVED = 4,</span>
<span id="L5298"><span class="lineNum">    5298</span>              :         STA_CONNECT_FAIL_REASON_ASSOC_REQ_TX_FAIL = 5,</span>
<span id="L5299"><span class="lineNum">    5299</span>              :         STA_CONNECT_FAIL_REASON_ASSOC_NO_ACK_RECEIVED = 6,</span>
<span id="L5300"><span class="lineNum">    5300</span>              :         STA_CONNECT_FAIL_REASON_ASSOC_NO_RESP_RECEIVED = 7,</span>
<span id="L5301"><span class="lineNum">    5301</span>              : };</span>
<span id="L5302"><span class="lineNum">    5302</span>              : </span>
<span id="L5303"><span class="lineNum">    5303</span>              : /**</span>
<span id="L5304"><span class="lineNum">    5304</span>              :  * union wpa_event_data - Additional data for wpa_supplicant_event() calls</span>
<span id="L5305"><span class="lineNum">    5305</span>              :  */</span>
<span id="L5306"><span class="lineNum">    5306</span>              : union wpa_event_data {</span>
<span id="L5307"><span class="lineNum">    5307</span>              :         /**</span>
<span id="L5308"><span class="lineNum">    5308</span>              :          * struct assoc_info - Data for EVENT_ASSOC and EVENT_ASSOCINFO events</span>
<span id="L5309"><span class="lineNum">    5309</span>              :          *</span>
<span id="L5310"><span class="lineNum">    5310</span>              :          * This structure is optional for EVENT_ASSOC calls and required for</span>
<span id="L5311"><span class="lineNum">    5311</span>              :          * EVENT_ASSOCINFO calls. By using EVENT_ASSOC with this data, the</span>
<span id="L5312"><span class="lineNum">    5312</span>              :          * driver interface does not need to generate separate EVENT_ASSOCINFO</span>
<span id="L5313"><span class="lineNum">    5313</span>              :          * calls.</span>
<span id="L5314"><span class="lineNum">    5314</span>              :          */</span>
<span id="L5315"><span class="lineNum">    5315</span>              :         struct assoc_info {</span>
<span id="L5316"><span class="lineNum">    5316</span>              :                 /**</span>
<span id="L5317"><span class="lineNum">    5317</span>              :                  * reassoc - Flag to indicate association or reassociation</span>
<span id="L5318"><span class="lineNum">    5318</span>              :                  */</span>
<span id="L5319"><span class="lineNum">    5319</span>              :                 int reassoc;</span>
<span id="L5320"><span class="lineNum">    5320</span>              : </span>
<span id="L5321"><span class="lineNum">    5321</span>              :                 /**</span>
<span id="L5322"><span class="lineNum">    5322</span>              :                  * req_ies - (Re)Association Request IEs</span>
<span id="L5323"><span class="lineNum">    5323</span>              :                  *</span>
<span id="L5324"><span class="lineNum">    5324</span>              :                  * If the driver generates WPA/RSN IE, this event data must be</span>
<span id="L5325"><span class="lineNum">    5325</span>              :                  * returned for WPA handshake to have needed information. If</span>
<span id="L5326"><span class="lineNum">    5326</span>              :                  * wpa_supplicant-generated WPA/RSN IE is used, this</span>
<span id="L5327"><span class="lineNum">    5327</span>              :                  * information event is optional.</span>
<span id="L5328"><span class="lineNum">    5328</span>              :                  *</span>
<span id="L5329"><span class="lineNum">    5329</span>              :                  * This should start with the first IE (fixed fields before IEs</span>
<span id="L5330"><span class="lineNum">    5330</span>              :                  * are not included).</span>
<span id="L5331"><span class="lineNum">    5331</span>              :                  */</span>
<span id="L5332"><span class="lineNum">    5332</span>              :                 const u8 *req_ies;</span>
<span id="L5333"><span class="lineNum">    5333</span>              : </span>
<span id="L5334"><span class="lineNum">    5334</span>              :                 /**</span>
<span id="L5335"><span class="lineNum">    5335</span>              :                  * req_ies_len - Length of req_ies in bytes</span>
<span id="L5336"><span class="lineNum">    5336</span>              :                  */</span>
<span id="L5337"><span class="lineNum">    5337</span>              :                 size_t req_ies_len;</span>
<span id="L5338"><span class="lineNum">    5338</span>              : </span>
<span id="L5339"><span class="lineNum">    5339</span>              :                 /**</span>
<span id="L5340"><span class="lineNum">    5340</span>              :                  * resp_ies - (Re)Association Response IEs</span>
<span id="L5341"><span class="lineNum">    5341</span>              :                  *</span>
<span id="L5342"><span class="lineNum">    5342</span>              :                  * Optional association data from the driver. This data is not</span>
<span id="L5343"><span class="lineNum">    5343</span>              :                  * required WPA, but may be useful for some protocols and as</span>
<span id="L5344"><span class="lineNum">    5344</span>              :                  * such, should be reported if this is available to the driver</span>
<span id="L5345"><span class="lineNum">    5345</span>              :                  * interface.</span>
<span id="L5346"><span class="lineNum">    5346</span>              :                  *</span>
<span id="L5347"><span class="lineNum">    5347</span>              :                  * This should start with the first IE (fixed fields before IEs</span>
<span id="L5348"><span class="lineNum">    5348</span>              :                  * are not included).</span>
<span id="L5349"><span class="lineNum">    5349</span>              :                  */</span>
<span id="L5350"><span class="lineNum">    5350</span>              :                 const u8 *resp_ies;</span>
<span id="L5351"><span class="lineNum">    5351</span>              : </span>
<span id="L5352"><span class="lineNum">    5352</span>              :                 /**</span>
<span id="L5353"><span class="lineNum">    5353</span>              :                  * resp_ies_len - Length of resp_ies in bytes</span>
<span id="L5354"><span class="lineNum">    5354</span>              :                  */</span>
<span id="L5355"><span class="lineNum">    5355</span>              :                 size_t resp_ies_len;</span>
<span id="L5356"><span class="lineNum">    5356</span>              : </span>
<span id="L5357"><span class="lineNum">    5357</span>              :                 /**</span>
<span id="L5358"><span class="lineNum">    5358</span>              :                  * resp_frame - (Re)Association Response frame</span>
<span id="L5359"><span class="lineNum">    5359</span>              :                  */</span>
<span id="L5360"><span class="lineNum">    5360</span>              :                 const u8 *resp_frame;</span>
<span id="L5361"><span class="lineNum">    5361</span>              : </span>
<span id="L5362"><span class="lineNum">    5362</span>              :                 /**</span>
<span id="L5363"><span class="lineNum">    5363</span>              :                  * resp_frame_len - (Re)Association Response frame length</span>
<span id="L5364"><span class="lineNum">    5364</span>              :                  */</span>
<span id="L5365"><span class="lineNum">    5365</span>              :                 size_t resp_frame_len;</span>
<span id="L5366"><span class="lineNum">    5366</span>              : </span>
<span id="L5367"><span class="lineNum">    5367</span>              :                 /**</span>
<span id="L5368"><span class="lineNum">    5368</span>              :                  * beacon_ies - Beacon or Probe Response IEs</span>
<span id="L5369"><span class="lineNum">    5369</span>              :                  *</span>
<span id="L5370"><span class="lineNum">    5370</span>              :                  * Optional Beacon/ProbeResp data: IEs included in Beacon or</span>
<span id="L5371"><span class="lineNum">    5371</span>              :                  * Probe Response frames from the current AP (i.e., the one</span>
<span id="L5372"><span class="lineNum">    5372</span>              :                  * that the client just associated with). This information is</span>
<span id="L5373"><span class="lineNum">    5373</span>              :                  * used to update WPA/RSN IE for the AP. If this field is not</span>
<span id="L5374"><span class="lineNum">    5374</span>              :                  * set, the results from previous scan will be used. If no</span>
<span id="L5375"><span class="lineNum">    5375</span>              :                  * data for the new AP is found, scan results will be requested</span>
<span id="L5376"><span class="lineNum">    5376</span>              :                  * again (without scan request). At this point, the driver is</span>
<span id="L5377"><span class="lineNum">    5377</span>              :                  * expected to provide WPA/RSN IE for the AP (if WPA/WPA2 is</span>
<span id="L5378"><span class="lineNum">    5378</span>              :                  * used).</span>
<span id="L5379"><span class="lineNum">    5379</span>              :                  *</span>
<span id="L5380"><span class="lineNum">    5380</span>              :                  * This should start with the first IE (fixed fields before IEs</span>
<span id="L5381"><span class="lineNum">    5381</span>              :                  * are not included).</span>
<span id="L5382"><span class="lineNum">    5382</span>              :                  */</span>
<span id="L5383"><span class="lineNum">    5383</span>              :                 const u8 *beacon_ies;</span>
<span id="L5384"><span class="lineNum">    5384</span>              : </span>
<span id="L5385"><span class="lineNum">    5385</span>              :                 /**</span>
<span id="L5386"><span class="lineNum">    5386</span>              :                  * beacon_ies_len - Length of beacon_ies */</span>
<span id="L5387"><span class="lineNum">    5387</span>              :                 size_t beacon_ies_len;</span>
<span id="L5388"><span class="lineNum">    5388</span>              : </span>
<span id="L5389"><span class="lineNum">    5389</span>              :                 /**</span>
<span id="L5390"><span class="lineNum">    5390</span>              :                  * freq - Frequency of the operational channel in MHz</span>
<span id="L5391"><span class="lineNum">    5391</span>              :                  */</span>
<span id="L5392"><span class="lineNum">    5392</span>              :                 unsigned int freq;</span>
<span id="L5393"><span class="lineNum">    5393</span>              : </span>
<span id="L5394"><span class="lineNum">    5394</span>              :                 /**</span>
<span id="L5395"><span class="lineNum">    5395</span>              :                  * wmm_params - WMM parameters used in this association.</span>
<span id="L5396"><span class="lineNum">    5396</span>              :                  */</span>
<span id="L5397"><span class="lineNum">    5397</span>              :                 struct wmm_params wmm_params;</span>
<span id="L5398"><span class="lineNum">    5398</span>              : </span>
<span id="L5399"><span class="lineNum">    5399</span>              :                 /**</span>
<span id="L5400"><span class="lineNum">    5400</span>              :                  * addr - Station address (for AP mode)</span>
<span id="L5401"><span class="lineNum">    5401</span>              :                  */</span>
<span id="L5402"><span class="lineNum">    5402</span>              :                 const u8 *addr;</span>
<span id="L5403"><span class="lineNum">    5403</span>              : </span>
<span id="L5404"><span class="lineNum">    5404</span>              :                 /**</span>
<span id="L5405"><span class="lineNum">    5405</span>              :                  * The following is the key management offload information</span>
<span id="L5406"><span class="lineNum">    5406</span>              :                  * @authorized</span>
<span id="L5407"><span class="lineNum">    5407</span>              :                  * @key_replay_ctr</span>
<span id="L5408"><span class="lineNum">    5408</span>              :                  * @key_replay_ctr_len</span>
<span id="L5409"><span class="lineNum">    5409</span>              :                  * @ptk_kck</span>
<span id="L5410"><span class="lineNum">    5410</span>              :                  * @ptk_kek_len</span>
<span id="L5411"><span class="lineNum">    5411</span>              :                  * @ptk_kek</span>
<span id="L5412"><span class="lineNum">    5412</span>              :                  * @ptk_kek_len</span>
<span id="L5413"><span class="lineNum">    5413</span>              :                  */</span>
<span id="L5414"><span class="lineNum">    5414</span>              : </span>
<span id="L5415"><span class="lineNum">    5415</span>              :                 /**</span>
<span id="L5416"><span class="lineNum">    5416</span>              :                  * authorized - Status of key management offload,</span>
<span id="L5417"><span class="lineNum">    5417</span>              :                  * 1 = successful</span>
<span id="L5418"><span class="lineNum">    5418</span>              :                  */</span>
<span id="L5419"><span class="lineNum">    5419</span>              :                 int authorized;</span>
<span id="L5420"><span class="lineNum">    5420</span>              : </span>
<span id="L5421"><span class="lineNum">    5421</span>              :                 /**</span>
<span id="L5422"><span class="lineNum">    5422</span>              :                  * key_replay_ctr - Key replay counter value last used</span>
<span id="L5423"><span class="lineNum">    5423</span>              :                  * in a valid EAPOL-Key frame</span>
<span id="L5424"><span class="lineNum">    5424</span>              :                  */</span>
<span id="L5425"><span class="lineNum">    5425</span>              :                 const u8 *key_replay_ctr;</span>
<span id="L5426"><span class="lineNum">    5426</span>              : </span>
<span id="L5427"><span class="lineNum">    5427</span>              :                 /**</span>
<span id="L5428"><span class="lineNum">    5428</span>              :                  * key_replay_ctr_len - The length of key_replay_ctr</span>
<span id="L5429"><span class="lineNum">    5429</span>              :                  */</span>
<span id="L5430"><span class="lineNum">    5430</span>              :                 size_t key_replay_ctr_len;</span>
<span id="L5431"><span class="lineNum">    5431</span>              : </span>
<span id="L5432"><span class="lineNum">    5432</span>              :                 /**</span>
<span id="L5433"><span class="lineNum">    5433</span>              :                  * ptk_kck - The derived PTK KCK</span>
<span id="L5434"><span class="lineNum">    5434</span>              :                  */</span>
<span id="L5435"><span class="lineNum">    5435</span>              :                 const u8 *ptk_kck;</span>
<span id="L5436"><span class="lineNum">    5436</span>              : </span>
<span id="L5437"><span class="lineNum">    5437</span>              :                 /**</span>
<span id="L5438"><span class="lineNum">    5438</span>              :                  * ptk_kek_len - The length of ptk_kck</span>
<span id="L5439"><span class="lineNum">    5439</span>              :                  */</span>
<span id="L5440"><span class="lineNum">    5440</span>              :                 size_t ptk_kck_len;</span>
<span id="L5441"><span class="lineNum">    5441</span>              : </span>
<span id="L5442"><span class="lineNum">    5442</span>              :                 /**</span>
<span id="L5443"><span class="lineNum">    5443</span>              :                  * ptk_kek - The derived PTK KEK</span>
<span id="L5444"><span class="lineNum">    5444</span>              :                  * This is used in key management offload and also in FILS SK</span>
<span id="L5445"><span class="lineNum">    5445</span>              :                  * offload.</span>
<span id="L5446"><span class="lineNum">    5446</span>              :                  */</span>
<span id="L5447"><span class="lineNum">    5447</span>              :                 const u8 *ptk_kek;</span>
<span id="L5448"><span class="lineNum">    5448</span>              : </span>
<span id="L5449"><span class="lineNum">    5449</span>              :                 /**</span>
<span id="L5450"><span class="lineNum">    5450</span>              :                  * ptk_kek_len - The length of ptk_kek</span>
<span id="L5451"><span class="lineNum">    5451</span>              :                  */</span>
<span id="L5452"><span class="lineNum">    5452</span>              :                 size_t ptk_kek_len;</span>
<span id="L5453"><span class="lineNum">    5453</span>              : </span>
<span id="L5454"><span class="lineNum">    5454</span>              :                 /**</span>
<span id="L5455"><span class="lineNum">    5455</span>              :                  * subnet_status - The subnet status:</span>
<span id="L5456"><span class="lineNum">    5456</span>              :                  * 0 = unknown, 1 = unchanged, 2 = changed</span>
<span id="L5457"><span class="lineNum">    5457</span>              :                  */</span>
<span id="L5458"><span class="lineNum">    5458</span>              :                 u8 subnet_status;</span>
<span id="L5459"><span class="lineNum">    5459</span>              : </span>
<span id="L5460"><span class="lineNum">    5460</span>              :                 /**</span>
<span id="L5461"><span class="lineNum">    5461</span>              :                  * The following information is used in FILS SK offload</span>
<span id="L5462"><span class="lineNum">    5462</span>              :                  * @fils_erp_next_seq_num</span>
<span id="L5463"><span class="lineNum">    5463</span>              :                  * @fils_pmk</span>
<span id="L5464"><span class="lineNum">    5464</span>              :                  * @fils_pmk_len</span>
<span id="L5465"><span class="lineNum">    5465</span>              :                  * @fils_pmkid</span>
<span id="L5466"><span class="lineNum">    5466</span>              :                  */</span>
<span id="L5467"><span class="lineNum">    5467</span>              : </span>
<span id="L5468"><span class="lineNum">    5468</span>              :                 /**</span>
<span id="L5469"><span class="lineNum">    5469</span>              :                  * fils_erp_next_seq_num - The next sequence number to use in</span>
<span id="L5470"><span class="lineNum">    5470</span>              :                  * FILS ERP messages</span>
<span id="L5471"><span class="lineNum">    5471</span>              :                  */</span>
<span id="L5472"><span class="lineNum">    5472</span>              :                 u16 fils_erp_next_seq_num;</span>
<span id="L5473"><span class="lineNum">    5473</span>              : </span>
<span id="L5474"><span class="lineNum">    5474</span>              :                 /**</span>
<span id="L5475"><span class="lineNum">    5475</span>              :                  * fils_pmk - A new PMK if generated in case of FILS</span>
<span id="L5476"><span class="lineNum">    5476</span>              :                  * authentication</span>
<span id="L5477"><span class="lineNum">    5477</span>              :                  */</span>
<span id="L5478"><span class="lineNum">    5478</span>              :                 const u8 *fils_pmk;</span>
<span id="L5479"><span class="lineNum">    5479</span>              : </span>
<span id="L5480"><span class="lineNum">    5480</span>              :                 /**</span>
<span id="L5481"><span class="lineNum">    5481</span>              :                  * fils_pmk_len - Length of fils_pmk</span>
<span id="L5482"><span class="lineNum">    5482</span>              :                  */</span>
<span id="L5483"><span class="lineNum">    5483</span>              :                 size_t fils_pmk_len;</span>
<span id="L5484"><span class="lineNum">    5484</span>              : </span>
<span id="L5485"><span class="lineNum">    5485</span>              :                 /**</span>
<span id="L5486"><span class="lineNum">    5486</span>              :                  * fils_pmkid - PMKID used or generated in FILS authentication</span>
<span id="L5487"><span class="lineNum">    5487</span>              :                  */</span>
<span id="L5488"><span class="lineNum">    5488</span>              :                 const u8 *fils_pmkid;</span>
<span id="L5489"><span class="lineNum">    5489</span>              :         } assoc_info;</span>
<span id="L5490"><span class="lineNum">    5490</span>              : </span>
<span id="L5491"><span class="lineNum">    5491</span>              :         /**</span>
<span id="L5492"><span class="lineNum">    5492</span>              :          * struct disassoc_info - Data for EVENT_DISASSOC events</span>
<span id="L5493"><span class="lineNum">    5493</span>              :          */</span>
<span id="L5494"><span class="lineNum">    5494</span>              :         struct disassoc_info {</span>
<span id="L5495"><span class="lineNum">    5495</span>              :                 /**</span>
<span id="L5496"><span class="lineNum">    5496</span>              :                  * addr - Station address (for AP mode)</span>
<span id="L5497"><span class="lineNum">    5497</span>              :                  */</span>
<span id="L5498"><span class="lineNum">    5498</span>              :                 const u8 *addr;</span>
<span id="L5499"><span class="lineNum">    5499</span>              : </span>
<span id="L5500"><span class="lineNum">    5500</span>              :                 /**</span>
<span id="L5501"><span class="lineNum">    5501</span>              :                  * reason_code - Reason Code (host byte order) used in</span>
<span id="L5502"><span class="lineNum">    5502</span>              :                  *      Deauthentication frame</span>
<span id="L5503"><span class="lineNum">    5503</span>              :                  */</span>
<span id="L5504"><span class="lineNum">    5504</span>              :                 u16 reason_code;</span>
<span id="L5505"><span class="lineNum">    5505</span>              : </span>
<span id="L5506"><span class="lineNum">    5506</span>              :                 /**</span>
<span id="L5507"><span class="lineNum">    5507</span>              :                  * ie - Optional IE(s) in Disassociation frame</span>
<span id="L5508"><span class="lineNum">    5508</span>              :                  */</span>
<span id="L5509"><span class="lineNum">    5509</span>              :                 const u8 *ie;</span>
<span id="L5510"><span class="lineNum">    5510</span>              : </span>
<span id="L5511"><span class="lineNum">    5511</span>              :                 /**</span>
<span id="L5512"><span class="lineNum">    5512</span>              :                  * ie_len - Length of ie buffer in octets</span>
<span id="L5513"><span class="lineNum">    5513</span>              :                  */</span>
<span id="L5514"><span class="lineNum">    5514</span>              :                 size_t ie_len;</span>
<span id="L5515"><span class="lineNum">    5515</span>              : </span>
<span id="L5516"><span class="lineNum">    5516</span>              :                 /**</span>
<span id="L5517"><span class="lineNum">    5517</span>              :                  * locally_generated - Whether the frame was locally generated</span>
<span id="L5518"><span class="lineNum">    5518</span>              :                  */</span>
<span id="L5519"><span class="lineNum">    5519</span>              :                 int locally_generated;</span>
<span id="L5520"><span class="lineNum">    5520</span>              :         } disassoc_info;</span>
<span id="L5521"><span class="lineNum">    5521</span>              : </span>
<span id="L5522"><span class="lineNum">    5522</span>              :         /**</span>
<span id="L5523"><span class="lineNum">    5523</span>              :          * struct deauth_info - Data for EVENT_DEAUTH events</span>
<span id="L5524"><span class="lineNum">    5524</span>              :          */</span>
<span id="L5525"><span class="lineNum">    5525</span>              :         struct deauth_info {</span>
<span id="L5526"><span class="lineNum">    5526</span>              :                 /**</span>
<span id="L5527"><span class="lineNum">    5527</span>              :                  * addr - Station address (for AP mode)</span>
<span id="L5528"><span class="lineNum">    5528</span>              :                  */</span>
<span id="L5529"><span class="lineNum">    5529</span>              :                 const u8 *addr;</span>
<span id="L5530"><span class="lineNum">    5530</span>              : </span>
<span id="L5531"><span class="lineNum">    5531</span>              :                 /**</span>
<span id="L5532"><span class="lineNum">    5532</span>              :                  * reason_code - Reason Code (host byte order) used in</span>
<span id="L5533"><span class="lineNum">    5533</span>              :                  *      Deauthentication frame</span>
<span id="L5534"><span class="lineNum">    5534</span>              :                  */</span>
<span id="L5535"><span class="lineNum">    5535</span>              :                 u16 reason_code;</span>
<span id="L5536"><span class="lineNum">    5536</span>              : </span>
<span id="L5537"><span class="lineNum">    5537</span>              :                 /**</span>
<span id="L5538"><span class="lineNum">    5538</span>              :                  * ie - Optional IE(s) in Deauthentication frame</span>
<span id="L5539"><span class="lineNum">    5539</span>              :                  */</span>
<span id="L5540"><span class="lineNum">    5540</span>              :                 const u8 *ie;</span>
<span id="L5541"><span class="lineNum">    5541</span>              : </span>
<span id="L5542"><span class="lineNum">    5542</span>              :                 /**</span>
<span id="L5543"><span class="lineNum">    5543</span>              :                  * ie_len - Length of ie buffer in octets</span>
<span id="L5544"><span class="lineNum">    5544</span>              :                  */</span>
<span id="L5545"><span class="lineNum">    5545</span>              :                 size_t ie_len;</span>
<span id="L5546"><span class="lineNum">    5546</span>              : </span>
<span id="L5547"><span class="lineNum">    5547</span>              :                 /**</span>
<span id="L5548"><span class="lineNum">    5548</span>              :                  * locally_generated - Whether the frame was locally generated</span>
<span id="L5549"><span class="lineNum">    5549</span>              :                  */</span>
<span id="L5550"><span class="lineNum">    5550</span>              :                 int locally_generated;</span>
<span id="L5551"><span class="lineNum">    5551</span>              :         } deauth_info;</span>
<span id="L5552"><span class="lineNum">    5552</span>              : </span>
<span id="L5553"><span class="lineNum">    5553</span>              :         /**</span>
<span id="L5554"><span class="lineNum">    5554</span>              :          * struct michael_mic_failure - Data for EVENT_MICHAEL_MIC_FAILURE</span>
<span id="L5555"><span class="lineNum">    5555</span>              :          */</span>
<span id="L5556"><span class="lineNum">    5556</span>              :         struct michael_mic_failure {</span>
<span id="L5557"><span class="lineNum">    5557</span>              :                 int unicast;</span>
<span id="L5558"><span class="lineNum">    5558</span>              :                 const u8 *src;</span>
<span id="L5559"><span class="lineNum">    5559</span>              :         } michael_mic_failure;</span>
<span id="L5560"><span class="lineNum">    5560</span>              : </span>
<span id="L5561"><span class="lineNum">    5561</span>              :         /**</span>
<span id="L5562"><span class="lineNum">    5562</span>              :          * struct interface_status - Data for EVENT_INTERFACE_STATUS</span>
<span id="L5563"><span class="lineNum">    5563</span>              :          */</span>
<span id="L5564"><span class="lineNum">    5564</span>              :         struct interface_status {</span>
<span id="L5565"><span class="lineNum">    5565</span>              :                 unsigned int ifindex;</span>
<span id="L5566"><span class="lineNum">    5566</span>              :                 char ifname[100];</span>
<span id="L5567"><span class="lineNum">    5567</span>              :                 enum {</span>
<span id="L5568"><span class="lineNum">    5568</span>              :                         EVENT_INTERFACE_ADDED, EVENT_INTERFACE_REMOVED</span>
<span id="L5569"><span class="lineNum">    5569</span>              :                 } ievent;</span>
<span id="L5570"><span class="lineNum">    5570</span>              :         } interface_status;</span>
<span id="L5571"><span class="lineNum">    5571</span>              : </span>
<span id="L5572"><span class="lineNum">    5572</span>              :         /**</span>
<span id="L5573"><span class="lineNum">    5573</span>              :          * struct pmkid_candidate - Data for EVENT_PMKID_CANDIDATE</span>
<span id="L5574"><span class="lineNum">    5574</span>              :          */</span>
<span id="L5575"><span class="lineNum">    5575</span>              :         struct pmkid_candidate {</span>
<span id="L5576"><span class="lineNum">    5576</span>              :                 /** BSSID of the PMKID candidate */</span>
<span id="L5577"><span class="lineNum">    5577</span>              :                 u8 bssid[ETH_ALEN];</span>
<span id="L5578"><span class="lineNum">    5578</span>              :                 /** Smaller the index, higher the priority */</span>
<span id="L5579"><span class="lineNum">    5579</span>              :                 int index;</span>
<span id="L5580"><span class="lineNum">    5580</span>              :                 /** Whether RSN IE includes pre-authenticate flag */</span>
<span id="L5581"><span class="lineNum">    5581</span>              :                 int preauth;</span>
<span id="L5582"><span class="lineNum">    5582</span>              :         } pmkid_candidate;</span>
<span id="L5583"><span class="lineNum">    5583</span>              : </span>
<span id="L5584"><span class="lineNum">    5584</span>              :         /**</span>
<span id="L5585"><span class="lineNum">    5585</span>              :          * struct tdls - Data for EVENT_TDLS</span>
<span id="L5586"><span class="lineNum">    5586</span>              :          */</span>
<span id="L5587"><span class="lineNum">    5587</span>              :         struct tdls {</span>
<span id="L5588"><span class="lineNum">    5588</span>              :                 u8 peer[ETH_ALEN];</span>
<span id="L5589"><span class="lineNum">    5589</span>              :                 enum {</span>
<span id="L5590"><span class="lineNum">    5590</span>              :                         TDLS_REQUEST_SETUP,</span>
<span id="L5591"><span class="lineNum">    5591</span>              :                         TDLS_REQUEST_TEARDOWN,</span>
<span id="L5592"><span class="lineNum">    5592</span>              :                         TDLS_REQUEST_DISCOVER,</span>
<span id="L5593"><span class="lineNum">    5593</span>              :                 } oper;</span>
<span id="L5594"><span class="lineNum">    5594</span>              :                 u16 reason_code; /* for teardown */</span>
<span id="L5595"><span class="lineNum">    5595</span>              :         } tdls;</span>
<span id="L5596"><span class="lineNum">    5596</span>              : </span>
<span id="L5597"><span class="lineNum">    5597</span>              :         /**</span>
<span id="L5598"><span class="lineNum">    5598</span>              :          * struct wnm - Data for EVENT_WNM</span>
<span id="L5599"><span class="lineNum">    5599</span>              :          */</span>
<span id="L5600"><span class="lineNum">    5600</span>              :         struct wnm {</span>
<span id="L5601"><span class="lineNum">    5601</span>              :                 u8 addr[ETH_ALEN];</span>
<span id="L5602"><span class="lineNum">    5602</span>              :                 enum {</span>
<span id="L5603"><span class="lineNum">    5603</span>              :                         WNM_OPER_SLEEP,</span>
<span id="L5604"><span class="lineNum">    5604</span>              :                 } oper;</span>
<span id="L5605"><span class="lineNum">    5605</span>              :                 enum {</span>
<span id="L5606"><span class="lineNum">    5606</span>              :                         WNM_SLEEP_ENTER,</span>
<span id="L5607"><span class="lineNum">    5607</span>              :                         WNM_SLEEP_EXIT</span>
<span id="L5608"><span class="lineNum">    5608</span>              :                 } sleep_action;</span>
<span id="L5609"><span class="lineNum">    5609</span>              :                 int sleep_intval;</span>
<span id="L5610"><span class="lineNum">    5610</span>              :                 u16 reason_code;</span>
<span id="L5611"><span class="lineNum">    5611</span>              :                 u8 *buf;</span>
<span id="L5612"><span class="lineNum">    5612</span>              :                 u16 buf_len;</span>
<span id="L5613"><span class="lineNum">    5613</span>              :         } wnm;</span>
<span id="L5614"><span class="lineNum">    5614</span>              : </span>
<span id="L5615"><span class="lineNum">    5615</span>              :         /**</span>
<span id="L5616"><span class="lineNum">    5616</span>              :          * struct ft_ies - FT information elements (EVENT_FT_RESPONSE)</span>
<span id="L5617"><span class="lineNum">    5617</span>              :          *</span>
<span id="L5618"><span class="lineNum">    5618</span>              :          * During FT (IEEE 802.11r) authentication sequence, the driver is</span>
<span id="L5619"><span class="lineNum">    5619</span>              :          * expected to use this event to report received FT IEs (MDIE, FTIE,</span>
<span id="L5620"><span class="lineNum">    5620</span>              :          * RSN IE, TIE, possible resource request) to the supplicant. The FT</span>
<span id="L5621"><span class="lineNum">    5621</span>              :          * IEs for the next message will be delivered through the</span>
<span id="L5622"><span class="lineNum">    5622</span>              :          * struct wpa_driver_ops::update_ft_ies() callback.</span>
<span id="L5623"><span class="lineNum">    5623</span>              :          */</span>
<span id="L5624"><span class="lineNum">    5624</span>              :         struct ft_ies {</span>
<span id="L5625"><span class="lineNum">    5625</span>              :                 const u8 *ies;</span>
<span id="L5626"><span class="lineNum">    5626</span>              :                 size_t ies_len;</span>
<span id="L5627"><span class="lineNum">    5627</span>              :                 int ft_action;</span>
<span id="L5628"><span class="lineNum">    5628</span>              :                 u8 target_ap[ETH_ALEN];</span>
<span id="L5629"><span class="lineNum">    5629</span>              :                 /** Optional IE(s), e.g., WMM TSPEC(s), for RIC-Request */</span>
<span id="L5630"><span class="lineNum">    5630</span>              :                 const u8 *ric_ies;</span>
<span id="L5631"><span class="lineNum">    5631</span>              :                 /** Length of ric_ies buffer in octets */</span>
<span id="L5632"><span class="lineNum">    5632</span>              :                 size_t ric_ies_len;</span>
<span id="L5633"><span class="lineNum">    5633</span>              :         } ft_ies;</span>
<span id="L5634"><span class="lineNum">    5634</span>              : </span>
<span id="L5635"><span class="lineNum">    5635</span>              :         /**</span>
<span id="L5636"><span class="lineNum">    5636</span>              :          * struct ibss_rsn_start - Data for EVENT_IBSS_RSN_START</span>
<span id="L5637"><span class="lineNum">    5637</span>              :          */</span>
<span id="L5638"><span class="lineNum">    5638</span>              :         struct ibss_rsn_start {</span>
<span id="L5639"><span class="lineNum">    5639</span>              :                 u8 peer[ETH_ALEN];</span>
<span id="L5640"><span class="lineNum">    5640</span>              :         } ibss_rsn_start;</span>
<span id="L5641"><span class="lineNum">    5641</span>              : </span>
<span id="L5642"><span class="lineNum">    5642</span>              :         /**</span>
<span id="L5643"><span class="lineNum">    5643</span>              :          * struct auth_info - Data for EVENT_AUTH events</span>
<span id="L5644"><span class="lineNum">    5644</span>              :          */</span>
<span id="L5645"><span class="lineNum">    5645</span>              :         struct auth_info {</span>
<span id="L5646"><span class="lineNum">    5646</span>              :                 u8 peer[ETH_ALEN];</span>
<span id="L5647"><span class="lineNum">    5647</span>              :                 u8 bssid[ETH_ALEN];</span>
<span id="L5648"><span class="lineNum">    5648</span>              :                 u16 auth_type;</span>
<span id="L5649"><span class="lineNum">    5649</span>              :                 u16 auth_transaction;</span>
<span id="L5650"><span class="lineNum">    5650</span>              :                 u16 status_code;</span>
<span id="L5651"><span class="lineNum">    5651</span>              :                 const u8 *ies;</span>
<span id="L5652"><span class="lineNum">    5652</span>              :                 size_t ies_len;</span>
<span id="L5653"><span class="lineNum">    5653</span>              :         } auth;</span>
<span id="L5654"><span class="lineNum">    5654</span>              : </span>
<span id="L5655"><span class="lineNum">    5655</span>              :         /**</span>
<span id="L5656"><span class="lineNum">    5656</span>              :          * struct assoc_reject - Data for EVENT_ASSOC_REJECT events</span>
<span id="L5657"><span class="lineNum">    5657</span>              :          */</span>
<span id="L5658"><span class="lineNum">    5658</span>              :         struct assoc_reject {</span>
<span id="L5659"><span class="lineNum">    5659</span>              :                 /**</span>
<span id="L5660"><span class="lineNum">    5660</span>              :                  * bssid - BSSID of the AP that rejected association</span>
<span id="L5661"><span class="lineNum">    5661</span>              :                  */</span>
<span id="L5662"><span class="lineNum">    5662</span>              :                 const u8 *bssid;</span>
<span id="L5663"><span class="lineNum">    5663</span>              : </span>
<span id="L5664"><span class="lineNum">    5664</span>              :                 /**</span>
<span id="L5665"><span class="lineNum">    5665</span>              :                  * resp_ies - (Re)Association Response IEs</span>
<span id="L5666"><span class="lineNum">    5666</span>              :                  *</span>
<span id="L5667"><span class="lineNum">    5667</span>              :                  * Optional association data from the driver. This data is not</span>
<span id="L5668"><span class="lineNum">    5668</span>              :                  * required WPA, but may be useful for some protocols and as</span>
<span id="L5669"><span class="lineNum">    5669</span>              :                  * such, should be reported if this is available to the driver</span>
<span id="L5670"><span class="lineNum">    5670</span>              :                  * interface.</span>
<span id="L5671"><span class="lineNum">    5671</span>              :                  *</span>
<span id="L5672"><span class="lineNum">    5672</span>              :                  * This should start with the first IE (fixed fields before IEs</span>
<span id="L5673"><span class="lineNum">    5673</span>              :                  * are not included).</span>
<span id="L5674"><span class="lineNum">    5674</span>              :                  */</span>
<span id="L5675"><span class="lineNum">    5675</span>              :                 const u8 *resp_ies;</span>
<span id="L5676"><span class="lineNum">    5676</span>              : </span>
<span id="L5677"><span class="lineNum">    5677</span>              :                 /**</span>
<span id="L5678"><span class="lineNum">    5678</span>              :                  * resp_ies_len - Length of resp_ies in bytes</span>
<span id="L5679"><span class="lineNum">    5679</span>              :                  */</span>
<span id="L5680"><span class="lineNum">    5680</span>              :                 size_t resp_ies_len;</span>
<span id="L5681"><span class="lineNum">    5681</span>              : </span>
<span id="L5682"><span class="lineNum">    5682</span>              :                 /**</span>
<span id="L5683"><span class="lineNum">    5683</span>              :                  * status_code - Status Code from (Re)association Response</span>
<span id="L5684"><span class="lineNum">    5684</span>              :                  */</span>
<span id="L5685"><span class="lineNum">    5685</span>              :                 u16 status_code;</span>
<span id="L5686"><span class="lineNum">    5686</span>              : </span>
<span id="L5687"><span class="lineNum">    5687</span>              :                 /**</span>
<span id="L5688"><span class="lineNum">    5688</span>              :                  * timed_out - Whether failure is due to timeout (etc.) rather</span>
<span id="L5689"><span class="lineNum">    5689</span>              :                  * than explicit rejection response from the AP.</span>
<span id="L5690"><span class="lineNum">    5690</span>              :                  */</span>
<span id="L5691"><span class="lineNum">    5691</span>              :                 int timed_out;</span>
<span id="L5692"><span class="lineNum">    5692</span>              : </span>
<span id="L5693"><span class="lineNum">    5693</span>              :                 /**</span>
<span id="L5694"><span class="lineNum">    5694</span>              :                  * timeout_reason - Reason for the timeout</span>
<span id="L5695"><span class="lineNum">    5695</span>              :                  */</span>
<span id="L5696"><span class="lineNum">    5696</span>              :                 const char *timeout_reason;</span>
<span id="L5697"><span class="lineNum">    5697</span>              : </span>
<span id="L5698"><span class="lineNum">    5698</span>              :                 /**</span>
<span id="L5699"><span class="lineNum">    5699</span>              :                  * fils_erp_next_seq_num - The next sequence number to use in</span>
<span id="L5700"><span class="lineNum">    5700</span>              :                  * FILS ERP messages</span>
<span id="L5701"><span class="lineNum">    5701</span>              :                  */</span>
<span id="L5702"><span class="lineNum">    5702</span>              :                 u16 fils_erp_next_seq_num;</span>
<span id="L5703"><span class="lineNum">    5703</span>              : </span>
<span id="L5704"><span class="lineNum">    5704</span>              :                 /**</span>
<span id="L5705"><span class="lineNum">    5705</span>              :                  * reason_code - Connection failure reason code from the driver</span>
<span id="L5706"><span class="lineNum">    5706</span>              :                  */</span>
<span id="L5707"><span class="lineNum">    5707</span>              :                 enum sta_connect_fail_reason_codes reason_code;</span>
<span id="L5708"><span class="lineNum">    5708</span>              :         } assoc_reject;</span>
<span id="L5709"><span class="lineNum">    5709</span>              : </span>
<span id="L5710"><span class="lineNum">    5710</span>              :         struct timeout_event {</span>
<span id="L5711"><span class="lineNum">    5711</span>              :                 u8 addr[ETH_ALEN];</span>
<span id="L5712"><span class="lineNum">    5712</span>              :         } timeout_event;</span>
<span id="L5713"><span class="lineNum">    5713</span>              : </span>
<span id="L5714"><span class="lineNum">    5714</span>              :         /**</span>
<span id="L5715"><span class="lineNum">    5715</span>              :          * struct tx_status - Data for EVENT_TX_STATUS events</span>
<span id="L5716"><span class="lineNum">    5716</span>              :          */</span>
<span id="L5717"><span class="lineNum">    5717</span>              :         struct tx_status {</span>
<span id="L5718"><span class="lineNum">    5718</span>              :                 u16 type;</span>
<span id="L5719"><span class="lineNum">    5719</span>              :                 u16 stype;</span>
<span id="L5720"><span class="lineNum">    5720</span>              :                 const u8 *dst;</span>
<span id="L5721"><span class="lineNum">    5721</span>              :                 const u8 *data;</span>
<span id="L5722"><span class="lineNum">    5722</span>              :                 size_t data_len;</span>
<span id="L5723"><span class="lineNum">    5723</span>              :                 int ack;</span>
<span id="L5724"><span class="lineNum">    5724</span>              :         } tx_status;</span>
<span id="L5725"><span class="lineNum">    5725</span>              : </span>
<span id="L5726"><span class="lineNum">    5726</span>              :         /**</span>
<span id="L5727"><span class="lineNum">    5727</span>              :          * struct rx_from_unknown - Data for EVENT_RX_FROM_UNKNOWN events</span>
<span id="L5728"><span class="lineNum">    5728</span>              :          */</span>
<span id="L5729"><span class="lineNum">    5729</span>              :         struct rx_from_unknown {</span>
<span id="L5730"><span class="lineNum">    5730</span>              :                 const u8 *bssid;</span>
<span id="L5731"><span class="lineNum">    5731</span>              :                 const u8 *addr;</span>
<span id="L5732"><span class="lineNum">    5732</span>              :                 int wds;</span>
<span id="L5733"><span class="lineNum">    5733</span>              :         } rx_from_unknown;</span>
<span id="L5734"><span class="lineNum">    5734</span>              : </span>
<span id="L5735"><span class="lineNum">    5735</span>              :         /**</span>
<span id="L5736"><span class="lineNum">    5736</span>              :          * struct rx_mgmt - Data for EVENT_RX_MGMT events</span>
<span id="L5737"><span class="lineNum">    5737</span>              :          */</span>
<span id="L5738"><span class="lineNum">    5738</span>              :         struct rx_mgmt {</span>
<span id="L5739"><span class="lineNum">    5739</span>              :                 const u8 *frame;</span>
<span id="L5740"><span class="lineNum">    5740</span>              :                 size_t frame_len;</span>
<span id="L5741"><span class="lineNum">    5741</span>              :                 u32 datarate;</span>
<span id="L5742"><span class="lineNum">    5742</span>              : </span>
<span id="L5743"><span class="lineNum">    5743</span>              :                 /**</span>
<span id="L5744"><span class="lineNum">    5744</span>              :                  * drv_priv - Pointer to store driver private BSS information</span>
<span id="L5745"><span class="lineNum">    5745</span>              :                  *</span>
<span id="L5746"><span class="lineNum">    5746</span>              :                  * If not set to NULL, this is used for comparison with</span>
<span id="L5747"><span class="lineNum">    5747</span>              :                  * hostapd_data-&gt;drv_priv to determine which BSS should process</span>
<span id="L5748"><span class="lineNum">    5748</span>              :                  * the frame.</span>
<span id="L5749"><span class="lineNum">    5749</span>              :                  */</span>
<span id="L5750"><span class="lineNum">    5750</span>              :                 void *drv_priv;</span>
<span id="L5751"><span class="lineNum">    5751</span>              : </span>
<span id="L5752"><span class="lineNum">    5752</span>              :                 /**</span>
<span id="L5753"><span class="lineNum">    5753</span>              :                  * freq - Frequency (in MHz) on which the frame was received</span>
<span id="L5754"><span class="lineNum">    5754</span>              :                  */</span>
<span id="L5755"><span class="lineNum">    5755</span>              :                 int freq;</span>
<span id="L5756"><span class="lineNum">    5756</span>              : </span>
<span id="L5757"><span class="lineNum">    5757</span>              :                 /**</span>
<span id="L5758"><span class="lineNum">    5758</span>              :                  * ssi_signal - Signal strength in dBm (or 0 if not available)</span>
<span id="L5759"><span class="lineNum">    5759</span>              :                  */</span>
<span id="L5760"><span class="lineNum">    5760</span>              :                 int ssi_signal;</span>
<span id="L5761"><span class="lineNum">    5761</span>              :         } rx_mgmt;</span>
<span id="L5762"><span class="lineNum">    5762</span>              : </span>
<span id="L5763"><span class="lineNum">    5763</span>              :         /**</span>
<span id="L5764"><span class="lineNum">    5764</span>              :          * struct remain_on_channel - Data for EVENT_REMAIN_ON_CHANNEL events</span>
<span id="L5765"><span class="lineNum">    5765</span>              :          *</span>
<span id="L5766"><span class="lineNum">    5766</span>              :          * This is also used with EVENT_CANCEL_REMAIN_ON_CHANNEL events.</span>
<span id="L5767"><span class="lineNum">    5767</span>              :          */</span>
<span id="L5768"><span class="lineNum">    5768</span>              :         struct remain_on_channel {</span>
<span id="L5769"><span class="lineNum">    5769</span>              :                 /**</span>
<span id="L5770"><span class="lineNum">    5770</span>              :                  * freq - Channel frequency in MHz</span>
<span id="L5771"><span class="lineNum">    5771</span>              :                  */</span>
<span id="L5772"><span class="lineNum">    5772</span>              :                 unsigned int freq;</span>
<span id="L5773"><span class="lineNum">    5773</span>              : </span>
<span id="L5774"><span class="lineNum">    5774</span>              :                 /**</span>
<span id="L5775"><span class="lineNum">    5775</span>              :                  * duration - Duration to remain on the channel in milliseconds</span>
<span id="L5776"><span class="lineNum">    5776</span>              :                  */</span>
<span id="L5777"><span class="lineNum">    5777</span>              :                 unsigned int duration;</span>
<span id="L5778"><span class="lineNum">    5778</span>              :         } remain_on_channel;</span>
<span id="L5779"><span class="lineNum">    5779</span>              : </span>
<span id="L5780"><span class="lineNum">    5780</span>              :         /**</span>
<span id="L5781"><span class="lineNum">    5781</span>              :          * struct scan_info - Optional data for EVENT_SCAN_RESULTS events</span>
<span id="L5782"><span class="lineNum">    5782</span>              :          * @aborted: Whether the scan was aborted</span>
<span id="L5783"><span class="lineNum">    5783</span>              :          * @freqs: Scanned frequencies in MHz (%NULL = all channels scanned)</span>
<span id="L5784"><span class="lineNum">    5784</span>              :          * @num_freqs: Number of entries in freqs array</span>
<span id="L5785"><span class="lineNum">    5785</span>              :          * @ssids: Scanned SSIDs (%NULL or zero-length SSID indicates wildcard</span>
<span id="L5786"><span class="lineNum">    5786</span>              :          *      SSID)</span>
<span id="L5787"><span class="lineNum">    5787</span>              :          * @num_ssids: Number of entries in ssids array</span>
<span id="L5788"><span class="lineNum">    5788</span>              :          * @external_scan: Whether the scan info is for an external scan</span>
<span id="L5789"><span class="lineNum">    5789</span>              :          * @nl_scan_event: 1 if the source of this scan event is a normal scan,</span>
<span id="L5790"><span class="lineNum">    5790</span>              :          *      0 if the source of the scan event is a vendor scan</span>
<span id="L5791"><span class="lineNum">    5791</span>              :          * @scan_start_tsf: Time when the scan started in terms of TSF of the</span>
<span id="L5792"><span class="lineNum">    5792</span>              :          *      BSS that the interface that requested the scan is connected to</span>
<span id="L5793"><span class="lineNum">    5793</span>              :          *      (if available).</span>
<span id="L5794"><span class="lineNum">    5794</span>              :          * @scan_start_tsf_bssid: The BSSID according to which %scan_start_tsf</span>
<span id="L5795"><span class="lineNum">    5795</span>              :          *      is set.</span>
<span id="L5796"><span class="lineNum">    5796</span>              :          */</span>
<span id="L5797"><span class="lineNum">    5797</span>              :         struct scan_info {</span>
<span id="L5798"><span class="lineNum">    5798</span>              :                 int aborted;</span>
<span id="L5799"><span class="lineNum">    5799</span>              :                 const int *freqs;</span>
<span id="L5800"><span class="lineNum">    5800</span>              :                 size_t num_freqs;</span>
<span id="L5801"><span class="lineNum">    5801</span>              :                 struct wpa_driver_scan_ssid ssids[WPAS_MAX_SCAN_SSIDS];</span>
<span id="L5802"><span class="lineNum">    5802</span>              :                 size_t num_ssids;</span>
<span id="L5803"><span class="lineNum">    5803</span>              :                 int external_scan;</span>
<span id="L5804"><span class="lineNum">    5804</span>              :                 int nl_scan_event;</span>
<span id="L5805"><span class="lineNum">    5805</span>              :                 u64 scan_start_tsf;</span>
<span id="L5806"><span class="lineNum">    5806</span>              :                 u8 scan_start_tsf_bssid[ETH_ALEN];</span>
<span id="L5807"><span class="lineNum">    5807</span>              :         } scan_info;</span>
<span id="L5808"><span class="lineNum">    5808</span>              : </span>
<span id="L5809"><span class="lineNum">    5809</span>              :         /**</span>
<span id="L5810"><span class="lineNum">    5810</span>              :          * struct rx_probe_req - Data for EVENT_RX_PROBE_REQ events</span>
<span id="L5811"><span class="lineNum">    5811</span>              :          */</span>
<span id="L5812"><span class="lineNum">    5812</span>              :         struct rx_probe_req {</span>
<span id="L5813"><span class="lineNum">    5813</span>              :                 /**</span>
<span id="L5814"><span class="lineNum">    5814</span>              :                  * sa - Source address of the received Probe Request frame</span>
<span id="L5815"><span class="lineNum">    5815</span>              :                  */</span>
<span id="L5816"><span class="lineNum">    5816</span>              :                 const u8 *sa;</span>
<span id="L5817"><span class="lineNum">    5817</span>              : </span>
<span id="L5818"><span class="lineNum">    5818</span>              :                 /**</span>
<span id="L5819"><span class="lineNum">    5819</span>              :                  * da - Destination address of the received Probe Request frame</span>
<span id="L5820"><span class="lineNum">    5820</span>              :                  *      or %NULL if not available</span>
<span id="L5821"><span class="lineNum">    5821</span>              :                  */</span>
<span id="L5822"><span class="lineNum">    5822</span>              :                 const u8 *da;</span>
<span id="L5823"><span class="lineNum">    5823</span>              : </span>
<span id="L5824"><span class="lineNum">    5824</span>              :                 /**</span>
<span id="L5825"><span class="lineNum">    5825</span>              :                  * bssid - BSSID of the received Probe Request frame or %NULL</span>
<span id="L5826"><span class="lineNum">    5826</span>              :                  *      if not available</span>
<span id="L5827"><span class="lineNum">    5827</span>              :                  */</span>
<span id="L5828"><span class="lineNum">    5828</span>              :                 const u8 *bssid;</span>
<span id="L5829"><span class="lineNum">    5829</span>              : </span>
<span id="L5830"><span class="lineNum">    5830</span>              :                 /**</span>
<span id="L5831"><span class="lineNum">    5831</span>              :                  * ie - IEs from the Probe Request body</span>
<span id="L5832"><span class="lineNum">    5832</span>              :                  */</span>
<span id="L5833"><span class="lineNum">    5833</span>              :                 const u8 *ie;</span>
<span id="L5834"><span class="lineNum">    5834</span>              : </span>
<span id="L5835"><span class="lineNum">    5835</span>              :                 /**</span>
<span id="L5836"><span class="lineNum">    5836</span>              :                  * ie_len - Length of ie buffer in octets</span>
<span id="L5837"><span class="lineNum">    5837</span>              :                  */</span>
<span id="L5838"><span class="lineNum">    5838</span>              :                 size_t ie_len;</span>
<span id="L5839"><span class="lineNum">    5839</span>              : </span>
<span id="L5840"><span class="lineNum">    5840</span>              :                 /**</span>
<span id="L5841"><span class="lineNum">    5841</span>              :                  * signal - signal strength in dBm (or 0 if not available)</span>
<span id="L5842"><span class="lineNum">    5842</span>              :                  */</span>
<span id="L5843"><span class="lineNum">    5843</span>              :                 int ssi_signal;</span>
<span id="L5844"><span class="lineNum">    5844</span>              :         } rx_probe_req;</span>
<span id="L5845"><span class="lineNum">    5845</span>              : </span>
<span id="L5846"><span class="lineNum">    5846</span>              :         /**</span>
<span id="L5847"><span class="lineNum">    5847</span>              :          * struct new_sta - Data for EVENT_NEW_STA events</span>
<span id="L5848"><span class="lineNum">    5848</span>              :          */</span>
<span id="L5849"><span class="lineNum">    5849</span>              :         struct new_sta {</span>
<span id="L5850"><span class="lineNum">    5850</span>              :                 const u8 *addr;</span>
<span id="L5851"><span class="lineNum">    5851</span>              :         } new_sta;</span>
<span id="L5852"><span class="lineNum">    5852</span>              : </span>
<span id="L5853"><span class="lineNum">    5853</span>              :         /**</span>
<span id="L5854"><span class="lineNum">    5854</span>              :          * struct eapol_rx - Data for EVENT_EAPOL_RX events</span>
<span id="L5855"><span class="lineNum">    5855</span>              :          */</span>
<span id="L5856"><span class="lineNum">    5856</span>              :         struct eapol_rx {</span>
<span id="L5857"><span class="lineNum">    5857</span>              :                 const u8 *src;</span>
<span id="L5858"><span class="lineNum">    5858</span>              :                 const u8 *data;</span>
<span id="L5859"><span class="lineNum">    5859</span>              :                 size_t data_len;</span>
<span id="L5860"><span class="lineNum">    5860</span>              :                 enum frame_encryption encrypted;</span>
<span id="L5861"><span class="lineNum">    5861</span>              :         } eapol_rx;</span>
<span id="L5862"><span class="lineNum">    5862</span>              : </span>
<span id="L5863"><span class="lineNum">    5863</span>              :         /**</span>
<span id="L5864"><span class="lineNum">    5864</span>              :          * signal_change - Data for EVENT_SIGNAL_CHANGE events</span>
<span id="L5865"><span class="lineNum">    5865</span>              :          */</span>
<span id="L5866"><span class="lineNum">    5866</span>              :         struct wpa_signal_info signal_change;</span>
<span id="L5867"><span class="lineNum">    5867</span>              : </span>
<span id="L5868"><span class="lineNum">    5868</span>              :         /**</span>
<span id="L5869"><span class="lineNum">    5869</span>              :          * struct best_channel - Data for EVENT_BEST_CHANNEL events</span>
<span id="L5870"><span class="lineNum">    5870</span>              :          * @freq_24: Best 2.4 GHz band channel frequency in MHz</span>
<span id="L5871"><span class="lineNum">    5871</span>              :          * @freq_5: Best 5 GHz band channel frequency in MHz</span>
<span id="L5872"><span class="lineNum">    5872</span>              :          * @freq_overall: Best channel frequency in MHz</span>
<span id="L5873"><span class="lineNum">    5873</span>              :          *</span>
<span id="L5874"><span class="lineNum">    5874</span>              :          * 0 can be used to indicate no preference in either band.</span>
<span id="L5875"><span class="lineNum">    5875</span>              :          */</span>
<span id="L5876"><span class="lineNum">    5876</span>              :         struct best_channel {</span>
<span id="L5877"><span class="lineNum">    5877</span>              :                 int freq_24;</span>
<span id="L5878"><span class="lineNum">    5878</span>              :                 int freq_5;</span>
<span id="L5879"><span class="lineNum">    5879</span>              :                 int freq_overall;</span>
<span id="L5880"><span class="lineNum">    5880</span>              :         } best_chan;</span>
<span id="L5881"><span class="lineNum">    5881</span>              : </span>
<span id="L5882"><span class="lineNum">    5882</span>              :         struct unprot_deauth {</span>
<span id="L5883"><span class="lineNum">    5883</span>              :                 const u8 *sa;</span>
<span id="L5884"><span class="lineNum">    5884</span>              :                 const u8 *da;</span>
<span id="L5885"><span class="lineNum">    5885</span>              :                 u16 reason_code;</span>
<span id="L5886"><span class="lineNum">    5886</span>              :         } unprot_deauth;</span>
<span id="L5887"><span class="lineNum">    5887</span>              : </span>
<span id="L5888"><span class="lineNum">    5888</span>              :         struct unprot_disassoc {</span>
<span id="L5889"><span class="lineNum">    5889</span>              :                 const u8 *sa;</span>
<span id="L5890"><span class="lineNum">    5890</span>              :                 const u8 *da;</span>
<span id="L5891"><span class="lineNum">    5891</span>              :                 u16 reason_code;</span>
<span id="L5892"><span class="lineNum">    5892</span>              :         } unprot_disassoc;</span>
<span id="L5893"><span class="lineNum">    5893</span>              : </span>
<span id="L5894"><span class="lineNum">    5894</span>              :         /**</span>
<span id="L5895"><span class="lineNum">    5895</span>              :          * struct low_ack - Data for EVENT_STATION_LOW_ACK events</span>
<span id="L5896"><span class="lineNum">    5896</span>              :          * @addr: station address</span>
<span id="L5897"><span class="lineNum">    5897</span>              :          * @num_packets: Number of packets lost (consecutive packets not</span>
<span id="L5898"><span class="lineNum">    5898</span>              :          * acknowledged)</span>
<span id="L5899"><span class="lineNum">    5899</span>              :          */</span>
<span id="L5900"><span class="lineNum">    5900</span>              :         struct low_ack {</span>
<span id="L5901"><span class="lineNum">    5901</span>              :                 u8 addr[ETH_ALEN];</span>
<span id="L5902"><span class="lineNum">    5902</span>              :                 u32 num_packets;</span>
<span id="L5903"><span class="lineNum">    5903</span>              :         } low_ack;</span>
<span id="L5904"><span class="lineNum">    5904</span>              : </span>
<span id="L5905"><span class="lineNum">    5905</span>              :         /**</span>
<span id="L5906"><span class="lineNum">    5906</span>              :          * struct ibss_peer_lost - Data for EVENT_IBSS_PEER_LOST</span>
<span id="L5907"><span class="lineNum">    5907</span>              :          */</span>
<span id="L5908"><span class="lineNum">    5908</span>              :         struct ibss_peer_lost {</span>
<span id="L5909"><span class="lineNum">    5909</span>              :                 u8 peer[ETH_ALEN];</span>
<span id="L5910"><span class="lineNum">    5910</span>              :         } ibss_peer_lost;</span>
<span id="L5911"><span class="lineNum">    5911</span>              : </span>
<span id="L5912"><span class="lineNum">    5912</span>              :         /**</span>
<span id="L5913"><span class="lineNum">    5913</span>              :          * struct driver_gtk_rekey - Data for EVENT_DRIVER_GTK_REKEY</span>
<span id="L5914"><span class="lineNum">    5914</span>              :          */</span>
<span id="L5915"><span class="lineNum">    5915</span>              :         struct driver_gtk_rekey {</span>
<span id="L5916"><span class="lineNum">    5916</span>              :                 const u8 *bssid;</span>
<span id="L5917"><span class="lineNum">    5917</span>              :                 const u8 *replay_ctr;</span>
<span id="L5918"><span class="lineNum">    5918</span>              :         } driver_gtk_rekey;</span>
<span id="L5919"><span class="lineNum">    5919</span>              : </span>
<span id="L5920"><span class="lineNum">    5920</span>              :         /**</span>
<span id="L5921"><span class="lineNum">    5921</span>              :          * struct client_poll - Data for EVENT_DRIVER_CLIENT_POLL_OK events</span>
<span id="L5922"><span class="lineNum">    5922</span>              :          * @addr: station address</span>
<span id="L5923"><span class="lineNum">    5923</span>              :          */</span>
<span id="L5924"><span class="lineNum">    5924</span>              :         struct client_poll {</span>
<span id="L5925"><span class="lineNum">    5925</span>              :                 u8 addr[ETH_ALEN];</span>
<span id="L5926"><span class="lineNum">    5926</span>              :         } client_poll;</span>
<span id="L5927"><span class="lineNum">    5927</span>              : </span>
<span id="L5928"><span class="lineNum">    5928</span>              :         /**</span>
<span id="L5929"><span class="lineNum">    5929</span>              :          * struct eapol_tx_status</span>
<span id="L5930"><span class="lineNum">    5930</span>              :          * @dst: Original destination</span>
<span id="L5931"><span class="lineNum">    5931</span>              :          * @data: Data starting with IEEE 802.1X header (!)</span>
<span id="L5932"><span class="lineNum">    5932</span>              :          * @data_len: Length of data</span>
<span id="L5933"><span class="lineNum">    5933</span>              :          * @ack: Indicates ack or lost frame</span>
<span id="L5934"><span class="lineNum">    5934</span>              :          *</span>
<span id="L5935"><span class="lineNum">    5935</span>              :          * This corresponds to hapd_send_eapol if the frame sent</span>
<span id="L5936"><span class="lineNum">    5936</span>              :          * there isn't just reported as EVENT_TX_STATUS.</span>
<span id="L5937"><span class="lineNum">    5937</span>              :          */</span>
<span id="L5938"><span class="lineNum">    5938</span>              :         struct eapol_tx_status {</span>
<span id="L5939"><span class="lineNum">    5939</span>              :                 const u8 *dst;</span>
<span id="L5940"><span class="lineNum">    5940</span>              :                 const u8 *data;</span>
<span id="L5941"><span class="lineNum">    5941</span>              :                 int data_len;</span>
<span id="L5942"><span class="lineNum">    5942</span>              :                 int ack;</span>
<span id="L5943"><span class="lineNum">    5943</span>              :         } eapol_tx_status;</span>
<span id="L5944"><span class="lineNum">    5944</span>              : </span>
<span id="L5945"><span class="lineNum">    5945</span>              :         /**</span>
<span id="L5946"><span class="lineNum">    5946</span>              :          * struct ch_switch</span>
<span id="L5947"><span class="lineNum">    5947</span>              :          * @freq: Frequency of new channel in MHz</span>
<span id="L5948"><span class="lineNum">    5948</span>              :          * @ht_enabled: Whether this is an HT channel</span>
<span id="L5949"><span class="lineNum">    5949</span>              :          * @ch_offset: Secondary channel offset</span>
<span id="L5950"><span class="lineNum">    5950</span>              :          * @ch_width: Channel width</span>
<span id="L5951"><span class="lineNum">    5951</span>              :          * @cf1: Center frequency 1</span>
<span id="L5952"><span class="lineNum">    5952</span>              :          * @cf2: Center frequency 2</span>
<span id="L5953"><span class="lineNum">    5953</span>              :          */</span>
<span id="L5954"><span class="lineNum">    5954</span>              :         struct ch_switch {</span>
<span id="L5955"><span class="lineNum">    5955</span>              :                 int freq;</span>
<span id="L5956"><span class="lineNum">    5956</span>              :                 int ht_enabled;</span>
<span id="L5957"><span class="lineNum">    5957</span>              :                 int ch_offset;</span>
<span id="L5958"><span class="lineNum">    5958</span>              :                 enum chan_width ch_width;</span>
<span id="L5959"><span class="lineNum">    5959</span>              :                 int cf1;</span>
<span id="L5960"><span class="lineNum">    5960</span>              :                 int cf2;</span>
<span id="L5961"><span class="lineNum">    5961</span>              :         } ch_switch;</span>
<span id="L5962"><span class="lineNum">    5962</span>              : </span>
<span id="L5963"><span class="lineNum">    5963</span>              :         /**</span>
<span id="L5964"><span class="lineNum">    5964</span>              :          * struct connect_failed - Data for EVENT_CONNECT_FAILED_REASON</span>
<span id="L5965"><span class="lineNum">    5965</span>              :          * @addr: Remote client address</span>
<span id="L5966"><span class="lineNum">    5966</span>              :          * @code: Reason code for connection failure</span>
<span id="L5967"><span class="lineNum">    5967</span>              :          */</span>
<span id="L5968"><span class="lineNum">    5968</span>              :         struct connect_failed_reason {</span>
<span id="L5969"><span class="lineNum">    5969</span>              :                 u8 addr[ETH_ALEN];</span>
<span id="L5970"><span class="lineNum">    5970</span>              :                 enum {</span>
<span id="L5971"><span class="lineNum">    5971</span>              :                         MAX_CLIENT_REACHED,</span>
<span id="L5972"><span class="lineNum">    5972</span>              :                         BLOCKED_CLIENT</span>
<span id="L5973"><span class="lineNum">    5973</span>              :                 } code;</span>
<span id="L5974"><span class="lineNum">    5974</span>              :         } connect_failed_reason;</span>
<span id="L5975"><span class="lineNum">    5975</span>              : </span>
<span id="L5976"><span class="lineNum">    5976</span>              :         /**</span>
<span id="L5977"><span class="lineNum">    5977</span>              :          * struct dfs_event - Data for radar detected events</span>
<span id="L5978"><span class="lineNum">    5978</span>              :          * @freq: Frequency of the channel in MHz</span>
<span id="L5979"><span class="lineNum">    5979</span>              :          */</span>
<span id="L5980"><span class="lineNum">    5980</span>              :         struct dfs_event {</span>
<span id="L5981"><span class="lineNum">    5981</span>              :                 int freq;</span>
<span id="L5982"><span class="lineNum">    5982</span>              :                 int ht_enabled;</span>
<span id="L5983"><span class="lineNum">    5983</span>              :                 int chan_offset;</span>
<span id="L5984"><span class="lineNum">    5984</span>              :                 enum chan_width chan_width;</span>
<span id="L5985"><span class="lineNum">    5985</span>              :                 int cf1;</span>
<span id="L5986"><span class="lineNum">    5986</span>              :                 int cf2;</span>
<span id="L5987"><span class="lineNum">    5987</span>              :         } dfs_event;</span>
<span id="L5988"><span class="lineNum">    5988</span>              : </span>
<span id="L5989"><span class="lineNum">    5989</span>              :         /**</span>
<span id="L5990"><span class="lineNum">    5990</span>              :          * survey_results - Survey result data for EVENT_SURVEY</span>
<span id="L5991"><span class="lineNum">    5991</span>              :          * @freq_filter: Requested frequency survey filter, 0 if request</span>
<span id="L5992"><span class="lineNum">    5992</span>              :          *      was for all survey data</span>
<span id="L5993"><span class="lineNum">    5993</span>              :          * @survey_list: Linked list of survey data (struct freq_survey)</span>
<span id="L5994"><span class="lineNum">    5994</span>              :          */</span>
<span id="L5995"><span class="lineNum">    5995</span>              :         struct survey_results {</span>
<span id="L5996"><span class="lineNum">    5996</span>              :                 unsigned int freq_filter;</span>
<span id="L5997"><span class="lineNum">    5997</span>              :                 struct dl_list survey_list; /* struct freq_survey */</span>
<span id="L5998"><span class="lineNum">    5998</span>              :         } survey_results;</span>
<span id="L5999"><span class="lineNum">    5999</span>              : </span>
<span id="L6000"><span class="lineNum">    6000</span>              :         /**</span>
<span id="L6001"><span class="lineNum">    6001</span>              :          * channel_list_changed - Data for EVENT_CHANNEL_LIST_CHANGED</span>
<span id="L6002"><span class="lineNum">    6002</span>              :          * @initiator: Initiator of the regulatory change</span>
<span id="L6003"><span class="lineNum">    6003</span>              :          * @type: Regulatory change type</span>
<span id="L6004"><span class="lineNum">    6004</span>              :          * @alpha2: Country code (or &quot;&quot; if not available)</span>
<span id="L6005"><span class="lineNum">    6005</span>              :          */</span>
<span id="L6006"><span class="lineNum">    6006</span>              :         struct channel_list_changed {</span>
<span id="L6007"><span class="lineNum">    6007</span>              :                 enum reg_change_initiator initiator;</span>
<span id="L6008"><span class="lineNum">    6008</span>              :                 enum reg_type type;</span>
<span id="L6009"><span class="lineNum">    6009</span>              :                 char alpha2[3];</span>
<span id="L6010"><span class="lineNum">    6010</span>              :         } channel_list_changed;</span>
<span id="L6011"><span class="lineNum">    6011</span>              : </span>
<span id="L6012"><span class="lineNum">    6012</span>              :         /**</span>
<span id="L6013"><span class="lineNum">    6013</span>              :          * freq_range - List of frequency ranges</span>
<span id="L6014"><span class="lineNum">    6014</span>              :          *</span>
<span id="L6015"><span class="lineNum">    6015</span>              :          * This is used as the data with EVENT_AVOID_FREQUENCIES.</span>
<span id="L6016"><span class="lineNum">    6016</span>              :          */</span>
<span id="L6017"><span class="lineNum">    6017</span>              :         struct wpa_freq_range_list freq_range;</span>
<span id="L6018"><span class="lineNum">    6018</span>              : </span>
<span id="L6019"><span class="lineNum">    6019</span>              :         /**</span>
<span id="L6020"><span class="lineNum">    6020</span>              :          * struct mesh_peer</span>
<span id="L6021"><span class="lineNum">    6021</span>              :          *</span>
<span id="L6022"><span class="lineNum">    6022</span>              :          * @peer: Peer address</span>
<span id="L6023"><span class="lineNum">    6023</span>              :          * @ies: Beacon IEs</span>
<span id="L6024"><span class="lineNum">    6024</span>              :          * @ie_len: Length of @ies</span>
<span id="L6025"><span class="lineNum">    6025</span>              :          *</span>
<span id="L6026"><span class="lineNum">    6026</span>              :          * Notification of new candidate mesh peer.</span>
<span id="L6027"><span class="lineNum">    6027</span>              :          */</span>
<span id="L6028"><span class="lineNum">    6028</span>              :         struct mesh_peer {</span>
<span id="L6029"><span class="lineNum">    6029</span>              :                 const u8 *peer;</span>
<span id="L6030"><span class="lineNum">    6030</span>              :                 const u8 *ies;</span>
<span id="L6031"><span class="lineNum">    6031</span>              :                 size_t ie_len;</span>
<span id="L6032"><span class="lineNum">    6032</span>              :         } mesh_peer;</span>
<span id="L6033"><span class="lineNum">    6033</span>              : </span>
<span id="L6034"><span class="lineNum">    6034</span>              :         /**</span>
<span id="L6035"><span class="lineNum">    6035</span>              :          * struct acs_selected_channels - Data for EVENT_ACS_CHANNEL_SELECTED</span>
<span id="L6036"><span class="lineNum">    6036</span>              :          * @pri_freq: Selected primary frequency</span>
<span id="L6037"><span class="lineNum">    6037</span>              :          * @sec_freq: Selected secondary frequency</span>
<span id="L6038"><span class="lineNum">    6038</span>              :          * @edmg_channel: Selected EDMG channel</span>
<span id="L6039"><span class="lineNum">    6039</span>              :          * @vht_seg0_center_ch: VHT mode Segment0 center channel</span>
<span id="L6040"><span class="lineNum">    6040</span>              :          *      The value is the index of the channel center frequency for</span>
<span id="L6041"><span class="lineNum">    6041</span>              :          *      20 MHz, 40 MHz, and 80 MHz channels. The value is the center</span>
<span id="L6042"><span class="lineNum">    6042</span>              :          *      frequency index of the primary 80 MHz segment for 160 MHz and</span>
<span id="L6043"><span class="lineNum">    6043</span>              :          *      80+80 MHz channels.</span>
<span id="L6044"><span class="lineNum">    6044</span>              :          * @vht_seg1_center_ch: VHT mode Segment1 center channel</span>
<span id="L6045"><span class="lineNum">    6045</span>              :          *      The value is zero for 20 MHz, 40 MHz, and 80 MHz channels. The</span>
<span id="L6046"><span class="lineNum">    6046</span>              :          *      value is the index of the channel center frequency for 160 MHz</span>
<span id="L6047"><span class="lineNum">    6047</span>              :          *      channels and the center frequency index of the secondary 80 MHz</span>
<span id="L6048"><span class="lineNum">    6048</span>              :          *      segment for 80+80 MHz channels.</span>
<span id="L6049"><span class="lineNum">    6049</span>              :          * @ch_width: Selected Channel width by driver. Driver may choose to</span>
<span id="L6050"><span class="lineNum">    6050</span>              :          *      change hostapd configured ACS channel width due driver internal</span>
<span id="L6051"><span class="lineNum">    6051</span>              :          *      channel restrictions.</span>
<span id="L6052"><span class="lineNum">    6052</span>              :          * hw_mode: Selected band (used with hw_mode=any)</span>
<span id="L6053"><span class="lineNum">    6053</span>              :          */</span>
<span id="L6054"><span class="lineNum">    6054</span>              :         struct acs_selected_channels {</span>
<span id="L6055"><span class="lineNum">    6055</span>              :                 unsigned int pri_freq;</span>
<span id="L6056"><span class="lineNum">    6056</span>              :                 unsigned int sec_freq;</span>
<span id="L6057"><span class="lineNum">    6057</span>              :                 u8 edmg_channel;</span>
<span id="L6058"><span class="lineNum">    6058</span>              :                 u8 vht_seg0_center_ch;</span>
<span id="L6059"><span class="lineNum">    6059</span>              :                 u8 vht_seg1_center_ch;</span>
<span id="L6060"><span class="lineNum">    6060</span>              :                 u16 ch_width;</span>
<span id="L6061"><span class="lineNum">    6061</span>              :                 enum hostapd_hw_mode hw_mode;</span>
<span id="L6062"><span class="lineNum">    6062</span>              :         } acs_selected_channels;</span>
<span id="L6063"><span class="lineNum">    6063</span>              : </span>
<span id="L6064"><span class="lineNum">    6064</span>              :         /**</span>
<span id="L6065"><span class="lineNum">    6065</span>              :          * struct p2p_lo_stop - Reason code for P2P Listen offload stop event</span>
<span id="L6066"><span class="lineNum">    6066</span>              :          * @reason_code: Reason for stopping offload</span>
<span id="L6067"><span class="lineNum">    6067</span>              :          *      P2P_LO_STOPPED_REASON_COMPLETE: Listen offload finished as</span>
<span id="L6068"><span class="lineNum">    6068</span>              :          *      scheduled.</span>
<span id="L6069"><span class="lineNum">    6069</span>              :          *      P2P_LO_STOPPED_REASON_RECV_STOP_CMD: Host requested offload to</span>
<span id="L6070"><span class="lineNum">    6070</span>              :          *      be stopped.</span>
<span id="L6071"><span class="lineNum">    6071</span>              :          *      P2P_LO_STOPPED_REASON_INVALID_PARAM: Invalid listen offload</span>
<span id="L6072"><span class="lineNum">    6072</span>              :          *      parameters.</span>
<span id="L6073"><span class="lineNum">    6073</span>              :          *      P2P_LO_STOPPED_REASON_NOT_SUPPORTED: Listen offload not</span>
<span id="L6074"><span class="lineNum">    6074</span>              :          *      supported by device.</span>
<span id="L6075"><span class="lineNum">    6075</span>              :          */</span>
<span id="L6076"><span class="lineNum">    6076</span>              :         struct p2p_lo_stop {</span>
<span id="L6077"><span class="lineNum">    6077</span>              :                 enum {</span>
<span id="L6078"><span class="lineNum">    6078</span>              :                         P2P_LO_STOPPED_REASON_COMPLETE = 0,</span>
<span id="L6079"><span class="lineNum">    6079</span>              :                         P2P_LO_STOPPED_REASON_RECV_STOP_CMD,</span>
<span id="L6080"><span class="lineNum">    6080</span>              :                         P2P_LO_STOPPED_REASON_INVALID_PARAM,</span>
<span id="L6081"><span class="lineNum">    6081</span>              :                         P2P_LO_STOPPED_REASON_NOT_SUPPORTED,</span>
<span id="L6082"><span class="lineNum">    6082</span>              :                 } reason_code;</span>
<span id="L6083"><span class="lineNum">    6083</span>              :         } p2p_lo_stop;</span>
<span id="L6084"><span class="lineNum">    6084</span>              : </span>
<span id="L6085"><span class="lineNum">    6085</span>              :         /* For EVENT_EXTERNAL_AUTH */</span>
<span id="L6086"><span class="lineNum">    6086</span>              :         struct external_auth external_auth;</span>
<span id="L6087"><span class="lineNum">    6087</span>              : </span>
<span id="L6088"><span class="lineNum">    6088</span>              :         /**</span>
<span id="L6089"><span class="lineNum">    6089</span>              :          * struct sta_opmode - Station's operation mode change event</span>
<span id="L6090"><span class="lineNum">    6090</span>              :          * @addr: The station MAC address</span>
<span id="L6091"><span class="lineNum">    6091</span>              :          * @smps_mode: SMPS mode of the station</span>
<span id="L6092"><span class="lineNum">    6092</span>              :          * @chan_width: Channel width of the station</span>
<span id="L6093"><span class="lineNum">    6093</span>              :          * @rx_nss: RX_NSS of the station</span>
<span id="L6094"><span class="lineNum">    6094</span>              :          *</span>
<span id="L6095"><span class="lineNum">    6095</span>              :          * This is used as data with EVENT_STATION_OPMODE_CHANGED.</span>
<span id="L6096"><span class="lineNum">    6096</span>              :          */</span>
<span id="L6097"><span class="lineNum">    6097</span>              :         struct sta_opmode {</span>
<span id="L6098"><span class="lineNum">    6098</span>              :                 const u8 *addr;</span>
<span id="L6099"><span class="lineNum">    6099</span>              :                 enum smps_mode smps_mode;</span>
<span id="L6100"><span class="lineNum">    6100</span>              :                 enum chan_width chan_width;</span>
<span id="L6101"><span class="lineNum">    6101</span>              :                 u8 rx_nss;</span>
<span id="L6102"><span class="lineNum">    6102</span>              :         } sta_opmode;</span>
<span id="L6103"><span class="lineNum">    6103</span>              : </span>
<span id="L6104"><span class="lineNum">    6104</span>              :         /**</span>
<span id="L6105"><span class="lineNum">    6105</span>              :          * struct wds_sta_interface - Data for EVENT_WDS_STA_INTERFACE_STATUS.</span>
<span id="L6106"><span class="lineNum">    6106</span>              :          */</span>
<span id="L6107"><span class="lineNum">    6107</span>              :         struct wds_sta_interface {</span>
<span id="L6108"><span class="lineNum">    6108</span>              :                 const u8 *sta_addr;</span>
<span id="L6109"><span class="lineNum">    6109</span>              :                 const char *ifname;</span>
<span id="L6110"><span class="lineNum">    6110</span>              :                 enum {</span>
<span id="L6111"><span class="lineNum">    6111</span>              :                         INTERFACE_ADDED,</span>
<span id="L6112"><span class="lineNum">    6112</span>              :                         INTERFACE_REMOVED</span>
<span id="L6113"><span class="lineNum">    6113</span>              :                 } istatus;</span>
<span id="L6114"><span class="lineNum">    6114</span>              :         } wds_sta_interface;</span>
<span id="L6115"><span class="lineNum">    6115</span>              : </span>
<span id="L6116"><span class="lineNum">    6116</span>              :         /**</span>
<span id="L6117"><span class="lineNum">    6117</span>              :          * struct update_dh - Data for EVENT_UPDATE_DH</span>
<span id="L6118"><span class="lineNum">    6118</span>              :          */</span>
<span id="L6119"><span class="lineNum">    6119</span>              :         struct update_dh {</span>
<span id="L6120"><span class="lineNum">    6120</span>              :                 const u8 *peer;</span>
<span id="L6121"><span class="lineNum">    6121</span>              :                 const u8 *ie;</span>
<span id="L6122"><span class="lineNum">    6122</span>              :                 size_t ie_len;</span>
<span id="L6123"><span class="lineNum">    6123</span>              :         } update_dh;</span>
<span id="L6124"><span class="lineNum">    6124</span>              : </span>
<span id="L6125"><span class="lineNum">    6125</span>              :         /**</span>
<span id="L6126"><span class="lineNum">    6126</span>              :          * struct unprot_beacon - Data for EVENT_UNPROT_BEACON</span>
<span id="L6127"><span class="lineNum">    6127</span>              :          */</span>
<span id="L6128"><span class="lineNum">    6128</span>              :         struct unprot_beacon {</span>
<span id="L6129"><span class="lineNum">    6129</span>              :                 const u8 *sa;</span>
<span id="L6130"><span class="lineNum">    6130</span>              :         } unprot_beacon;</span>
<span id="L6131"><span class="lineNum">    6131</span>              : </span>
<span id="L6132"><span class="lineNum">    6132</span>              :         /**</span>
<span id="L6133"><span class="lineNum">    6133</span>              :          * struct bss_color_collision - Data for EVENT_BSS_COLOR_COLLISION</span>
<span id="L6134"><span class="lineNum">    6134</span>              :          */</span>
<span id="L6135"><span class="lineNum">    6135</span>              :         struct bss_color_collision {</span>
<span id="L6136"><span class="lineNum">    6136</span>              :                 u64 bitmap;</span>
<span id="L6137"><span class="lineNum">    6137</span>              :         } bss_color_collision;</span>
<span id="L6138"><span class="lineNum">    6138</span>              : };</span>
<span id="L6139"><span class="lineNum">    6139</span>              : </span>
<span id="L6140"><span class="lineNum">    6140</span>              : /**</span>
<span id="L6141"><span class="lineNum">    6141</span>              :  * wpa_supplicant_event - Report a driver event for wpa_supplicant</span>
<span id="L6142"><span class="lineNum">    6142</span>              :  * @ctx: Context pointer (wpa_s); this is the ctx variable registered</span>
<span id="L6143"><span class="lineNum">    6143</span>              :  *      with struct wpa_driver_ops::init()</span>
<span id="L6144"><span class="lineNum">    6144</span>              :  * @event: event type (defined above)</span>
<span id="L6145"><span class="lineNum">    6145</span>              :  * @data: possible extra data for the event</span>
<span id="L6146"><span class="lineNum">    6146</span>              :  *</span>
<span id="L6147"><span class="lineNum">    6147</span>              :  * Driver wrapper code should call this function whenever an event is received</span>
<span id="L6148"><span class="lineNum">    6148</span>              :  * from the driver.</span>
<span id="L6149"><span class="lineNum">    6149</span>              :  */</span>
<span id="L6150"><span class="lineNum">    6150</span>              : void wpa_supplicant_event(void *ctx, enum wpa_event_type event,</span>
<span id="L6151"><span class="lineNum">    6151</span>              :                           union wpa_event_data *data);</span>
<span id="L6152"><span class="lineNum">    6152</span>              : </span>
<span id="L6153"><span class="lineNum">    6153</span>              : /**</span>
<span id="L6154"><span class="lineNum">    6154</span>              :  * wpa_supplicant_event_global - Report a driver event for wpa_supplicant</span>
<span id="L6155"><span class="lineNum">    6155</span>              :  * @ctx: Context pointer (wpa_s); this is the ctx variable registered</span>
<span id="L6156"><span class="lineNum">    6156</span>              :  *      with struct wpa_driver_ops::init()</span>
<span id="L6157"><span class="lineNum">    6157</span>              :  * @event: event type (defined above)</span>
<span id="L6158"><span class="lineNum">    6158</span>              :  * @data: possible extra data for the event</span>
<span id="L6159"><span class="lineNum">    6159</span>              :  *</span>
<span id="L6160"><span class="lineNum">    6160</span>              :  * Same as wpa_supplicant_event(), but we search for the interface in</span>
<span id="L6161"><span class="lineNum">    6161</span>              :  * wpa_global.</span>
<span id="L6162"><span class="lineNum">    6162</span>              :  */</span>
<span id="L6163"><span class="lineNum">    6163</span>              : void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,</span>
<span id="L6164"><span class="lineNum">    6164</span>              :                                  union wpa_event_data *data);</span>
<span id="L6165"><span class="lineNum">    6165</span>              : </span>
<span id="L6166"><span class="lineNum">    6166</span>              : /*</span>
<span id="L6167"><span class="lineNum">    6167</span>              :  * The following inline functions are provided for convenience to simplify</span>
<span id="L6168"><span class="lineNum">    6168</span>              :  * event indication for some of the common events.</span>
<span id="L6169"><span class="lineNum">    6169</span>              :  */</span>
<span id="L6170"><span class="lineNum">    6170</span>              : </span>
<span id="L6171"><span class="lineNum">    6171</span> <span class="tlaUNC tlaBgUNC">           0 : static inline void drv_event_assoc(void *ctx, const u8 *addr, const u8 *ie,</span></span>
<span id="L6172"><span class="lineNum">    6172</span>              :                                    size_t ielen, int reassoc)</span>
<span id="L6173"><span class="lineNum">    6173</span>              : {</span>
<span id="L6174"><span class="lineNum">    6174</span>              :         union wpa_event_data event;</span>
<span id="L6175"><span class="lineNum">    6175</span> <span class="tlaUNC">           0 :         os_memset(&amp;event, 0, sizeof(event));</span></span>
<span id="L6176"><span class="lineNum">    6176</span> <span class="tlaUNC">           0 :         event.assoc_info.reassoc = reassoc;</span></span>
<span id="L6177"><span class="lineNum">    6177</span> <span class="tlaUNC">           0 :         event.assoc_info.req_ies = ie;</span></span>
<span id="L6178"><span class="lineNum">    6178</span> <span class="tlaUNC">           0 :         event.assoc_info.req_ies_len = ielen;</span></span>
<span id="L6179"><span class="lineNum">    6179</span> <span class="tlaUNC">           0 :         event.assoc_info.addr = addr;</span></span>
<span id="L6180"><span class="lineNum">    6180</span> <span class="tlaUNC">           0 :         wpa_supplicant_event(ctx, EVENT_ASSOC, &amp;event);</span></span>
<span id="L6181"><span class="lineNum">    6181</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L6182"><span class="lineNum">    6182</span>              : </span>
<span id="L6183"><span class="lineNum">    6183</span> <span class="tlaUNC">           0 : static inline void drv_event_disassoc(void *ctx, const u8 *addr)</span></span>
<span id="L6184"><span class="lineNum">    6184</span>              : {</span>
<span id="L6185"><span class="lineNum">    6185</span>              :         union wpa_event_data event;</span>
<span id="L6186"><span class="lineNum">    6186</span> <span class="tlaUNC">           0 :         os_memset(&amp;event, 0, sizeof(event));</span></span>
<span id="L6187"><span class="lineNum">    6187</span> <span class="tlaUNC">           0 :         event.disassoc_info.addr = addr;</span></span>
<span id="L6188"><span class="lineNum">    6188</span> <span class="tlaUNC">           0 :         wpa_supplicant_event(ctx, EVENT_DISASSOC, &amp;event);</span></span>
<span id="L6189"><span class="lineNum">    6189</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L6190"><span class="lineNum">    6190</span>              : </span>
<span id="L6191"><span class="lineNum">    6191</span> <span class="tlaUNC">           0 : static inline void drv_event_eapol_rx(void *ctx, const u8 *src, const u8 *data,</span></span>
<span id="L6192"><span class="lineNum">    6192</span>              :                                       size_t data_len)</span>
<span id="L6193"><span class="lineNum">    6193</span>              : {</span>
<span id="L6194"><span class="lineNum">    6194</span>              :         union wpa_event_data event;</span>
<span id="L6195"><span class="lineNum">    6195</span> <span class="tlaUNC">           0 :         os_memset(&amp;event, 0, sizeof(event));</span></span>
<span id="L6196"><span class="lineNum">    6196</span> <span class="tlaUNC">           0 :         event.eapol_rx.src = src;</span></span>
<span id="L6197"><span class="lineNum">    6197</span> <span class="tlaUNC">           0 :         event.eapol_rx.data = data;</span></span>
<span id="L6198"><span class="lineNum">    6198</span> <span class="tlaUNC">           0 :         event.eapol_rx.data_len = data_len;</span></span>
<span id="L6199"><span class="lineNum">    6199</span> <span class="tlaUNC">           0 :         event.eapol_rx.encrypted = FRAME_ENCRYPTION_UNKNOWN;</span></span>
<span id="L6200"><span class="lineNum">    6200</span> <span class="tlaUNC">           0 :         wpa_supplicant_event(ctx, EVENT_EAPOL_RX, &amp;event);</span></span>
<span id="L6201"><span class="lineNum">    6201</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L6202"><span class="lineNum">    6202</span>              : </span>
<span id="L6203"><span class="lineNum">    6203</span> <span class="tlaUNC">           0 : static inline void drv_event_eapol_rx2(void *ctx, const u8 *src, const u8 *data,</span></span>
<span id="L6204"><span class="lineNum">    6204</span>              :                                       size_t data_len,</span>
<span id="L6205"><span class="lineNum">    6205</span>              :                                        enum frame_encryption encrypted)</span>
<span id="L6206"><span class="lineNum">    6206</span>              : {</span>
<span id="L6207"><span class="lineNum">    6207</span>              :         union wpa_event_data event;</span>
<span id="L6208"><span class="lineNum">    6208</span> <span class="tlaUNC">           0 :         os_memset(&amp;event, 0, sizeof(event));</span></span>
<span id="L6209"><span class="lineNum">    6209</span> <span class="tlaUNC">           0 :         event.eapol_rx.src = src;</span></span>
<span id="L6210"><span class="lineNum">    6210</span> <span class="tlaUNC">           0 :         event.eapol_rx.data = data;</span></span>
<span id="L6211"><span class="lineNum">    6211</span> <span class="tlaUNC">           0 :         event.eapol_rx.data_len = data_len;</span></span>
<span id="L6212"><span class="lineNum">    6212</span> <span class="tlaUNC">           0 :         event.eapol_rx.encrypted = encrypted;</span></span>
<span id="L6213"><span class="lineNum">    6213</span> <span class="tlaUNC">           0 :         wpa_supplicant_event(ctx, EVENT_EAPOL_RX, &amp;event);</span></span>
<span id="L6214"><span class="lineNum">    6214</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L6215"><span class="lineNum">    6215</span>              : </span>
<span id="L6216"><span class="lineNum">    6216</span>              : /* driver_common.c */</span>
<span id="L6217"><span class="lineNum">    6217</span>              : void wpa_scan_results_free(struct wpa_scan_results *res);</span>
<span id="L6218"><span class="lineNum">    6218</span>              : </span>
<span id="L6219"><span class="lineNum">    6219</span>              : /* Convert wpa_event_type to a string for logging */</span>
<span id="L6220"><span class="lineNum">    6220</span>              : const char * event_to_string(enum wpa_event_type event);</span>
<span id="L6221"><span class="lineNum">    6221</span>              : </span>
<span id="L6222"><span class="lineNum">    6222</span>              : /* Convert chan_width to a string for logging and control interfaces */</span>
<span id="L6223"><span class="lineNum">    6223</span>              : const char * channel_width_to_string(enum chan_width width);</span>
<span id="L6224"><span class="lineNum">    6224</span>              : </span>
<span id="L6225"><span class="lineNum">    6225</span>              : int channel_width_to_int(enum chan_width width);</span>
<span id="L6226"><span class="lineNum">    6226</span>              : </span>
<span id="L6227"><span class="lineNum">    6227</span>              : int ht_supported(const struct hostapd_hw_modes *mode);</span>
<span id="L6228"><span class="lineNum">    6228</span>              : int vht_supported(const struct hostapd_hw_modes *mode);</span>
<span id="L6229"><span class="lineNum">    6229</span>              : </span>
<span id="L6230"><span class="lineNum">    6230</span>              : struct wowlan_triggers *</span>
<span id="L6231"><span class="lineNum">    6231</span>              : wpa_get_wowlan_triggers(const char *wowlan_triggers,</span>
<span id="L6232"><span class="lineNum">    6232</span>              :                         const struct wpa_driver_capa *capa);</span>
<span id="L6233"><span class="lineNum">    6233</span>              : /* Convert driver flag to string */</span>
<span id="L6234"><span class="lineNum">    6234</span>              : const char * driver_flag_to_string(u64 flag);</span>
<span id="L6235"><span class="lineNum">    6235</span>              : const char * driver_flag2_to_string(u64 flag2);</span>
<span id="L6236"><span class="lineNum">    6236</span>              : </span>
<span id="L6237"><span class="lineNum">    6237</span>              : /* NULL terminated array of linked in driver wrappers */</span>
<span id="L6238"><span class="lineNum">    6238</span>              : extern const struct wpa_driver_ops *const wpa_drivers[];</span>
<span id="L6239"><span class="lineNum">    6239</span>              : </span>
<span id="L6240"><span class="lineNum">    6240</span>              : </span>
<span id="L6241"><span class="lineNum">    6241</span>              : /* Available drivers */</span>
<span id="L6242"><span class="lineNum">    6242</span>              : </span>
<span id="L6243"><span class="lineNum">    6243</span>              : #ifdef CONFIG_DRIVER_WEXT</span>
<span id="L6244"><span class="lineNum">    6244</span>              : extern const struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */</span>
<span id="L6245"><span class="lineNum">    6245</span>              : #endif /* CONFIG_DRIVER_WEXT */</span>
<span id="L6246"><span class="lineNum">    6246</span>              : #ifdef CONFIG_DRIVER_NL80211</span>
<span id="L6247"><span class="lineNum">    6247</span>              : /* driver_nl80211.c */</span>
<span id="L6248"><span class="lineNum">    6248</span>              : extern const struct wpa_driver_ops wpa_driver_nl80211_ops;</span>
<span id="L6249"><span class="lineNum">    6249</span>              : #endif /* CONFIG_DRIVER_NL80211 */</span>
<span id="L6250"><span class="lineNum">    6250</span>              : #ifdef CONFIG_DRIVER_HOSTAP</span>
<span id="L6251"><span class="lineNum">    6251</span>              : extern const struct wpa_driver_ops wpa_driver_hostap_ops; /* driver_hostap.c */</span>
<span id="L6252"><span class="lineNum">    6252</span>              : #endif /* CONFIG_DRIVER_HOSTAP */</span>
<span id="L6253"><span class="lineNum">    6253</span>              : #ifdef CONFIG_DRIVER_BSD</span>
<span id="L6254"><span class="lineNum">    6254</span>              : extern const struct wpa_driver_ops wpa_driver_bsd_ops; /* driver_bsd.c */</span>
<span id="L6255"><span class="lineNum">    6255</span>              : #endif /* CONFIG_DRIVER_BSD */</span>
<span id="L6256"><span class="lineNum">    6256</span>              : #ifdef CONFIG_DRIVER_OPENBSD</span>
<span id="L6257"><span class="lineNum">    6257</span>              : /* driver_openbsd.c */</span>
<span id="L6258"><span class="lineNum">    6258</span>              : extern const struct wpa_driver_ops wpa_driver_openbsd_ops;</span>
<span id="L6259"><span class="lineNum">    6259</span>              : #endif /* CONFIG_DRIVER_OPENBSD */</span>
<span id="L6260"><span class="lineNum">    6260</span>              : #ifdef CONFIG_DRIVER_NDIS</span>
<span id="L6261"><span class="lineNum">    6261</span>              : extern struct wpa_driver_ops wpa_driver_ndis_ops; /* driver_ndis.c */</span>
<span id="L6262"><span class="lineNum">    6262</span>              : #endif /* CONFIG_DRIVER_NDIS */</span>
<span id="L6263"><span class="lineNum">    6263</span>              : #ifdef CONFIG_DRIVER_WIRED</span>
<span id="L6264"><span class="lineNum">    6264</span>              : extern const struct wpa_driver_ops wpa_driver_wired_ops; /* driver_wired.c */</span>
<span id="L6265"><span class="lineNum">    6265</span>              : #endif /* CONFIG_DRIVER_WIRED */</span>
<span id="L6266"><span class="lineNum">    6266</span>              : #ifdef CONFIG_DRIVER_MACSEC_QCA</span>
<span id="L6267"><span class="lineNum">    6267</span>              : /* driver_macsec_qca.c */</span>
<span id="L6268"><span class="lineNum">    6268</span>              : extern const struct wpa_driver_ops wpa_driver_macsec_qca_ops;</span>
<span id="L6269"><span class="lineNum">    6269</span>              : #endif /* CONFIG_DRIVER_MACSEC_QCA */</span>
<span id="L6270"><span class="lineNum">    6270</span>              : #ifdef CONFIG_DRIVER_MACSEC_LINUX</span>
<span id="L6271"><span class="lineNum">    6271</span>              : /* driver_macsec_linux.c */</span>
<span id="L6272"><span class="lineNum">    6272</span>              : extern const struct wpa_driver_ops wpa_driver_macsec_linux_ops;</span>
<span id="L6273"><span class="lineNum">    6273</span>              : #endif /* CONFIG_DRIVER_MACSEC_LINUX */</span>
<span id="L6274"><span class="lineNum">    6274</span>              : #ifdef CONFIG_DRIVER_ROBOSWITCH</span>
<span id="L6275"><span class="lineNum">    6275</span>              : /* driver_roboswitch.c */</span>
<span id="L6276"><span class="lineNum">    6276</span>              : extern const struct wpa_driver_ops wpa_driver_roboswitch_ops;</span>
<span id="L6277"><span class="lineNum">    6277</span>              : #endif /* CONFIG_DRIVER_ROBOSWITCH */</span>
<span id="L6278"><span class="lineNum">    6278</span>              : #ifdef CONFIG_DRIVER_ATHEROS</span>
<span id="L6279"><span class="lineNum">    6279</span>              : /* driver_atheros.c */</span>
<span id="L6280"><span class="lineNum">    6280</span>              : extern const struct wpa_driver_ops wpa_driver_atheros_ops;</span>
<span id="L6281"><span class="lineNum">    6281</span>              : #endif /* CONFIG_DRIVER_ATHEROS */</span>
<span id="L6282"><span class="lineNum">    6282</span>              : #ifdef CONFIG_DRIVER_NONE</span>
<span id="L6283"><span class="lineNum">    6283</span>              : extern const struct wpa_driver_ops wpa_driver_none_ops; /* driver_none.c */</span>
<span id="L6284"><span class="lineNum">    6284</span>              : #endif /* CONFIG_DRIVER_NONE */</span>
<span id="L6285"><span class="lineNum">    6285</span>              : </span>
<span id="L6286"><span class="lineNum">    6286</span>              : #endif /* DRIVER_H */</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version </a></td></tr>
          </table>
          <br>

</body>
</html>
